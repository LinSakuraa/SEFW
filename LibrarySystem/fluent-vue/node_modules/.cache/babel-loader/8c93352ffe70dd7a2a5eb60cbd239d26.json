{"ast":null,"code":"import { ref, watch, onMounted, inject, getCurrentInstance, onBeforeUnmount } from 'vue'; // injection.collection {\n//   key1: [insta, instb]\n//   key2: [instc]\n// }\n\nexport function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {\n  var _a;\n\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;\n  watch(registerKeyRef, registerInstance);\n  registerInstance(registerKeyRef.value);\n  onBeforeUnmount(() => {\n    registerInstance(undefined, registerKeyRef.value);\n  });\n\n  function registerInstance(key, oldKey) {\n    const collection = injection[collectionKey];\n    if (oldKey !== undefined) removeInstance(collection, oldKey);\n    if (key !== undefined) addInstance(collection, key);\n  }\n\n  function removeInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n    collection[key].splice(collection[key].findIndex(instance => instance === vm), 1);\n  }\n\n  function addInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n\n    if (!~collection[key].findIndex(instance => instance === vm)) {\n      collection[key].push(vm);\n    }\n  }\n} // injection.collection {\n//   key1: [insta.value, instb.value]\n//   key2: [instc.value]\n// }\n\nexport function useInjectionCollection(injectionName, collectionKey, valueRef) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n\n  injection[collectionKey].push(valueRef.value);\n  watch(valueRef, (value, prevValue) => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === prevValue);\n    if (~index) collectionArray.splice(index, 1);\n    collectionArray.push(value);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === valueRef.value);\n    if (~index) collectionArray.splice(index, 1);\n  });\n} // injection.collection {\n//   key1: [insta.$el, instb.$el]\n//   key2: [instc.$el]\n// }\n\nexport function useInjectionElementCollection(injectionName, collectionKey, getElement) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n\n  onMounted(() => {\n    const el = getElement();\n    if (!el) return;\n    injection[collectionKey].push(el);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const element = getElement();\n    const index = collectionArray.findIndex(collectionElement => collectionElement === element);\n    if (~index) collectionArray.splice(index, 1);\n  });\n}\nexport function useDeferredTrue(valueRef, delay, shouldDelayRef) {\n  if (!delay) return valueRef;\n  const delayedRef = ref(valueRef.value);\n  let timerId = null;\n  watch(valueRef, value => {\n    if (timerId !== null) window.clearTimeout(timerId);\n\n    if (value === true) {\n      if (shouldDelayRef && !shouldDelayRef.value) {\n        delayedRef.value = true;\n      } else {\n        timerId = window.setTimeout(() => {\n          delayedRef.value = true;\n        }, delay);\n      }\n    } else {\n      delayedRef.value = false;\n    }\n  });\n  return delayedRef;\n}\nexport { useAdjustedTo } from './use-adjusted-to';\nexport { useHoudini } from './use-houdini';","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/_utils/composable/index.js"],"names":["ref","watch","onMounted","inject","getCurrentInstance","onBeforeUnmount","useInjectionInstanceCollection","injectionName","collectionKey","registerKeyRef","_a","injection","vm","proxy","registerInstance","value","undefined","key","oldKey","collection","removeInstance","addInstance","splice","findIndex","instance","push","useInjectionCollection","valueRef","prevValue","collectionArray","index","collectionValue","useInjectionElementCollection","getElement","el","element","collectionElement","useDeferredTrue","delay","shouldDelayRef","delayedRef","timerId","window","clearTimeout","setTimeout","useAdjustedTo","useHoudini"],"mappings":"AAAA,SAASA,GAAT,EAAcC,KAAd,EAAqBC,SAArB,EAAgCC,MAAhC,EAAwCC,kBAAxC,EAA4DC,eAA5D,QAAmF,KAAnF,C,CACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,8BAAT,CAAwCC,aAAxC,EAAuDC,aAAvD,EAAsEC,cAAtE,EAAsF;AACzF,MAAIC,EAAJ;;AACA,QAAMC,SAAS,GAAGR,MAAM,CAACI,aAAD,EAAgB,IAAhB,CAAxB;AACA,MAAII,SAAS,KAAK,IAAlB,EACI;AACJ,QAAMC,EAAE,GAAG,CAACF,EAAE,GAAGN,kBAAkB,EAAxB,MAAgC,IAAhC,IAAwCM,EAAE,KAAK,KAAK,CAApD,GAAwD,KAAK,CAA7D,GAAiEA,EAAE,CAACG,KAA/E;AACAZ,EAAAA,KAAK,CAACQ,cAAD,EAAiBK,gBAAjB,CAAL;AACAA,EAAAA,gBAAgB,CAACL,cAAc,CAACM,KAAhB,CAAhB;AACAV,EAAAA,eAAe,CAAC,MAAM;AAClBS,IAAAA,gBAAgB,CAACE,SAAD,EAAYP,cAAc,CAACM,KAA3B,CAAhB;AACH,GAFc,CAAf;;AAGA,WAASD,gBAAT,CAA0BG,GAA1B,EAA+BC,MAA/B,EAAuC;AACnC,UAAMC,UAAU,GAAGR,SAAS,CAACH,aAAD,CAA5B;AACA,QAAIU,MAAM,KAAKF,SAAf,EACII,cAAc,CAACD,UAAD,EAAaD,MAAb,CAAd;AACJ,QAAID,GAAG,KAAKD,SAAZ,EACIK,WAAW,CAACF,UAAD,EAAaF,GAAb,CAAX;AACP;;AACD,WAASG,cAAT,CAAwBD,UAAxB,EAAoCF,GAApC,EAAyC;AACrC,QAAI,CAACE,UAAU,CAACF,GAAD,CAAf,EACIE,UAAU,CAACF,GAAD,CAAV,GAAkB,EAAlB;AACJE,IAAAA,UAAU,CAACF,GAAD,CAAV,CAAgBK,MAAhB,CAAuBH,UAAU,CAACF,GAAD,CAAV,CAAgBM,SAAhB,CAA2BC,QAAD,IAAcA,QAAQ,KAAKZ,EAArD,CAAvB,EAAiF,CAAjF;AACH;;AACD,WAASS,WAAT,CAAqBF,UAArB,EAAiCF,GAAjC,EAAsC;AAClC,QAAI,CAACE,UAAU,CAACF,GAAD,CAAf,EACIE,UAAU,CAACF,GAAD,CAAV,GAAkB,EAAlB;;AACJ,QAAI,CAAC,CAACE,UAAU,CAACF,GAAD,CAAV,CAAgBM,SAAhB,CAA2BC,QAAD,IAAcA,QAAQ,KAAKZ,EAArD,CAAN,EAAgE;AAC5DO,MAAAA,UAAU,CAACF,GAAD,CAAV,CAAgBQ,IAAhB,CAAqBb,EAArB;AACH;AACJ;AACJ,C,CACD;AACA;AACA;AACA;;AACA,OAAO,SAASc,sBAAT,CAAgCnB,aAAhC,EAA+CC,aAA/C,EAA8DmB,QAA9D,EAAwE;AAC3E,QAAMhB,SAAS,GAAGR,MAAM,CAACI,aAAD,EAAgB,IAAhB,CAAxB;AACA,MAAII,SAAS,KAAK,IAAlB,EACI;;AACJ,MAAI,EAAEH,aAAa,IAAIG,SAAnB,CAAJ,EAAmC;AAC/BA,IAAAA,SAAS,CAACH,aAAD,CAAT,GAA2B,EAA3B;AACH;;AACDG,EAAAA,SAAS,CAACH,aAAD,CAAT,CAAyBiB,IAAzB,CAA8BE,QAAQ,CAACZ,KAAvC;AACAd,EAAAA,KAAK,CAAC0B,QAAD,EAAW,CAACZ,KAAD,EAAQa,SAAR,KAAsB;AAClC,UAAMC,eAAe,GAAGlB,SAAS,CAACH,aAAD,CAAjC;AACA,UAAMsB,KAAK,GAAGD,eAAe,CAACN,SAAhB,CAA2BQ,eAAD,IAAqBA,eAAe,KAAKH,SAAnE,CAAd;AACA,QAAI,CAACE,KAAL,EACID,eAAe,CAACP,MAAhB,CAAuBQ,KAAvB,EAA8B,CAA9B;AACJD,IAAAA,eAAe,CAACJ,IAAhB,CAAqBV,KAArB;AACH,GANI,CAAL;AAOAV,EAAAA,eAAe,CAAC,MAAM;AAClB,UAAMwB,eAAe,GAAGlB,SAAS,CAACH,aAAD,CAAjC;AACA,UAAMsB,KAAK,GAAGD,eAAe,CAACN,SAAhB,CAA2BQ,eAAD,IAAqBA,eAAe,KAAKJ,QAAQ,CAACZ,KAA5E,CAAd;AACA,QAAI,CAACe,KAAL,EACID,eAAe,CAACP,MAAhB,CAAuBQ,KAAvB,EAA8B,CAA9B;AACP,GALc,CAAf;AAMH,C,CACD;AACA;AACA;AACA;;AACA,OAAO,SAASE,6BAAT,CAAuCzB,aAAvC,EAAsDC,aAAtD,EAAqEyB,UAArE,EAAiF;AACpF,QAAMtB,SAAS,GAAGR,MAAM,CAACI,aAAD,EAAgB,IAAhB,CAAxB;AACA,MAAII,SAAS,KAAK,IAAlB,EACI;;AACJ,MAAI,EAAEH,aAAa,IAAIG,SAAnB,CAAJ,EAAmC;AAC/BA,IAAAA,SAAS,CAACH,aAAD,CAAT,GAA2B,EAA3B;AACH;;AACDN,EAAAA,SAAS,CAAC,MAAM;AACZ,UAAMgC,EAAE,GAAGD,UAAU,EAArB;AACA,QAAI,CAACC,EAAL,EACI;AACJvB,IAAAA,SAAS,CAACH,aAAD,CAAT,CAAyBiB,IAAzB,CAA8BS,EAA9B;AACH,GALQ,CAAT;AAMA7B,EAAAA,eAAe,CAAC,MAAM;AAClB,UAAMwB,eAAe,GAAGlB,SAAS,CAACH,aAAD,CAAjC;AACA,UAAM2B,OAAO,GAAGF,UAAU,EAA1B;AACA,UAAMH,KAAK,GAAGD,eAAe,CAACN,SAAhB,CAA2Ba,iBAAD,IAAuBA,iBAAiB,KAAKD,OAAvE,CAAd;AACA,QAAI,CAACL,KAAL,EACID,eAAe,CAACP,MAAhB,CAAuBQ,KAAvB,EAA8B,CAA9B;AACP,GANc,CAAf;AAOH;AACD,OAAO,SAASO,eAAT,CAAyBV,QAAzB,EAAmCW,KAAnC,EAA0CC,cAA1C,EAA0D;AAC7D,MAAI,CAACD,KAAL,EACI,OAAOX,QAAP;AACJ,QAAMa,UAAU,GAAGxC,GAAG,CAAC2B,QAAQ,CAACZ,KAAV,CAAtB;AACA,MAAI0B,OAAO,GAAG,IAAd;AACAxC,EAAAA,KAAK,CAAC0B,QAAD,EAAYZ,KAAD,IAAW;AACvB,QAAI0B,OAAO,KAAK,IAAhB,EACIC,MAAM,CAACC,YAAP,CAAoBF,OAApB;;AACJ,QAAI1B,KAAK,KAAK,IAAd,EAAoB;AAChB,UAAIwB,cAAc,IAAI,CAACA,cAAc,CAACxB,KAAtC,EAA6C;AACzCyB,QAAAA,UAAU,CAACzB,KAAX,GAAmB,IAAnB;AACH,OAFD,MAGK;AACD0B,QAAAA,OAAO,GAAGC,MAAM,CAACE,UAAP,CAAkB,MAAM;AAC9BJ,UAAAA,UAAU,CAACzB,KAAX,GAAmB,IAAnB;AACH,SAFS,EAEPuB,KAFO,CAAV;AAGH;AACJ,KATD,MAUK;AACDE,MAAAA,UAAU,CAACzB,KAAX,GAAmB,KAAnB;AACH;AACJ,GAhBI,CAAL;AAiBA,SAAOyB,UAAP;AACH;AACD,SAASK,aAAT,QAA8B,mBAA9B;AACA,SAASC,UAAT,QAA2B,eAA3B","sourcesContent":["import { ref, watch, onMounted, inject, getCurrentInstance, onBeforeUnmount } from 'vue';\n// injection.collection {\n//   key1: [insta, instb]\n//   key2: [instc]\n// }\nexport function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {\n    var _a;\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;\n    watch(registerKeyRef, registerInstance);\n    registerInstance(registerKeyRef.value);\n    onBeforeUnmount(() => {\n        registerInstance(undefined, registerKeyRef.value);\n    });\n    function registerInstance(key, oldKey) {\n        const collection = injection[collectionKey];\n        if (oldKey !== undefined)\n            removeInstance(collection, oldKey);\n        if (key !== undefined)\n            addInstance(collection, key);\n    }\n    function removeInstance(collection, key) {\n        if (!collection[key])\n            collection[key] = [];\n        collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);\n    }\n    function addInstance(collection, key) {\n        if (!collection[key])\n            collection[key] = [];\n        if (!~collection[key].findIndex((instance) => instance === vm)) {\n            collection[key].push(vm);\n        }\n    }\n}\n// injection.collection {\n//   key1: [insta.value, instb.value]\n//   key2: [instc.value]\n// }\nexport function useInjectionCollection(injectionName, collectionKey, valueRef) {\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    if (!(collectionKey in injection)) {\n        injection[collectionKey] = [];\n    }\n    injection[collectionKey].push(valueRef.value);\n    watch(valueRef, (value, prevValue) => {\n        const collectionArray = injection[collectionKey];\n        const index = collectionArray.findIndex((collectionValue) => collectionValue === prevValue);\n        if (~index)\n            collectionArray.splice(index, 1);\n        collectionArray.push(value);\n    });\n    onBeforeUnmount(() => {\n        const collectionArray = injection[collectionKey];\n        const index = collectionArray.findIndex((collectionValue) => collectionValue === valueRef.value);\n        if (~index)\n            collectionArray.splice(index, 1);\n    });\n}\n// injection.collection {\n//   key1: [insta.$el, instb.$el]\n//   key2: [instc.$el]\n// }\nexport function useInjectionElementCollection(injectionName, collectionKey, getElement) {\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    if (!(collectionKey in injection)) {\n        injection[collectionKey] = [];\n    }\n    onMounted(() => {\n        const el = getElement();\n        if (!el)\n            return;\n        injection[collectionKey].push(el);\n    });\n    onBeforeUnmount(() => {\n        const collectionArray = injection[collectionKey];\n        const element = getElement();\n        const index = collectionArray.findIndex((collectionElement) => collectionElement === element);\n        if (~index)\n            collectionArray.splice(index, 1);\n    });\n}\nexport function useDeferredTrue(valueRef, delay, shouldDelayRef) {\n    if (!delay)\n        return valueRef;\n    const delayedRef = ref(valueRef.value);\n    let timerId = null;\n    watch(valueRef, (value) => {\n        if (timerId !== null)\n            window.clearTimeout(timerId);\n        if (value === true) {\n            if (shouldDelayRef && !shouldDelayRef.value) {\n                delayedRef.value = true;\n            }\n            else {\n                timerId = window.setTimeout(() => {\n                    delayedRef.value = true;\n                }, delay);\n            }\n        }\n        else {\n            delayedRef.value = false;\n        }\n    });\n    return delayedRef;\n}\nexport { useAdjustedTo } from './use-adjusted-to';\nexport { useHoudini } from './use-houdini';\n"]},"metadata":{},"sourceType":"module"}