{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, defineComponent, inject, nextTick, watch, toRef, ref, onMounted, onBeforeUnmount, withDirectives } from 'vue';\nimport { zindexable } from 'vdirs';\nimport { useMemo, useIsMounted, onFontsReady } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nimport LazyTeleport from '../../lazy-teleport/src/index';\nimport { getPlacementAndOffsetOfFollower, getProperTransformOrigin, getOffset } from './get-placement-style';\nimport { getPointRect, getRect } from './utils';\nconst style = c([c('.v-binder-follower-container', {\n  position: 'absolute',\n  left: '0',\n  right: '0',\n  top: '0',\n  height: '0',\n  pointerEvents: 'none',\n  zIndex: 'auto'\n}), c('.v-binder-follower-content', {\n  position: 'absolute',\n  zIndex: 'auto'\n}, [c('> *', {\n  pointerEvents: 'all'\n})])]);\nexport default defineComponent({\n  name: 'Follower',\n  inheritAttrs: false,\n  props: {\n    show: Boolean,\n    enabled: {\n      type: Boolean,\n      default: undefined\n    },\n    placement: {\n      type: String,\n      default: 'bottom'\n    },\n    syncTrigger: {\n      type: Array,\n      default: ['resize', 'scroll']\n    },\n    to: [String, Object],\n    flip: {\n      type: Boolean,\n      default: true\n    },\n    internalShift: Boolean,\n    x: Number,\n    y: Number,\n    width: String,\n    minWidth: String,\n    containerClass: String,\n    teleportDisabled: Boolean,\n    zindexable: {\n      type: Boolean,\n      default: true\n    },\n    zIndex: Number,\n    overlap: Boolean\n  },\n\n  setup(props) {\n    const VBinder = inject('VBinder');\n    const mergedEnabledRef = useMemo(() => {\n      return props.enabled !== undefined ? props.enabled : props.show;\n    });\n    const followerRef = ref(null);\n    const offsetContainerRef = ref(null);\n\n    const ensureListeners = () => {\n      const {\n        syncTrigger\n      } = props;\n\n      if (syncTrigger.includes('scroll')) {\n        VBinder.addScrollListener(syncPosition);\n      }\n\n      if (syncTrigger.includes('resize')) {\n        VBinder.addResizeListener(syncPosition);\n      }\n    };\n\n    const removeListeners = () => {\n      VBinder.removeScrollListener(syncPosition);\n      VBinder.removeResizeListener(syncPosition);\n    };\n\n    onMounted(() => {\n      if (mergedEnabledRef.value) {\n        syncPosition();\n        ensureListeners();\n      }\n    });\n    const ssrAdapter = useSsrAdapter();\n    style.mount({\n      id: 'vueuc/binder',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onBeforeUnmount(() => {\n      removeListeners();\n    });\n    onFontsReady(() => {\n      if (mergedEnabledRef.value) {\n        syncPosition();\n      }\n    });\n\n    const syncPosition = () => {\n      if (!mergedEnabledRef.value) {\n        return;\n      }\n\n      const follower = followerRef.value; // sometimes watched props change before its dom is ready\n      // for example: show=false, x=undefined, y=undefined\n      //              show=true,  x=0,         y=0\n      // will cause error\n      // I may optimize the watch start point later\n\n      if (follower === null) return;\n      const target = VBinder.targetRef;\n      const {\n        x,\n        y,\n        overlap\n      } = props;\n      const targetRect = x !== undefined && y !== undefined ? getPointRect(x, y) : getRect(target);\n      follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);\n      follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);\n      const {\n        width,\n        minWidth,\n        placement,\n        internalShift,\n        flip\n      } = props;\n      follower.setAttribute('v-placement', placement);\n\n      if (overlap) {\n        follower.setAttribute('v-overlap', '');\n      } else {\n        follower.removeAttribute('v-overlap');\n      }\n\n      const {\n        style\n      } = follower;\n\n      if (width === 'target') {\n        style.width = `${targetRect.width}px`;\n      } else if (width !== undefined) {\n        style.width = width;\n      } else {\n        style.width = '';\n      }\n\n      if (minWidth === 'target') {\n        style.minWidth = `${targetRect.width}px`;\n      } else if (minWidth !== undefined) {\n        style.minWidth = minWidth;\n      } else {\n        style.minWidth = '';\n      }\n\n      const followerRect = getRect(follower);\n      const offsetContainerRect = getRect(offsetContainerRef.value);\n      const {\n        left: offsetLeftToStandardPlacement,\n        top: offsetTopToStandardPlacement,\n        placement: properPlacement\n      } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);\n      const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);\n      const {\n        left,\n        top,\n        transform\n      } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap); // we assume that the content size doesn't change after flip,\n      // nor we need to make sync logic more complex\n\n      follower.setAttribute('v-placement', properPlacement);\n      follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);\n      follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);\n      follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;\n      follower.style.transformOrigin = properTransformOrigin;\n    };\n\n    watch(mergedEnabledRef, value => {\n      if (value) {\n        ensureListeners();\n        syncOnNextTick();\n      } else {\n        removeListeners();\n      }\n    });\n\n    const syncOnNextTick = () => {\n      nextTick().then(syncPosition).catch(e => console.error(e));\n    };\n\n    ['placement', 'x', 'y', 'internalShift', 'flip', 'width', 'overlap', 'minWidth'].forEach(prop => {\n      watch(toRef(props, prop), syncPosition);\n    });\n    ['teleportDisabled'].forEach(prop => {\n      watch(toRef(props, prop), syncOnNextTick);\n    });\n    watch(toRef(props, 'syncTrigger'), value => {\n      if (!value.includes('resize')) {\n        VBinder.removeResizeListener(syncPosition);\n      } else {\n        VBinder.addResizeListener(syncPosition);\n      }\n\n      if (!value.includes('scroll')) {\n        VBinder.removeScrollListener(syncPosition);\n      } else {\n        VBinder.addScrollListener(syncPosition);\n      }\n    });\n    const isMountedRef = useIsMounted();\n    const mergedToRef = useMemo(() => {\n      const {\n        to\n      } = props;\n      if (to !== undefined) return to;\n\n      if (isMountedRef.value) {\n        // TODO: find proper container\n        return undefined;\n      }\n\n      return undefined;\n    });\n    return {\n      VBinder,\n      mergedEnabled: mergedEnabledRef,\n      offsetContainerRef,\n      followerRef,\n      mergedTo: mergedToRef,\n      syncPosition\n    };\n  },\n\n  render() {\n    return h(LazyTeleport, {\n      show: this.show,\n      to: this.mergedTo,\n      disabled: this.teleportDisabled\n    }, {\n      default: () => {\n        var _a, _b;\n\n        const vNode = h('div', {\n          class: ['v-binder-follower-container', this.containerClass],\n          ref: 'offsetContainerRef'\n        }, [h('div', {\n          class: 'v-binder-follower-content',\n          ref: 'followerRef'\n        }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))]);\n\n        if (this.zindexable) {\n          return withDirectives(vNode, [[zindexable, {\n            enabled: this.mergedEnabled,\n            zIndex: this.zIndex\n          }]]);\n        }\n\n        return vNode;\n      }\n    });\n  }\n\n});","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/vueuc/es/binder/src/Follower.js"],"names":["h","defineComponent","inject","nextTick","watch","toRef","ref","onMounted","onBeforeUnmount","withDirectives","zindexable","useMemo","useIsMounted","onFontsReady","useSsrAdapter","c","cssrAnchorMetaName","LazyTeleport","getPlacementAndOffsetOfFollower","getProperTransformOrigin","getOffset","getPointRect","getRect","style","position","left","right","top","height","pointerEvents","zIndex","name","inheritAttrs","props","show","Boolean","enabled","type","default","undefined","placement","String","syncTrigger","Array","to","Object","flip","internalShift","x","Number","y","width","minWidth","containerClass","teleportDisabled","overlap","setup","VBinder","mergedEnabledRef","followerRef","offsetContainerRef","ensureListeners","includes","addScrollListener","syncPosition","addResizeListener","removeListeners","removeScrollListener","removeResizeListener","value","ssrAdapter","mount","id","head","anchorMetaName","ssr","follower","target","targetRef","targetRect","setProperty","Math","round","setAttribute","removeAttribute","followerRect","offsetContainerRect","offsetLeftToStandardPlacement","offsetTopToStandardPlacement","properPlacement","properTransformOrigin","transform","transformOrigin","syncOnNextTick","then","catch","e","console","error","forEach","prop","isMountedRef","mergedToRef","mergedEnabled","mergedTo","render","disabled","_a","_b","vNode","class","$slots","call"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, defineComponent, inject, nextTick, watch, toRef, ref, onMounted, onBeforeUnmount, withDirectives } from 'vue';\nimport { zindexable } from 'vdirs';\nimport { useMemo, useIsMounted, onFontsReady } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nimport LazyTeleport from '../../lazy-teleport/src/index';\nimport { getPlacementAndOffsetOfFollower, getProperTransformOrigin, getOffset } from './get-placement-style';\nimport { getPointRect, getRect } from './utils';\nconst style = c([\n    c('.v-binder-follower-container', {\n        position: 'absolute',\n        left: '0',\n        right: '0',\n        top: '0',\n        height: '0',\n        pointerEvents: 'none',\n        zIndex: 'auto'\n    }),\n    c('.v-binder-follower-content', {\n        position: 'absolute',\n        zIndex: 'auto'\n    }, [\n        c('> *', {\n            pointerEvents: 'all'\n        })\n    ])\n]);\nexport default defineComponent({\n    name: 'Follower',\n    inheritAttrs: false,\n    props: {\n        show: Boolean,\n        enabled: {\n            type: Boolean,\n            default: undefined\n        },\n        placement: {\n            type: String,\n            default: 'bottom'\n        },\n        syncTrigger: {\n            type: Array,\n            default: ['resize', 'scroll']\n        },\n        to: [String, Object],\n        flip: {\n            type: Boolean,\n            default: true\n        },\n        internalShift: Boolean,\n        x: Number,\n        y: Number,\n        width: String,\n        minWidth: String,\n        containerClass: String,\n        teleportDisabled: Boolean,\n        zindexable: {\n            type: Boolean,\n            default: true\n        },\n        zIndex: Number,\n        overlap: Boolean\n    },\n    setup(props) {\n        const VBinder = inject('VBinder');\n        const mergedEnabledRef = useMemo(() => {\n            return props.enabled !== undefined ? props.enabled : props.show;\n        });\n        const followerRef = ref(null);\n        const offsetContainerRef = ref(null);\n        const ensureListeners = () => {\n            const { syncTrigger } = props;\n            if (syncTrigger.includes('scroll')) {\n                VBinder.addScrollListener(syncPosition);\n            }\n            if (syncTrigger.includes('resize')) {\n                VBinder.addResizeListener(syncPosition);\n            }\n        };\n        const removeListeners = () => {\n            VBinder.removeScrollListener(syncPosition);\n            VBinder.removeResizeListener(syncPosition);\n        };\n        onMounted(() => {\n            if (mergedEnabledRef.value) {\n                syncPosition();\n                ensureListeners();\n            }\n        });\n        const ssrAdapter = useSsrAdapter();\n        style.mount({\n            id: 'vueuc/binder',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onBeforeUnmount(() => {\n            removeListeners();\n        });\n        onFontsReady(() => {\n            if (mergedEnabledRef.value) {\n                syncPosition();\n            }\n        });\n        const syncPosition = () => {\n            if (!mergedEnabledRef.value) {\n                return;\n            }\n            const follower = followerRef.value;\n            // sometimes watched props change before its dom is ready\n            // for example: show=false, x=undefined, y=undefined\n            //              show=true,  x=0,         y=0\n            // will cause error\n            // I may optimize the watch start point later\n            if (follower === null)\n                return;\n            const target = VBinder.targetRef;\n            const { x, y, overlap } = props;\n            const targetRect = x !== undefined && y !== undefined\n                ? getPointRect(x, y)\n                : getRect(target);\n            follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);\n            follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);\n            const { width, minWidth, placement, internalShift, flip } = props;\n            follower.setAttribute('v-placement', placement);\n            if (overlap) {\n                follower.setAttribute('v-overlap', '');\n            }\n            else {\n                follower.removeAttribute('v-overlap');\n            }\n            const { style } = follower;\n            if (width === 'target') {\n                style.width = `${targetRect.width}px`;\n            }\n            else if (width !== undefined) {\n                style.width = width;\n            }\n            else {\n                style.width = '';\n            }\n            if (minWidth === 'target') {\n                style.minWidth = `${targetRect.width}px`;\n            }\n            else if (minWidth !== undefined) {\n                style.minWidth = minWidth;\n            }\n            else {\n                style.minWidth = '';\n            }\n            const followerRect = getRect(follower);\n            const offsetContainerRect = getRect(offsetContainerRef.value);\n            const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);\n            const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);\n            const { left, top, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);\n            // we assume that the content size doesn't change after flip,\n            // nor we need to make sync logic more complex\n            follower.setAttribute('v-placement', properPlacement);\n            follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);\n            follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);\n            follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;\n            follower.style.transformOrigin = properTransformOrigin;\n        };\n        watch(mergedEnabledRef, (value) => {\n            if (value) {\n                ensureListeners();\n                syncOnNextTick();\n            }\n            else {\n                removeListeners();\n            }\n        });\n        const syncOnNextTick = () => {\n            nextTick()\n                .then(syncPosition)\n                .catch((e) => console.error(e));\n        };\n        [\n            'placement',\n            'x',\n            'y',\n            'internalShift',\n            'flip',\n            'width',\n            'overlap',\n            'minWidth'\n        ].forEach((prop) => {\n            watch(toRef(props, prop), syncPosition);\n        });\n        ['teleportDisabled'].forEach((prop) => {\n            watch(toRef(props, prop), syncOnNextTick);\n        });\n        watch(toRef(props, 'syncTrigger'), (value) => {\n            if (!value.includes('resize')) {\n                VBinder.removeResizeListener(syncPosition);\n            }\n            else {\n                VBinder.addResizeListener(syncPosition);\n            }\n            if (!value.includes('scroll')) {\n                VBinder.removeScrollListener(syncPosition);\n            }\n            else {\n                VBinder.addScrollListener(syncPosition);\n            }\n        });\n        const isMountedRef = useIsMounted();\n        const mergedToRef = useMemo(() => {\n            const { to } = props;\n            if (to !== undefined)\n                return to;\n            if (isMountedRef.value) {\n                // TODO: find proper container\n                return undefined;\n            }\n            return undefined;\n        });\n        return {\n            VBinder,\n            mergedEnabled: mergedEnabledRef,\n            offsetContainerRef,\n            followerRef,\n            mergedTo: mergedToRef,\n            syncPosition\n        };\n    },\n    render() {\n        return h(LazyTeleport, {\n            show: this.show,\n            to: this.mergedTo,\n            disabled: this.teleportDisabled\n        }, {\n            default: () => {\n                var _a, _b;\n                const vNode = h('div', {\n                    class: ['v-binder-follower-container', this.containerClass],\n                    ref: 'offsetContainerRef'\n                }, [\n                    h('div', {\n                        class: 'v-binder-follower-content',\n                        ref: 'followerRef'\n                    }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))\n                ]);\n                if (this.zindexable) {\n                    return withDirectives(vNode, [\n                        [\n                            zindexable,\n                            {\n                                enabled: this.mergedEnabled,\n                                zIndex: this.zIndex\n                            }\n                        ]\n                    ]);\n                }\n                return vNode;\n            }\n        });\n    }\n});\n"]},"metadata":{},"sourceType":"module"}