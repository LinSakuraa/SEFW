{"ast":null,"code":"import { $global } from \"@microsoft/fast-element\";\n/**\n *  A service to batch intersection event callbacks so multiple elements can share a single observer\n *\n * @public\n */\n\nexport class IntersectionService {\n  constructor() {\n    this.intersectionDetector = null;\n    this.observedElements = new Map();\n    /**\n     * Request the position of a target element\n     *\n     * @internal\n     */\n\n    this.requestPosition = (target, callback) => {\n      var _a;\n\n      if (this.intersectionDetector === null) {\n        return;\n      }\n\n      if (this.observedElements.has(target)) {\n        (_a = this.observedElements.get(target)) === null || _a === void 0 ? void 0 : _a.push(callback);\n        return;\n      }\n\n      this.observedElements.set(target, [callback]);\n      this.intersectionDetector.observe(target);\n    };\n    /**\n     * Cancel a position request\n     *\n     * @internal\n     */\n\n\n    this.cancelRequestPosition = (target, callback) => {\n      const callbacks = this.observedElements.get(target);\n\n      if (callbacks !== undefined) {\n        const callBackIndex = callbacks.indexOf(callback);\n\n        if (callBackIndex !== -1) {\n          callbacks.splice(callBackIndex, 1);\n        }\n      }\n    };\n    /**\n     * initialize intersection detector\n     */\n\n\n    this.initializeIntersectionDetector = () => {\n      if (!$global.IntersectionObserver) {\n        //intersection observer not supported\n        return;\n      }\n\n      this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {\n        root: null,\n        rootMargin: \"0px\",\n        threshold: [0, 1]\n      });\n    };\n    /**\n     *  Handle intersections\n     */\n\n\n    this.handleIntersection = entries => {\n      if (this.intersectionDetector === null) {\n        return;\n      }\n\n      const pendingCallbacks = [];\n      const pendingCallbackParams = []; // go through the entries to build a list of callbacks and params for each\n\n      entries.forEach(entry => {\n        var _a; // stop watching this element until we get new update requests for it\n\n\n        (_a = this.intersectionDetector) === null || _a === void 0 ? void 0 : _a.unobserve(entry.target);\n        const thisElementCallbacks = this.observedElements.get(entry.target);\n\n        if (thisElementCallbacks !== undefined) {\n          thisElementCallbacks.forEach(callback => {\n            let targetCallbackIndex = pendingCallbacks.indexOf(callback);\n\n            if (targetCallbackIndex === -1) {\n              targetCallbackIndex = pendingCallbacks.length;\n              pendingCallbacks.push(callback);\n              pendingCallbackParams.push([]);\n            }\n\n            pendingCallbackParams[targetCallbackIndex].push(entry);\n          });\n          this.observedElements.delete(entry.target);\n        }\n      }); // execute callbacks\n\n      pendingCallbacks.forEach((callback, index) => {\n        callback(pendingCallbackParams[index]);\n      });\n    };\n\n    this.initializeIntersectionDetector();\n  }\n\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/utilities/intersection-service.js"],"names":["$global","IntersectionService","constructor","intersectionDetector","observedElements","Map","requestPosition","target","callback","_a","has","get","push","set","observe","cancelRequestPosition","callbacks","undefined","callBackIndex","indexOf","splice","initializeIntersectionDetector","IntersectionObserver","handleIntersection","root","rootMargin","threshold","entries","pendingCallbacks","pendingCallbackParams","forEach","entry","unobserve","thisElementCallbacks","targetCallbackIndex","length","delete","index"],"mappings":"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","sourcesContent":["import { $global } from \"@microsoft/fast-element\";\n/**\n *  A service to batch intersection event callbacks so multiple elements can share a single observer\n *\n * @public\n */\nexport class IntersectionService {\n    constructor() {\n        this.intersectionDetector = null;\n        this.observedElements = new Map();\n        /**\n         * Request the position of a target element\n         *\n         * @internal\n         */\n        this.requestPosition = (target, callback) => {\n            var _a;\n            if (this.intersectionDetector === null) {\n                return;\n            }\n            if (this.observedElements.has(target)) {\n                (_a = this.observedElements.get(target)) === null || _a === void 0 ? void 0 : _a.push(callback);\n                return;\n            }\n            this.observedElements.set(target, [callback]);\n            this.intersectionDetector.observe(target);\n        };\n        /**\n         * Cancel a position request\n         *\n         * @internal\n         */\n        this.cancelRequestPosition = (target, callback) => {\n            const callbacks = this.observedElements.get(target);\n            if (callbacks !== undefined) {\n                const callBackIndex = callbacks.indexOf(callback);\n                if (callBackIndex !== -1) {\n                    callbacks.splice(callBackIndex, 1);\n                }\n            }\n        };\n        /**\n         * initialize intersection detector\n         */\n        this.initializeIntersectionDetector = () => {\n            if (!$global.IntersectionObserver) {\n                //intersection observer not supported\n                return;\n            }\n            this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {\n                root: null,\n                rootMargin: \"0px\",\n                threshold: [0, 1],\n            });\n        };\n        /**\n         *  Handle intersections\n         */\n        this.handleIntersection = (entries) => {\n            if (this.intersectionDetector === null) {\n                return;\n            }\n            const pendingCallbacks = [];\n            const pendingCallbackParams = [];\n            // go through the entries to build a list of callbacks and params for each\n            entries.forEach((entry) => {\n                var _a;\n                // stop watching this element until we get new update requests for it\n                (_a = this.intersectionDetector) === null || _a === void 0 ? void 0 : _a.unobserve(entry.target);\n                const thisElementCallbacks = this.observedElements.get(entry.target);\n                if (thisElementCallbacks !== undefined) {\n                    thisElementCallbacks.forEach((callback) => {\n                        let targetCallbackIndex = pendingCallbacks.indexOf(callback);\n                        if (targetCallbackIndex === -1) {\n                            targetCallbackIndex = pendingCallbacks.length;\n                            pendingCallbacks.push(callback);\n                            pendingCallbackParams.push([]);\n                        }\n                        pendingCallbackParams[targetCallbackIndex].push(entry);\n                    });\n                    this.observedElements.delete(entry.target);\n                }\n            });\n            // execute callbacks\n            pendingCallbacks.forEach((callback, index) => {\n                callback(pendingCallbackParams[index]);\n            });\n        };\n        this.initializeIntersectionDetector();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}