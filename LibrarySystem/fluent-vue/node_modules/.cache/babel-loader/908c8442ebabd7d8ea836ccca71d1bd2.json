{"ast":null,"code":"function ampCount(selector) {\n  let cnt = 0;\n\n  for (let i = 0; i < selector.length; ++i) {\n    if (selector[i] === '&') ++cnt;\n  }\n\n  return cnt;\n}\n/**\n * Don't just use ',' to separate css selector. For example:\n * x:(a, b) {} will be split into 'x:(a' and 'b)', which is not expected.\n * Make sure comma doesn't exist inside parentheses.\n */\n\n\nconst separatorRegex = /\\s*,(?![^(]*\\))\\s*/g;\nconst extraSpaceRegex = /\\s+/g;\n/**\n * selector must includes '&'\n * selector is trimmed\n * every part of amp is trimmed\n */\n\nfunction resolveSelectorWithAmp(amp, selector) {\n  const nextAmp = [];\n  selector.split(separatorRegex).forEach(partialSelector => {\n    let round = ampCount(partialSelector); // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n    if (!round) {\n      amp.forEach(partialAmp => {\n        nextAmp.push( // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        (partialAmp && partialAmp + ' ') + partialSelector);\n      });\n      return;\n    } else if (round === 1) {\n      amp.forEach(partialAmp => {\n        nextAmp.push(partialSelector.replace('&', partialAmp));\n      });\n      return;\n    }\n\n    let partialNextAmp = [partialSelector]; // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n    while (round--) {\n      const nextPartialNextAmp = [];\n      partialNextAmp.forEach(selectorItr => {\n        amp.forEach(partialAmp => {\n          nextPartialNextAmp.push(selectorItr.replace('&', partialAmp));\n        });\n      });\n      partialNextAmp = nextPartialNextAmp;\n    }\n\n    partialNextAmp.forEach(part => nextAmp.push(part));\n  });\n  return nextAmp;\n}\n/**\n * selector mustn't includes '&'\n * selector is trimmed\n */\n\n\nfunction resolveSelector(amp, selector) {\n  const nextAmp = [];\n  selector.split(separatorRegex).forEach(partialSelector => {\n    amp.forEach(partialAmp => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      nextAmp.push((partialAmp && partialAmp + ' ') + partialSelector);\n    });\n  });\n  return nextAmp;\n}\n\nexport function parseSelectorPath(selectorPaths) {\n  let amp = [''];\n  selectorPaths.forEach(selector => {\n    // eslint-disable-next-line\n    selector = selector && selector.trim();\n\n    if ( // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    !selector) {\n      /**\n       * if it's a empty selector, do nothing\n       */\n      return;\n    } // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n\n    if (selector.includes('&')) {\n      amp = resolveSelectorWithAmp(amp, selector);\n    } else {\n      amp = resolveSelector(amp, selector);\n    }\n  });\n  return amp.join(', ').replace(extraSpaceRegex, ' ');\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/css-render/esm/parse.js"],"names":["ampCount","selector","cnt","i","length","separatorRegex","extraSpaceRegex","resolveSelectorWithAmp","amp","nextAmp","split","forEach","partialSelector","round","partialAmp","push","replace","partialNextAmp","nextPartialNextAmp","selectorItr","part","resolveSelector","parseSelectorPath","selectorPaths","trim","includes","join"],"mappings":"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","sourcesContent":["function ampCount(selector) {\n    let cnt = 0;\n    for (let i = 0; i < selector.length; ++i) {\n        if (selector[i] === '&')\n            ++cnt;\n    }\n    return cnt;\n}\n/**\n * Don't just use ',' to separate css selector. For example:\n * x:(a, b) {} will be split into 'x:(a' and 'b)', which is not expected.\n * Make sure comma doesn't exist inside parentheses.\n */\nconst separatorRegex = /\\s*,(?![^(]*\\))\\s*/g;\nconst extraSpaceRegex = /\\s+/g;\n/**\n * selector must includes '&'\n * selector is trimmed\n * every part of amp is trimmed\n */\nfunction resolveSelectorWithAmp(amp, selector) {\n    const nextAmp = [];\n    selector.split(separatorRegex).forEach(partialSelector => {\n        let round = ampCount(partialSelector);\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (!round) {\n            amp.forEach(partialAmp => {\n                nextAmp.push(\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                (partialAmp && partialAmp + ' ') + partialSelector);\n            });\n            return;\n        }\n        else if (round === 1) {\n            amp.forEach(partialAmp => {\n                nextAmp.push(partialSelector.replace('&', partialAmp));\n            });\n            return;\n        }\n        let partialNextAmp = [\n            partialSelector\n        ];\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        while (round--) {\n            const nextPartialNextAmp = [];\n            partialNextAmp.forEach(selectorItr => {\n                amp.forEach(partialAmp => {\n                    nextPartialNextAmp.push(selectorItr.replace('&', partialAmp));\n                });\n            });\n            partialNextAmp = nextPartialNextAmp;\n        }\n        partialNextAmp.forEach(part => nextAmp.push(part));\n    });\n    return nextAmp;\n}\n/**\n * selector mustn't includes '&'\n * selector is trimmed\n */\nfunction resolveSelector(amp, selector) {\n    const nextAmp = [];\n    selector.split(separatorRegex).forEach(partialSelector => {\n        amp.forEach(partialAmp => {\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            nextAmp.push(((partialAmp && partialAmp + ' ') + partialSelector));\n        });\n    });\n    return nextAmp;\n}\nexport function parseSelectorPath(selectorPaths) {\n    let amp = [''];\n    selectorPaths.forEach(selector => {\n        // eslint-disable-next-line\n        selector = selector && selector.trim();\n        if (\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        !selector) {\n            /**\n             * if it's a empty selector, do nothing\n             */\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (selector.includes('&')) {\n            amp = resolveSelectorWithAmp(amp, selector);\n        }\n        else {\n            amp = resolveSelector(amp, selector);\n        }\n    });\n    return amp.join(', ').replace(extraSpaceRegex, ' ');\n}\n"]},"metadata":{},"sourceType":"module"}