{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, DOM, Observable } from \"@microsoft/fast-element\";\nimport { keyEscape, keyTab } from \"@microsoft/fast-web-utilities\";\nimport { isTabbable } from \"tabbable\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A Switch Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#dialog | ARIA dialog }.\n *\n * @public\n */\n\nexport class Dialog extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * Indicates the element is modal. When modal, user mouse interaction will be limited to the contents of the element by a modal\n     * overlay.  Clicks on the overlay will cause the dialog to emit a \"dismiss\" event.\n     * @public\n     * @defaultValue - true\n     * @remarks\n     * HTML Attribute: modal\n     */\n\n    this.modal = true;\n    /**\n     * The hidden state of the element.\n     *\n     * @public\n     * @defaultValue - false\n     * @remarks\n     * HTML Attribute: hidden\n     */\n\n    this.hidden = false;\n    /**\n     * Indicates that the dialog should trap focus.\n     *\n     * @public\n     * @defaultValue - true\n     * @remarks\n     * HTML Attribute: trap-focus\n     */\n\n    this.trapFocus = true;\n\n    this.trapFocusChanged = () => {\n      if (this.$fastController.isConnected) {\n        this.updateTrapFocus();\n      }\n    };\n    /**\n     * @internal\n     */\n\n\n    this.isTrappingFocus = false;\n\n    this.handleDocumentKeydown = e => {\n      if (!e.defaultPrevented && !this.hidden) {\n        switch (e.key) {\n          case keyEscape:\n            this.dismiss();\n            e.preventDefault();\n            break;\n\n          case keyTab:\n            this.handleTabKeyDown(e);\n            break;\n        }\n      }\n    };\n\n    this.handleDocumentFocus = e => {\n      if (!e.defaultPrevented && this.shouldForceFocus(e.target)) {\n        this.focusFirstElement();\n        e.preventDefault();\n      }\n    };\n\n    this.handleTabKeyDown = e => {\n      if (!this.trapFocus || this.hidden) {\n        return;\n      }\n\n      const bounds = this.getTabQueueBounds();\n\n      if (bounds.length === 0) {\n        return;\n      }\n\n      if (bounds.length === 1) {\n        // keep focus on single element\n        bounds[0].focus();\n        e.preventDefault();\n        return;\n      }\n\n      if (e.shiftKey && e.target === bounds[0]) {\n        bounds[bounds.length - 1].focus();\n        e.preventDefault();\n      } else if (!e.shiftKey && e.target === bounds[bounds.length - 1]) {\n        bounds[0].focus();\n        e.preventDefault();\n      }\n\n      return;\n    };\n\n    this.getTabQueueBounds = () => {\n      const bounds = [];\n      return Dialog.reduceTabbableItems(bounds, this);\n    };\n    /**\n     * focus on first element of tab queue\n     */\n\n\n    this.focusFirstElement = () => {\n      const bounds = this.getTabQueueBounds();\n\n      if (bounds.length > 0) {\n        bounds[0].focus();\n      } else {\n        if (this.dialog instanceof HTMLElement) {\n          this.dialog.focus();\n        }\n      }\n    };\n    /**\n     * we should only focus if focus has not already been brought to the dialog\n     */\n\n\n    this.shouldForceFocus = currentFocusElement => {\n      return this.isTrappingFocus && !this.contains(currentFocusElement);\n    };\n    /**\n     * we should we be active trapping focus\n     */\n\n\n    this.shouldTrapFocus = () => {\n      return this.trapFocus && !this.hidden;\n    };\n    /**\n     *\n     *\n     * @internal\n     */\n\n\n    this.updateTrapFocus = shouldTrapFocusOverride => {\n      const shouldTrapFocus = shouldTrapFocusOverride === undefined ? this.shouldTrapFocus() : shouldTrapFocusOverride;\n\n      if (shouldTrapFocus && !this.isTrappingFocus) {\n        this.isTrappingFocus = true; // Add an event listener for focusin events if we are trapping focus\n\n        document.addEventListener(\"focusin\", this.handleDocumentFocus);\n        DOM.queueUpdate(() => {\n          if (this.shouldForceFocus(document.activeElement)) {\n            this.focusFirstElement();\n          }\n        });\n      } else if (!shouldTrapFocus && this.isTrappingFocus) {\n        this.isTrappingFocus = false; // remove event listener if we are not trapping focus\n\n        document.removeEventListener(\"focusin\", this.handleDocumentFocus);\n      }\n    };\n  }\n  /**\n   * @internal\n   */\n\n\n  dismiss() {\n    this.$emit(\"dismiss\");\n  }\n  /**\n   * The method to show the dialog.\n   *\n   * @public\n   */\n\n\n  show() {\n    this.hidden = false;\n  }\n  /**\n   * The method to hide the dialog.\n   *\n   * @public\n   */\n\n\n  hide() {\n    this.hidden = true;\n  }\n  /**\n   * @internal\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    document.addEventListener(\"keydown\", this.handleDocumentKeydown);\n    this.notifier = Observable.getNotifier(this);\n    this.notifier.subscribe(this, \"hidden\");\n    this.updateTrapFocus();\n  }\n  /**\n   * @internal\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback(); // remove keydown event listener\n\n    document.removeEventListener(\"keydown\", this.handleDocumentKeydown); // if we are trapping focus remove the focusin listener\n\n    this.updateTrapFocus(false);\n    this.notifier.unsubscribe(this, \"hidden\");\n  }\n  /**\n   * @internal\n   */\n\n\n  handleChange(source, propertyName) {\n    switch (propertyName) {\n      case \"hidden\":\n        this.updateTrapFocus();\n        break;\n\n      default:\n        break;\n    }\n  }\n  /**\n   * Reduce a collection to only its focusable elements.\n   *\n   * @param elements - Collection of elements to reduce\n   * @param element - The current element\n   *\n   * @internal\n   */\n\n\n  static reduceTabbableItems(elements, element) {\n    if (element.getAttribute(\"tabindex\") === \"-1\") {\n      return elements;\n    }\n\n    if (isTabbable(element) || Dialog.isFocusableFastElement(element) && Dialog.hasTabbableShadow(element)) {\n      elements.push(element);\n      return elements;\n    }\n\n    if (element.childElementCount) {\n      return elements.concat(Array.from(element.children).reduce(Dialog.reduceTabbableItems, []));\n    }\n\n    return elements;\n  }\n  /**\n   * Test if element is focusable fast element\n   *\n   * @param element - The element to check\n   *\n   * @internal\n   */\n\n\n  static isFocusableFastElement(element) {\n    var _a, _b;\n\n    return !!((_b = (_a = element.$fastController) === null || _a === void 0 ? void 0 : _a.definition.shadowOptions) === null || _b === void 0 ? void 0 : _b.delegatesFocus);\n  }\n  /**\n   * Test if the element has a focusable shadow\n   *\n   * @param element - The element to check\n   *\n   * @internal\n   */\n\n\n  static hasTabbableShadow(element) {\n    var _a, _b;\n\n    return Array.from((_b = (_a = element.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"*\")) !== null && _b !== void 0 ? _b : []).some(x => {\n      return isTabbable(x);\n    });\n  }\n\n}\n\n__decorate([attr({\n  mode: \"boolean\"\n})], Dialog.prototype, \"modal\", void 0);\n\n__decorate([attr({\n  mode: \"boolean\"\n})], Dialog.prototype, \"hidden\", void 0);\n\n__decorate([attr({\n  attribute: \"trap-focus\",\n  mode: \"boolean\"\n})], Dialog.prototype, \"trapFocus\", void 0);\n\n__decorate([attr({\n  attribute: \"aria-describedby\"\n})], Dialog.prototype, \"ariaDescribedby\", void 0);\n\n__decorate([attr({\n  attribute: \"aria-labelledby\"\n})], Dialog.prototype, \"ariaLabelledby\", void 0);\n\n__decorate([attr({\n  attribute: \"aria-label\"\n})], Dialog.prototype, \"ariaLabel\", void 0);","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.js"],"names":["__decorate","attr","DOM","Observable","keyEscape","keyTab","isTabbable","FoundationElement","Dialog","constructor","arguments","modal","hidden","trapFocus","trapFocusChanged","$fastController","isConnected","updateTrapFocus","isTrappingFocus","handleDocumentKeydown","e","defaultPrevented","key","dismiss","preventDefault","handleTabKeyDown","handleDocumentFocus","shouldForceFocus","target","focusFirstElement","bounds","getTabQueueBounds","length","focus","shiftKey","reduceTabbableItems","dialog","HTMLElement","currentFocusElement","contains","shouldTrapFocus","shouldTrapFocusOverride","undefined","document","addEventListener","queueUpdate","activeElement","removeEventListener","$emit","show","hide","connectedCallback","notifier","getNotifier","subscribe","disconnectedCallback","unsubscribe","handleChange","source","propertyName","elements","element","getAttribute","isFocusableFastElement","hasTabbableShadow","push","childElementCount","concat","Array","from","children","reduce","_a","_b","definition","shadowOptions","delegatesFocus","shadowRoot","querySelectorAll","some","x","mode","prototype","attribute"],"mappings":"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","sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, Observable } from \"@microsoft/fast-element\";\nimport { keyEscape, keyTab } from \"@microsoft/fast-web-utilities\";\nimport { isTabbable } from \"tabbable\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A Switch Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#dialog | ARIA dialog }.\n *\n * @public\n */\nexport class Dialog extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Indicates the element is modal. When modal, user mouse interaction will be limited to the contents of the element by a modal\n         * overlay.  Clicks on the overlay will cause the dialog to emit a \"dismiss\" event.\n         * @public\n         * @defaultValue - true\n         * @remarks\n         * HTML Attribute: modal\n         */\n        this.modal = true;\n        /**\n         * The hidden state of the element.\n         *\n         * @public\n         * @defaultValue - false\n         * @remarks\n         * HTML Attribute: hidden\n         */\n        this.hidden = false;\n        /**\n         * Indicates that the dialog should trap focus.\n         *\n         * @public\n         * @defaultValue - true\n         * @remarks\n         * HTML Attribute: trap-focus\n         */\n        this.trapFocus = true;\n        this.trapFocusChanged = () => {\n            if (this.$fastController.isConnected) {\n                this.updateTrapFocus();\n            }\n        };\n        /**\n         * @internal\n         */\n        this.isTrappingFocus = false;\n        this.handleDocumentKeydown = (e) => {\n            if (!e.defaultPrevented && !this.hidden) {\n                switch (e.key) {\n                    case keyEscape:\n                        this.dismiss();\n                        e.preventDefault();\n                        break;\n                    case keyTab:\n                        this.handleTabKeyDown(e);\n                        break;\n                }\n            }\n        };\n        this.handleDocumentFocus = (e) => {\n            if (!e.defaultPrevented && this.shouldForceFocus(e.target)) {\n                this.focusFirstElement();\n                e.preventDefault();\n            }\n        };\n        this.handleTabKeyDown = (e) => {\n            if (!this.trapFocus || this.hidden) {\n                return;\n            }\n            const bounds = this.getTabQueueBounds();\n            if (bounds.length === 0) {\n                return;\n            }\n            if (bounds.length === 1) {\n                // keep focus on single element\n                bounds[0].focus();\n                e.preventDefault();\n                return;\n            }\n            if (e.shiftKey && e.target === bounds[0]) {\n                bounds[bounds.length - 1].focus();\n                e.preventDefault();\n            }\n            else if (!e.shiftKey && e.target === bounds[bounds.length - 1]) {\n                bounds[0].focus();\n                e.preventDefault();\n            }\n            return;\n        };\n        this.getTabQueueBounds = () => {\n            const bounds = [];\n            return Dialog.reduceTabbableItems(bounds, this);\n        };\n        /**\n         * focus on first element of tab queue\n         */\n        this.focusFirstElement = () => {\n            const bounds = this.getTabQueueBounds();\n            if (bounds.length > 0) {\n                bounds[0].focus();\n            }\n            else {\n                if (this.dialog instanceof HTMLElement) {\n                    this.dialog.focus();\n                }\n            }\n        };\n        /**\n         * we should only focus if focus has not already been brought to the dialog\n         */\n        this.shouldForceFocus = (currentFocusElement) => {\n            return this.isTrappingFocus && !this.contains(currentFocusElement);\n        };\n        /**\n         * we should we be active trapping focus\n         */\n        this.shouldTrapFocus = () => {\n            return this.trapFocus && !this.hidden;\n        };\n        /**\n         *\n         *\n         * @internal\n         */\n        this.updateTrapFocus = (shouldTrapFocusOverride) => {\n            const shouldTrapFocus = shouldTrapFocusOverride === undefined\n                ? this.shouldTrapFocus()\n                : shouldTrapFocusOverride;\n            if (shouldTrapFocus && !this.isTrappingFocus) {\n                this.isTrappingFocus = true;\n                // Add an event listener for focusin events if we are trapping focus\n                document.addEventListener(\"focusin\", this.handleDocumentFocus);\n                DOM.queueUpdate(() => {\n                    if (this.shouldForceFocus(document.activeElement)) {\n                        this.focusFirstElement();\n                    }\n                });\n            }\n            else if (!shouldTrapFocus && this.isTrappingFocus) {\n                this.isTrappingFocus = false;\n                // remove event listener if we are not trapping focus\n                document.removeEventListener(\"focusin\", this.handleDocumentFocus);\n            }\n        };\n    }\n    /**\n     * @internal\n     */\n    dismiss() {\n        this.$emit(\"dismiss\");\n    }\n    /**\n     * The method to show the dialog.\n     *\n     * @public\n     */\n    show() {\n        this.hidden = false;\n    }\n    /**\n     * The method to hide the dialog.\n     *\n     * @public\n     */\n    hide() {\n        this.hidden = true;\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        document.addEventListener(\"keydown\", this.handleDocumentKeydown);\n        this.notifier = Observable.getNotifier(this);\n        this.notifier.subscribe(this, \"hidden\");\n        this.updateTrapFocus();\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        // remove keydown event listener\n        document.removeEventListener(\"keydown\", this.handleDocumentKeydown);\n        // if we are trapping focus remove the focusin listener\n        this.updateTrapFocus(false);\n        this.notifier.unsubscribe(this, \"hidden\");\n    }\n    /**\n     * @internal\n     */\n    handleChange(source, propertyName) {\n        switch (propertyName) {\n            case \"hidden\":\n                this.updateTrapFocus();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Reduce a collection to only its focusable elements.\n     *\n     * @param elements - Collection of elements to reduce\n     * @param element - The current element\n     *\n     * @internal\n     */\n    static reduceTabbableItems(elements, element) {\n        if (element.getAttribute(\"tabindex\") === \"-1\") {\n            return elements;\n        }\n        if (isTabbable(element) ||\n            (Dialog.isFocusableFastElement(element) && Dialog.hasTabbableShadow(element))) {\n            elements.push(element);\n            return elements;\n        }\n        if (element.childElementCount) {\n            return elements.concat(Array.from(element.children).reduce(Dialog.reduceTabbableItems, []));\n        }\n        return elements;\n    }\n    /**\n     * Test if element is focusable fast element\n     *\n     * @param element - The element to check\n     *\n     * @internal\n     */\n    static isFocusableFastElement(element) {\n        var _a, _b;\n        return !!((_b = (_a = element.$fastController) === null || _a === void 0 ? void 0 : _a.definition.shadowOptions) === null || _b === void 0 ? void 0 : _b.delegatesFocus);\n    }\n    /**\n     * Test if the element has a focusable shadow\n     *\n     * @param element - The element to check\n     *\n     * @internal\n     */\n    static hasTabbableShadow(element) {\n        var _a, _b;\n        return Array.from((_b = (_a = element.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"*\")) !== null && _b !== void 0 ? _b : []).some(x => {\n            return isTabbable(x);\n        });\n    }\n}\n__decorate([\n    attr({ mode: \"boolean\" })\n], Dialog.prototype, \"modal\", void 0);\n__decorate([\n    attr({ mode: \"boolean\" })\n], Dialog.prototype, \"hidden\", void 0);\n__decorate([\n    attr({ attribute: \"trap-focus\", mode: \"boolean\" })\n], Dialog.prototype, \"trapFocus\", void 0);\n__decorate([\n    attr({ attribute: \"aria-describedby\" })\n], Dialog.prototype, \"ariaDescribedby\", void 0);\n__decorate([\n    attr({ attribute: \"aria-labelledby\" })\n], Dialog.prototype, \"ariaLabelledby\", void 0);\n__decorate([\n    attr({ attribute: \"aria-label\" })\n], Dialog.prototype, \"ariaLabel\", void 0);\n"]},"metadata":{},"sourceType":"module"}