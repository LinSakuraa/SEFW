{"ast":null,"code":"import { h, defineComponent, ref, Fragment, onMounted, onBeforeUnmount, watch } from 'vue';\nimport { createId } from 'seemly';\nimport { on, off } from 'evtd';\nimport { focusFirstDescendant, focusLastDescendant } from './utils';\nimport { resolveTo } from '../../shared';\nlet stack = [];\nexport const FocusTrap = defineComponent({\n  name: 'FocusTrap',\n  props: {\n    disabled: Boolean,\n    active: Boolean,\n    autoFocus: {\n      type: Boolean,\n      default: true\n    },\n    onEsc: Function,\n    initialFocusTo: String,\n    finalFocusTo: String,\n    returnFocusOnDeactivated: {\n      type: Boolean,\n      default: true\n    }\n  },\n\n  setup(props) {\n    const id = createId();\n    const focusableStartRef = ref(null);\n    const focusableEndRef = ref(null);\n    let activated = false;\n    let ignoreInternalFocusChange = false;\n    const lastFocusedElement = document.activeElement;\n\n    function isCurrentActive() {\n      const currentActiveId = stack[stack.length - 1];\n      return currentActiveId === id;\n    }\n\n    function handleDocumentKeydown(e) {\n      var _a;\n\n      if (e.code === 'Escape') {\n        if (isCurrentActive()) {\n          (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);\n        }\n      }\n    }\n\n    onMounted(() => {\n      watch(() => props.active, value => {\n        if (value) {\n          activate();\n          on('keydown', document, handleDocumentKeydown);\n        } else {\n          off('keydown', document, handleDocumentKeydown);\n\n          if (activated) {\n            deactivate();\n          }\n        }\n      }, {\n        immediate: true\n      });\n    });\n    onBeforeUnmount(() => {\n      off('keydown', document, handleDocumentKeydown);\n      if (activated) deactivate();\n    });\n\n    function handleDocumentFocus(e) {\n      if (ignoreInternalFocusChange) return;\n\n      if (isCurrentActive()) {\n        const mainEl = getMainEl();\n        if (mainEl === null) return;\n        if (mainEl.contains(e.target)) return; // I don't handle shift + tab status since it's too tricky to handle\n        // Not impossible but I need to sleep\n\n        resetFocusTo('first');\n      }\n    }\n\n    function getMainEl() {\n      const focusableStartEl = focusableStartRef.value;\n      if (focusableStartEl === null) return null;\n      let mainEl = focusableStartEl;\n\n      while (true) {\n        mainEl = mainEl.nextSibling;\n        if (mainEl === null) break;\n\n        if (mainEl instanceof Element && mainEl.tagName === 'DIV') {\n          break;\n        }\n      }\n\n      return mainEl;\n    }\n\n    function activate() {\n      var _a;\n\n      if (props.disabled) return;\n      stack.push(id);\n\n      if (props.autoFocus) {\n        const {\n          initialFocusTo\n        } = props;\n\n        if (initialFocusTo === undefined) {\n          resetFocusTo('first');\n        } else {\n          (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({\n            preventScroll: true\n          });\n        }\n      }\n\n      activated = true;\n      document.addEventListener('focus', handleDocumentFocus, true);\n    }\n\n    function deactivate() {\n      var _a;\n\n      if (props.disabled) return;\n      document.removeEventListener('focus', handleDocumentFocus, true);\n      stack = stack.filter(idInStack => idInStack !== id);\n      if (isCurrentActive()) return;\n      const {\n        finalFocusTo\n      } = props;\n\n      if (finalFocusTo !== undefined) {\n        (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({\n          preventScroll: true\n        });\n      } else if (props.returnFocusOnDeactivated) {\n        if (lastFocusedElement instanceof HTMLElement) {\n          ignoreInternalFocusChange = true;\n          lastFocusedElement.focus({\n            preventScroll: true\n          });\n          ignoreInternalFocusChange = false;\n        }\n      }\n    }\n\n    function resetFocusTo(target) {\n      if (!isCurrentActive()) return;\n\n      if (props.active) {\n        const focusableStartEl = focusableStartRef.value;\n        const focusableEndEl = focusableEndRef.value;\n\n        if (focusableStartEl !== null && focusableEndEl !== null) {\n          const mainEl = getMainEl();\n\n          if (mainEl == null || mainEl === focusableEndEl) {\n            ignoreInternalFocusChange = true;\n            focusableStartEl.focus({\n              preventScroll: true\n            });\n            ignoreInternalFocusChange = false;\n            return;\n          }\n\n          ignoreInternalFocusChange = true;\n          const focused = target === 'first' ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);\n          ignoreInternalFocusChange = false;\n\n          if (!focused) {\n            ignoreInternalFocusChange = true;\n            focusableStartEl.focus({\n              preventScroll: true\n            });\n            ignoreInternalFocusChange = false;\n          }\n        }\n      }\n    }\n\n    function handleStartFocus(e) {\n      if (ignoreInternalFocusChange) return;\n      const mainEl = getMainEl();\n      if (mainEl === null) return;\n\n      if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {\n        // if it comes from inner, focus last\n        resetFocusTo('last');\n      } else {\n        // otherwise focus first\n        resetFocusTo('first');\n      }\n    }\n\n    function handleEndFocus(e) {\n      if (ignoreInternalFocusChange) return;\n\n      if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {\n        // if it comes from first, focus last\n        resetFocusTo('last');\n      } else {\n        // otherwise focus first\n        resetFocusTo('first');\n      }\n    }\n\n    return {\n      focusableStartRef,\n      focusableEndRef,\n      focusableStyle: 'position: absolute; height: 0; width: 0;',\n      handleStartFocus,\n      handleEndFocus\n    };\n  },\n\n  render() {\n    const {\n      default: defaultSlot\n    } = this.$slots;\n    if (defaultSlot === undefined) return null;\n    if (this.disabled) return defaultSlot();\n    const {\n      active,\n      focusableStyle\n    } = this;\n    return h(Fragment, null, [h('div', {\n      'aria-hidden': 'true',\n      tabindex: active ? '0' : '-1',\n      ref: 'focusableStartRef',\n      style: focusableStyle,\n      onFocus: this.handleStartFocus\n    }), defaultSlot(), h('div', {\n      'aria-hidden': 'true',\n      style: focusableStyle,\n      ref: 'focusableEndRef',\n      tabindex: active ? '0' : '-1',\n      onFocus: this.handleEndFocus\n    })]);\n  }\n\n});","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/vueuc/es/focus-trap/src/index.js"],"names":["h","defineComponent","ref","Fragment","onMounted","onBeforeUnmount","watch","createId","on","off","focusFirstDescendant","focusLastDescendant","resolveTo","stack","FocusTrap","name","props","disabled","Boolean","active","autoFocus","type","default","onEsc","Function","initialFocusTo","String","finalFocusTo","returnFocusOnDeactivated","setup","id","focusableStartRef","focusableEndRef","activated","ignoreInternalFocusChange","lastFocusedElement","document","activeElement","isCurrentActive","currentActiveId","length","handleDocumentKeydown","e","_a","code","call","value","activate","deactivate","immediate","handleDocumentFocus","mainEl","getMainEl","contains","target","resetFocusTo","focusableStartEl","nextSibling","Element","tagName","push","undefined","focus","preventScroll","addEventListener","removeEventListener","filter","idInStack","HTMLElement","focusableEndEl","focused","handleStartFocus","relatedTarget","handleEndFocus","focusableStyle","render","defaultSlot","$slots","tabindex","style","onFocus"],"mappings":"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","sourcesContent":["import { h, defineComponent, ref, Fragment, onMounted, onBeforeUnmount, watch } from 'vue';\nimport { createId } from 'seemly';\nimport { on, off } from 'evtd';\nimport { focusFirstDescendant, focusLastDescendant } from './utils';\nimport { resolveTo } from '../../shared';\nlet stack = [];\nexport const FocusTrap = defineComponent({\n    name: 'FocusTrap',\n    props: {\n        disabled: Boolean,\n        active: Boolean,\n        autoFocus: {\n            type: Boolean,\n            default: true\n        },\n        onEsc: Function,\n        initialFocusTo: String,\n        finalFocusTo: String,\n        returnFocusOnDeactivated: {\n            type: Boolean,\n            default: true\n        }\n    },\n    setup(props) {\n        const id = createId();\n        const focusableStartRef = ref(null);\n        const focusableEndRef = ref(null);\n        let activated = false;\n        let ignoreInternalFocusChange = false;\n        const lastFocusedElement = document.activeElement;\n        function isCurrentActive() {\n            const currentActiveId = stack[stack.length - 1];\n            return currentActiveId === id;\n        }\n        function handleDocumentKeydown(e) {\n            var _a;\n            if (e.code === 'Escape') {\n                if (isCurrentActive()) {\n                    (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);\n                }\n            }\n        }\n        onMounted(() => {\n            watch(() => props.active, (value) => {\n                if (value) {\n                    activate();\n                    on('keydown', document, handleDocumentKeydown);\n                }\n                else {\n                    off('keydown', document, handleDocumentKeydown);\n                    if (activated) {\n                        deactivate();\n                    }\n                }\n            }, {\n                immediate: true\n            });\n        });\n        onBeforeUnmount(() => {\n            off('keydown', document, handleDocumentKeydown);\n            if (activated)\n                deactivate();\n        });\n        function handleDocumentFocus(e) {\n            if (ignoreInternalFocusChange)\n                return;\n            if (isCurrentActive()) {\n                const mainEl = getMainEl();\n                if (mainEl === null)\n                    return;\n                if (mainEl.contains(e.target))\n                    return;\n                // I don't handle shift + tab status since it's too tricky to handle\n                // Not impossible but I need to sleep\n                resetFocusTo('first');\n            }\n        }\n        function getMainEl() {\n            const focusableStartEl = focusableStartRef.value;\n            if (focusableStartEl === null)\n                return null;\n            let mainEl = focusableStartEl;\n            while (true) {\n                mainEl = mainEl.nextSibling;\n                if (mainEl === null)\n                    break;\n                if (mainEl instanceof Element && mainEl.tagName === 'DIV') {\n                    break;\n                }\n            }\n            return mainEl;\n        }\n        function activate() {\n            var _a;\n            if (props.disabled)\n                return;\n            stack.push(id);\n            if (props.autoFocus) {\n                const { initialFocusTo } = props;\n                if (initialFocusTo === undefined) {\n                    resetFocusTo('first');\n                }\n                else {\n                    (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });\n                }\n            }\n            activated = true;\n            document.addEventListener('focus', handleDocumentFocus, true);\n        }\n        function deactivate() {\n            var _a;\n            if (props.disabled)\n                return;\n            document.removeEventListener('focus', handleDocumentFocus, true);\n            stack = stack.filter((idInStack) => idInStack !== id);\n            if (isCurrentActive())\n                return;\n            const { finalFocusTo } = props;\n            if (finalFocusTo !== undefined) {\n                (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });\n            }\n            else if (props.returnFocusOnDeactivated) {\n                if (lastFocusedElement instanceof HTMLElement) {\n                    ignoreInternalFocusChange = true;\n                    lastFocusedElement.focus({ preventScroll: true });\n                    ignoreInternalFocusChange = false;\n                }\n            }\n        }\n        function resetFocusTo(target) {\n            if (!isCurrentActive())\n                return;\n            if (props.active) {\n                const focusableStartEl = focusableStartRef.value;\n                const focusableEndEl = focusableEndRef.value;\n                if (focusableStartEl !== null && focusableEndEl !== null) {\n                    const mainEl = getMainEl();\n                    if (mainEl == null || mainEl === focusableEndEl) {\n                        ignoreInternalFocusChange = true;\n                        focusableStartEl.focus({ preventScroll: true });\n                        ignoreInternalFocusChange = false;\n                        return;\n                    }\n                    ignoreInternalFocusChange = true;\n                    const focused = target === 'first'\n                        ? focusFirstDescendant(mainEl)\n                        : focusLastDescendant(mainEl);\n                    ignoreInternalFocusChange = false;\n                    if (!focused) {\n                        ignoreInternalFocusChange = true;\n                        focusableStartEl.focus({ preventScroll: true });\n                        ignoreInternalFocusChange = false;\n                    }\n                }\n            }\n        }\n        function handleStartFocus(e) {\n            if (ignoreInternalFocusChange)\n                return;\n            const mainEl = getMainEl();\n            if (mainEl === null)\n                return;\n            if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {\n                // if it comes from inner, focus last\n                resetFocusTo('last');\n            }\n            else {\n                // otherwise focus first\n                resetFocusTo('first');\n            }\n        }\n        function handleEndFocus(e) {\n            if (ignoreInternalFocusChange)\n                return;\n            if (e.relatedTarget !== null &&\n                e.relatedTarget === focusableStartRef.value) {\n                // if it comes from first, focus last\n                resetFocusTo('last');\n            }\n            else {\n                // otherwise focus first\n                resetFocusTo('first');\n            }\n        }\n        return {\n            focusableStartRef,\n            focusableEndRef,\n            focusableStyle: 'position: absolute; height: 0; width: 0;',\n            handleStartFocus,\n            handleEndFocus\n        };\n    },\n    render() {\n        const { default: defaultSlot } = this.$slots;\n        if (defaultSlot === undefined)\n            return null;\n        if (this.disabled)\n            return defaultSlot();\n        const { active, focusableStyle } = this;\n        return h(Fragment, null, [\n            h('div', {\n                'aria-hidden': 'true',\n                tabindex: active ? '0' : '-1',\n                ref: 'focusableStartRef',\n                style: focusableStyle,\n                onFocus: this.handleStartFocus\n            }),\n            defaultSlot(),\n            h('div', {\n                'aria-hidden': 'true',\n                style: focusableStyle,\n                ref: 'focusableEndRef',\n                tabindex: active ? '0' : '-1',\n                onFocus: this.handleEndFocus\n            })\n        ]);\n    }\n});\n"]},"metadata":{},"sourceType":"module"}