{"ast":null,"code":"import { Histogram } from \"./histogram\";\nimport { insertIntoSortedList, PixelBox } from \"./pixel-box\";\n\nfunction countValidBoxes(queue, isBoxValid) {\n  if (isBoxValid === null) {\n    return queue.length;\n  }\n\n  let retVal = 0;\n\n  for (let i = 0; i < queue.length; i++) {\n    if (isBoxValid(queue[i])) {\n      retVal++;\n    }\n  }\n\n  return retVal;\n}\n/**\n * The default quantize configuration.\n * @public\n */\n\n\nexport const defaultQuantizeConfig = {\n  significantBits: 5,\n  pixelSkipping: 5,\n  targetPaletteSize: 64,\n  fractionByPopulation: 0.85,\n  isBoxValid: box => {\n    if (box.pixelCount < 5) {\n      // Screen out outlier results that aren't present in the original image\n      return false;\n    }\n\n    return true;\n  },\n  isHistogramPixelValid: pixel => {\n    if (pixel[3] < 128) {\n      // Ignore pixels that are too transparent\n      return false;\n    }\n\n    return true;\n  },\n  maxIterations: 1000\n};\n/**\n * The data in the color histogram is reduced down to a small set of colors.\n * It can be useful to create the Histogram manually in cases where one wants to remove or alter the colors in it\n * or to re-use it in order to quantize multiple times with different config settings.\n * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n *\n * @public\n */\n\nexport function quantizeHistogram(histogram, config = defaultQuantizeConfig) {\n  const initialBox = new PixelBox(histogram, histogram.minRed, histogram.maxRed, histogram.minGreen, histogram.maxGreen, histogram.minBlue, histogram.maxBlue);\n  const queue = [initialBox];\n  let count = countValidBoxes(queue, config.isBoxValid); // For a final palette of size targetPaletteSize, we determine the first fractionByPopulation*targetPaletteSize\n  // using population as the only factor when determening sort order. For the rest of the colors the\n  // sort order is population * colorVolume. This helps highly contrasting colors in a small area to show\n  // up in some of the final output.\n\n  const colorsByPopulation = Math.floor(config.targetPaletteSize * config.fractionByPopulation);\n\n  const popSort = box => {\n    return box.pixelCount;\n  };\n\n  let iterationCount = 0;\n\n  while (iterationCount <= config.maxIterations) {\n    if (queue.length > 0) {\n      const currentBox = queue.shift();\n      const cutBoxes = currentBox.modifiedMedianCut();\n\n      if (cutBoxes[0] !== null) {\n        insertIntoSortedList(queue, cutBoxes[0], popSort);\n      }\n\n      if (cutBoxes[1] !== null) {\n        insertIntoSortedList(queue, cutBoxes[1], popSort);\n      }\n    }\n\n    count = countValidBoxes(queue, config.isBoxValid);\n\n    if (count >= colorsByPopulation || queue.length <= 1) {\n      break;\n    }\n\n    iterationCount++;\n  }\n\n  if (count < config.targetPaletteSize) {\n    const popAndVolumeSort = box => {\n      return box.pixelCount * box.colorVolume;\n    };\n\n    queue.sort((a, b) => {\n      const aSort = popAndVolumeSort(a);\n      const bSort = popAndVolumeSort(b);\n\n      if (aSort === bSort) {\n        return 0;\n      } else if (aSort > bSort) {\n        return -1;\n      }\n\n      return 1;\n    });\n    iterationCount = 0;\n\n    while (iterationCount <= config.maxIterations) {\n      if (queue.length > 0) {\n        const currentBox = queue.shift();\n        const cutBoxes = currentBox.modifiedMedianCut();\n\n        if (cutBoxes[0] !== null) {\n          insertIntoSortedList(queue, cutBoxes[0], popAndVolumeSort);\n        }\n\n        if (cutBoxes[1] !== null) {\n          insertIntoSortedList(queue, cutBoxes[1], popAndVolumeSort);\n        }\n      }\n\n      count = countValidBoxes(queue, config.isBoxValid);\n\n      if (count >= config.targetPaletteSize || queue.length <= 1) {\n        break;\n      }\n\n      iterationCount++;\n    }\n  }\n\n  const retVal = new Array(count);\n  let index = 0;\n\n  for (let i = 0; i < queue.length; i++) {\n    if (!config.isBoxValid || config.isBoxValid(queue[i])) {\n      retVal[index] = {\n        color: queue[i].averageColor,\n        pixelCount: queue[i].pixelCount,\n        colorVolume: queue[i].colorVolume\n      };\n      index++;\n    }\n  }\n\n  return retVal;\n}\n/**\n * The image stored in the source PixelBlob is reduced down to a small set of colors.\n * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n *\n * @public\n */\n\nexport function quantize(source, config = defaultQuantizeConfig) {\n  const histogram = new Histogram(source, config.significantBits, config.pixelSkipping, config.isHistogramPixelValid);\n  return quantizeHistogram(histogram, config);\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-colors/dist/color-quantization.js"],"names":["Histogram","insertIntoSortedList","PixelBox","countValidBoxes","queue","isBoxValid","length","retVal","i","defaultQuantizeConfig","significantBits","pixelSkipping","targetPaletteSize","fractionByPopulation","box","pixelCount","isHistogramPixelValid","pixel","maxIterations","quantizeHistogram","histogram","config","initialBox","minRed","maxRed","minGreen","maxGreen","minBlue","maxBlue","count","colorsByPopulation","Math","floor","popSort","iterationCount","currentBox","shift","cutBoxes","modifiedMedianCut","popAndVolumeSort","colorVolume","sort","a","b","aSort","bSort","Array","index","color","averageColor","quantize","source"],"mappings":"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","sourcesContent":["import { Histogram } from \"./histogram\";\nimport { insertIntoSortedList, PixelBox } from \"./pixel-box\";\nfunction countValidBoxes(queue, isBoxValid) {\n    if (isBoxValid === null) {\n        return queue.length;\n    }\n    let retVal = 0;\n    for (let i = 0; i < queue.length; i++) {\n        if (isBoxValid(queue[i])) {\n            retVal++;\n        }\n    }\n    return retVal;\n}\n/**\n * The default quantize configuration.\n * @public\n */\nexport const defaultQuantizeConfig = {\n    significantBits: 5,\n    pixelSkipping: 5,\n    targetPaletteSize: 64,\n    fractionByPopulation: 0.85,\n    isBoxValid: (box) => {\n        if (box.pixelCount < 5) {\n            // Screen out outlier results that aren't present in the original image\n            return false;\n        }\n        return true;\n    },\n    isHistogramPixelValid: (pixel) => {\n        if (pixel[3] < 128) {\n            // Ignore pixels that are too transparent\n            return false;\n        }\n        return true;\n    },\n    maxIterations: 1000,\n};\n/**\n * The data in the color histogram is reduced down to a small set of colors.\n * It can be useful to create the Histogram manually in cases where one wants to remove or alter the colors in it\n * or to re-use it in order to quantize multiple times with different config settings.\n * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n *\n * @public\n */\nexport function quantizeHistogram(histogram, config = defaultQuantizeConfig) {\n    const initialBox = new PixelBox(histogram, histogram.minRed, histogram.maxRed, histogram.minGreen, histogram.maxGreen, histogram.minBlue, histogram.maxBlue);\n    const queue = [initialBox];\n    let count = countValidBoxes(queue, config.isBoxValid);\n    // For a final palette of size targetPaletteSize, we determine the first fractionByPopulation*targetPaletteSize\n    // using population as the only factor when determening sort order. For the rest of the colors the\n    // sort order is population * colorVolume. This helps highly contrasting colors in a small area to show\n    // up in some of the final output.\n    const colorsByPopulation = Math.floor(config.targetPaletteSize * config.fractionByPopulation);\n    const popSort = (box) => {\n        return box.pixelCount;\n    };\n    let iterationCount = 0;\n    while (iterationCount <= config.maxIterations) {\n        if (queue.length > 0) {\n            const currentBox = queue.shift();\n            const cutBoxes = currentBox.modifiedMedianCut();\n            if (cutBoxes[0] !== null) {\n                insertIntoSortedList(queue, cutBoxes[0], popSort);\n            }\n            if (cutBoxes[1] !== null) {\n                insertIntoSortedList(queue, cutBoxes[1], popSort);\n            }\n        }\n        count = countValidBoxes(queue, config.isBoxValid);\n        if (count >= colorsByPopulation || queue.length <= 1) {\n            break;\n        }\n        iterationCount++;\n    }\n    if (count < config.targetPaletteSize) {\n        const popAndVolumeSort = (box) => {\n            return box.pixelCount * box.colorVolume;\n        };\n        queue.sort((a, b) => {\n            const aSort = popAndVolumeSort(a);\n            const bSort = popAndVolumeSort(b);\n            if (aSort === bSort) {\n                return 0;\n            }\n            else if (aSort > bSort) {\n                return -1;\n            }\n            return 1;\n        });\n        iterationCount = 0;\n        while (iterationCount <= config.maxIterations) {\n            if (queue.length > 0) {\n                const currentBox = queue.shift();\n                const cutBoxes = currentBox.modifiedMedianCut();\n                if (cutBoxes[0] !== null) {\n                    insertIntoSortedList(queue, cutBoxes[0], popAndVolumeSort);\n                }\n                if (cutBoxes[1] !== null) {\n                    insertIntoSortedList(queue, cutBoxes[1], popAndVolumeSort);\n                }\n            }\n            count = countValidBoxes(queue, config.isBoxValid);\n            if (count >= config.targetPaletteSize || queue.length <= 1) {\n                break;\n            }\n            iterationCount++;\n        }\n    }\n    const retVal = new Array(count);\n    let index = 0;\n    for (let i = 0; i < queue.length; i++) {\n        if (!config.isBoxValid || config.isBoxValid(queue[i])) {\n            retVal[index] = {\n                color: queue[i].averageColor,\n                pixelCount: queue[i].pixelCount,\n                colorVolume: queue[i].colorVolume,\n            };\n            index++;\n        }\n    }\n    return retVal;\n}\n/**\n * The image stored in the source PixelBlob is reduced down to a small set of colors.\n * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n *\n * @public\n */\nexport function quantize(source, config = defaultQuantizeConfig) {\n    const histogram = new Histogram(source, config.significantBits, config.pixelSkipping, config.isHistogramPixelValid);\n    return quantizeHistogram(histogram, config);\n}\n"]},"metadata":{},"sourceType":"module"}