{"ast":null,"code":"import { h, Transition, ref, inject, toRef, defineComponent, computed, watch, nextTick, withDirectives } from 'vue';\nimport { clickoutside } from 'vdirs';\nimport { createTreeMate } from 'treemate';\nimport { NInternalSelectMenu } from '../../_internal';\nimport { createSelectOptions } from './utils';\nimport { cascaderInjectionKey } from './interface';\nimport { tmOptions } from '../../select/src/utils';\nexport default defineComponent({\n  name: 'NCascaderSelectMenu',\n  props: {\n    value: {\n      type: [String, Number, Array],\n      default: null\n    },\n    show: Boolean,\n    pattern: {\n      type: String,\n      default: ''\n    },\n    multiple: Boolean,\n    tmNodes: {\n      type: Array,\n      default: () => []\n    },\n    filter: Function,\n    labelField: {\n      type: String,\n      required: true\n    },\n    separator: {\n      type: String,\n      required: true\n    }\n  },\n\n  setup(props) {\n    const {\n      isMountedRef,\n      mergedValueRef,\n      mergedClsPrefixRef,\n      mergedThemeRef,\n      mergedCheckStrategyRef,\n      syncSelectMenuPosition,\n      closeMenu,\n      handleSelectMenuClickOutside,\n      doUncheck: cascaderDoUncheck,\n      doCheck: cascaderDoCheck,\n      clearPattern // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    } = inject(cascaderInjectionKey);\n    const menuInstRef = ref(null);\n    const selectOptionsRef = computed(() => {\n      return createSelectOptions(props.tmNodes, mergedCheckStrategyRef.value === 'child', props.labelField, props.separator);\n    });\n    const mergedFilterRef = computed(() => {\n      const {\n        filter\n      } = props;\n      if (filter) return filter;\n      const {\n        labelField\n      } = props;\n      return (pattern, _, path) => path.some(option => option[labelField] && ~option[labelField].indexOf(pattern));\n    });\n    const filteredSelectOptionsRef = computed(() => {\n      const {\n        pattern\n      } = props;\n      const {\n        value: mergedFilter\n      } = mergedFilterRef;\n      return (pattern ? selectOptionsRef.value.filter(option => {\n        return mergedFilter(pattern, option.rawNode, option.path);\n      }) : selectOptionsRef.value).map(option => ({\n        value: option.value,\n        label: option.label\n      }));\n    });\n    const selectTreeMateRef = computed(() => {\n      return createTreeMate(filteredSelectOptionsRef.value, tmOptions);\n    });\n    watch(toRef(props, 'value'), () => {\n      void nextTick(() => {\n        syncSelectMenuPosition();\n      });\n    });\n    watch(filteredSelectOptionsRef, () => {\n      void nextTick(() => {\n        syncSelectMenuPosition();\n      });\n    });\n\n    function handleToggle(tmNode) {\n      doCheck(tmNode);\n    } // We don't care what type the tmNode is, we only care about its key\n\n\n    function doCheck(tmNode) {\n      if (props.multiple) {\n        const {\n          value: mergedValue\n        } = mergedValueRef;\n\n        if (Array.isArray(mergedValue)) {\n          if (!mergedValue.includes(tmNode.key)) {\n            cascaderDoCheck(tmNode.key);\n          } else {\n            cascaderDoUncheck(tmNode.key);\n          }\n        } else if (mergedValue === null) {\n          cascaderDoCheck(tmNode.key);\n        }\n\n        clearPattern();\n      } else {\n        cascaderDoCheck(tmNode.key); // currently the select menu is set to focusable\n        // however just leave it here\n\n        closeMenu(true);\n      }\n    }\n\n    function prev() {\n      var _a;\n\n      (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();\n    }\n\n    function next() {\n      var _a;\n\n      (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.next();\n    }\n\n    function enter() {\n      var _a;\n\n      if (menuInstRef) {\n        const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();\n\n        if (pendingOptionTmNode) {\n          doCheck(pendingOptionTmNode);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    function handleClickOutside(e) {\n      handleSelectMenuClickOutside(e);\n    }\n\n    const exposedRef = {\n      prev,\n      next,\n      enter\n    };\n    return Object.assign({\n      isMounted: isMountedRef,\n      mergedTheme: mergedThemeRef,\n      mergedClsPrefix: mergedClsPrefixRef,\n      menuInstRef,\n      selectTreeMate: selectTreeMateRef,\n      handleToggle,\n      handleClickOutside\n    }, exposedRef);\n  },\n\n  render() {\n    const {\n      mergedClsPrefix,\n      isMounted,\n      mergedTheme\n    } = this;\n    return h(Transition, {\n      name: \"fade-in-scale-up-transition\",\n      appear: isMounted\n    }, {\n      default: () => this.show ? withDirectives(h(NInternalSelectMenu, {\n        ref: \"menuInstRef\",\n        clsPrefix: mergedClsPrefix,\n        class: `${mergedClsPrefix}-cascader-menu`,\n        autoPending: true,\n        themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu,\n        theme: mergedTheme.peers.InternalSelectMenu,\n        treeMate: this.selectTreeMate,\n        multiple: this.multiple,\n        value: this.value,\n        onToggle: this.handleToggle\n      }), [[clickoutside, this.handleClickOutside, undefined, {\n        capture: true\n      }]]) : null\n    });\n  }\n\n});","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/cascader/src/CascaderSelectMenu.js"],"names":["h","Transition","ref","inject","toRef","defineComponent","computed","watch","nextTick","withDirectives","clickoutside","createTreeMate","NInternalSelectMenu","createSelectOptions","cascaderInjectionKey","tmOptions","name","props","value","type","String","Number","Array","default","show","Boolean","pattern","multiple","tmNodes","filter","Function","labelField","required","separator","setup","isMountedRef","mergedValueRef","mergedClsPrefixRef","mergedThemeRef","mergedCheckStrategyRef","syncSelectMenuPosition","closeMenu","handleSelectMenuClickOutside","doUncheck","cascaderDoUncheck","doCheck","cascaderDoCheck","clearPattern","menuInstRef","selectOptionsRef","mergedFilterRef","_","path","some","option","indexOf","filteredSelectOptionsRef","mergedFilter","rawNode","map","label","selectTreeMateRef","handleToggle","tmNode","mergedValue","isArray","includes","key","prev","_a","next","enter","pendingOptionTmNode","getPendingTmNode","handleClickOutside","e","exposedRef","Object","assign","isMounted","mergedTheme","mergedClsPrefix","selectTreeMate","render","appear","clsPrefix","class","autoPending","themeOverrides","peerOverrides","InternalSelectMenu","theme","peers","treeMate","onToggle","undefined","capture"],"mappings":"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","sourcesContent":["import { h, Transition, ref, inject, toRef, defineComponent, computed, watch, nextTick, withDirectives } from 'vue';\nimport { clickoutside } from 'vdirs';\nimport { createTreeMate } from 'treemate';\nimport { NInternalSelectMenu } from '../../_internal';\nimport { createSelectOptions } from './utils';\nimport { cascaderInjectionKey } from './interface';\nimport { tmOptions } from '../../select/src/utils';\nexport default defineComponent({\n    name: 'NCascaderSelectMenu',\n    props: {\n        value: {\n            type: [String, Number, Array],\n            default: null\n        },\n        show: Boolean,\n        pattern: {\n            type: String,\n            default: ''\n        },\n        multiple: Boolean,\n        tmNodes: {\n            type: Array,\n            default: () => []\n        },\n        filter: Function,\n        labelField: {\n            type: String,\n            required: true\n        },\n        separator: {\n            type: String,\n            required: true\n        }\n    },\n    setup(props) {\n        const { isMountedRef, mergedValueRef, mergedClsPrefixRef, mergedThemeRef, mergedCheckStrategyRef, syncSelectMenuPosition, closeMenu, handleSelectMenuClickOutside, doUncheck: cascaderDoUncheck, doCheck: cascaderDoCheck, clearPattern\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n         } = inject(cascaderInjectionKey);\n        const menuInstRef = ref(null);\n        const selectOptionsRef = computed(() => {\n            return createSelectOptions(props.tmNodes, mergedCheckStrategyRef.value === 'child', props.labelField, props.separator);\n        });\n        const mergedFilterRef = computed(() => {\n            const { filter } = props;\n            if (filter)\n                return filter;\n            const { labelField } = props;\n            return (pattern, _, path) => path.some((option) => option[labelField] && ~option[labelField].indexOf(pattern));\n        });\n        const filteredSelectOptionsRef = computed(() => {\n            const { pattern } = props;\n            const { value: mergedFilter } = mergedFilterRef;\n            return (pattern\n                ? selectOptionsRef.value.filter((option) => {\n                    return mergedFilter(pattern, option.rawNode, option.path);\n                })\n                : selectOptionsRef.value).map((option) => ({\n                value: option.value,\n                label: option.label\n            }));\n        });\n        const selectTreeMateRef = computed(() => {\n            return createTreeMate(filteredSelectOptionsRef.value, tmOptions);\n        });\n        watch(toRef(props, 'value'), () => {\n            void nextTick(() => {\n                syncSelectMenuPosition();\n            });\n        });\n        watch(filteredSelectOptionsRef, () => {\n            void nextTick(() => {\n                syncSelectMenuPosition();\n            });\n        });\n        function handleToggle(tmNode) {\n            doCheck(tmNode);\n        }\n        // We don't care what type the tmNode is, we only care about its key\n        function doCheck(tmNode) {\n            if (props.multiple) {\n                const { value: mergedValue } = mergedValueRef;\n                if (Array.isArray(mergedValue)) {\n                    if (!mergedValue.includes(tmNode.key)) {\n                        cascaderDoCheck(tmNode.key);\n                    }\n                    else {\n                        cascaderDoUncheck(tmNode.key);\n                    }\n                }\n                else if (mergedValue === null) {\n                    cascaderDoCheck(tmNode.key);\n                }\n                clearPattern();\n            }\n            else {\n                cascaderDoCheck(tmNode.key);\n                // currently the select menu is set to focusable\n                // however just leave it here\n                closeMenu(true);\n            }\n        }\n        function prev() {\n            var _a;\n            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();\n        }\n        function next() {\n            var _a;\n            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.next();\n        }\n        function enter() {\n            var _a;\n            if (menuInstRef) {\n                const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();\n                if (pendingOptionTmNode) {\n                    doCheck(pendingOptionTmNode);\n                }\n                return true;\n            }\n            return false;\n        }\n        function handleClickOutside(e) {\n            handleSelectMenuClickOutside(e);\n        }\n        const exposedRef = {\n            prev,\n            next,\n            enter\n        };\n        return Object.assign({ isMounted: isMountedRef, mergedTheme: mergedThemeRef, mergedClsPrefix: mergedClsPrefixRef, menuInstRef, selectTreeMate: selectTreeMateRef, handleToggle,\n            handleClickOutside }, exposedRef);\n    },\n    render() {\n        const { mergedClsPrefix, isMounted, mergedTheme } = this;\n        return (h(Transition, { name: \"fade-in-scale-up-transition\", appear: isMounted }, {\n            default: () => this.show\n                ? withDirectives(h(NInternalSelectMenu, { ref: \"menuInstRef\", clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-cascader-menu`, autoPending: true, themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu, theme: mergedTheme.peers.InternalSelectMenu, treeMate: this.selectTreeMate, multiple: this.multiple, value: this.value, onToggle: this.handleToggle }), [\n                    [\n                        clickoutside,\n                        this.handleClickOutside,\n                        undefined,\n                        { capture: true }\n                    ]\n                ])\n                : null\n        }));\n    }\n});\n"]},"metadata":{},"sourceType":"module"}