{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { getDisplayedNodes, isHTMLElement, keyArrowDown, keyArrowLeft, keyArrowRight, keyArrowUp, keyEnd, keyEnter, keyHome } from \"@microsoft/fast-web-utilities\";\nimport { isTreeItemElement, TreeItem } from \"../tree-item\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A Tree view Custom HTML Element.\n * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.\n *\n * @public\n */\n\nexport class TreeView extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * The tree item that is designated to be in the tab queue.\n     *\n     * @internal\n     */\n\n    this.currentFocused = null;\n    /**\n     * Handle focus events\n     *\n     * @internal\n     */\n\n    this.handleFocus = e => {\n      if (this.slottedTreeItems.length < 1) {\n        // no child items, nothing to do\n        return;\n      }\n\n      if (e.target === this) {\n        if (this.currentFocused === null) {\n          this.currentFocused = this.getValidFocusableItem();\n        }\n\n        if (this.currentFocused !== null) {\n          TreeItem.focusItem(this.currentFocused);\n        }\n\n        return;\n      }\n\n      if (this.contains(e.target)) {\n        this.setAttribute(\"tabindex\", \"-1\");\n        this.currentFocused = e.target;\n      }\n    };\n    /**\n     * Handle blur events\n     *\n     * @internal\n     */\n\n\n    this.handleBlur = e => {\n      if (e.target instanceof HTMLElement && (e.relatedTarget === null || !this.contains(e.relatedTarget))) {\n        this.setAttribute(\"tabindex\", \"0\");\n      }\n    };\n    /**\n     * KeyDown handler\n     *\n     *  @internal\n     */\n\n\n    this.handleKeyDown = e => {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      if (this.slottedTreeItems.length < 1) {\n        return true;\n      }\n\n      const treeItems = this.getVisibleNodes();\n\n      switch (e.key) {\n        case keyHome:\n          if (treeItems.length) {\n            TreeItem.focusItem(treeItems[0]);\n          }\n\n          return;\n\n        case keyEnd:\n          if (treeItems.length) {\n            TreeItem.focusItem(treeItems[treeItems.length - 1]);\n          }\n\n          return;\n\n        case keyArrowLeft:\n          if (e.target && this.isFocusableElement(e.target)) {\n            const item = e.target;\n\n            if (item instanceof TreeItem && item.childItemLength() > 0) {\n              item.expanded = false;\n            }\n          }\n\n          return false;\n\n        case keyArrowRight:\n          if (e.target && this.isFocusableElement(e.target)) {\n            const item = e.target;\n\n            if (item instanceof TreeItem && item.childItemLength() > 0) {\n              item.expanded = true;\n            }\n          }\n\n          return;\n\n        case keyArrowDown:\n          if (e.target && this.isFocusableElement(e.target)) {\n            this.focusNextNode(1, e.target);\n          }\n\n          return;\n\n        case keyArrowUp:\n          if (e.target && this.isFocusableElement(e.target)) {\n            this.focusNextNode(-1, e.target);\n          }\n\n          return;\n\n        case keyEnter:\n          // In single-select trees where selection does not follow focus (see note below),\n          // the default action is typically to select the focused node.\n          this.handleClick(e);\n          return;\n      } // don't prevent default if we took no action\n\n\n      return true;\n    };\n    /**\n     * Handles the selected-changed events bubbling up\n     * from child tree items\n     *\n     *  @internal\n     */\n\n\n    this.handleSelectedChange = e => {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n        return true;\n      }\n\n      const item = e.target;\n\n      if (item.selected) {\n        if (this.currentSelected && this.currentSelected !== item) {\n          this.currentSelected.selected = false;\n        } // new selected item\n\n\n        this.currentSelected = item;\n      } else if (!item.selected && this.currentSelected === item) {\n        // selected item deselected\n        this.currentSelected = null;\n      }\n\n      return;\n    };\n    /**\n     * Updates the tree view when slottedTreeItems changes\n     */\n\n\n    this.setItems = () => {\n      // force single selection\n      // defaults to first one found\n      const selectedItem = this.treeView.querySelector(\"[aria-selected='true']\");\n      this.currentSelected = selectedItem; // invalidate the current focused item if it is no longer valid\n\n      if (this.currentFocused === null || !this.contains(this.currentFocused)) {\n        this.currentFocused = this.getValidFocusableItem();\n      } // toggle properties on child elements\n\n\n      this.nested = this.checkForNestedItems();\n      const treeItems = this.getVisibleNodes();\n      treeItems.forEach(node => {\n        if (isTreeItemElement(node)) {\n          node.nested = this.nested;\n        }\n      });\n    };\n    /**\n     * check if the item is focusable\n     */\n\n\n    this.isFocusableElement = el => {\n      return isTreeItemElement(el);\n    };\n\n    this.isSelectedElement = el => {\n      return el.selected;\n    };\n  }\n\n  slottedTreeItemsChanged() {\n    if (this.$fastController.isConnected) {\n      // update for slotted children change\n      this.setItems();\n    }\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.setAttribute(\"tabindex\", \"0\");\n    DOM.queueUpdate(() => {\n      this.setItems();\n    });\n  }\n  /**\n   * Handles click events bubbling up\n   *\n   *  @internal\n   */\n\n\n  handleClick(e) {\n    if (e.defaultPrevented) {\n      // handled, do nothing\n      return;\n    }\n\n    if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n      // not a tree item, ignore\n      return true;\n    }\n\n    const item = e.target;\n\n    if (!item.disabled) {\n      item.selected = !item.selected;\n    }\n\n    return;\n  }\n  /**\n   * Move focus to a tree item based on its offset from the provided item\n   */\n\n\n  focusNextNode(delta, item) {\n    const visibleNodes = this.getVisibleNodes();\n\n    if (!visibleNodes) {\n      return;\n    }\n\n    const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];\n\n    if (isHTMLElement(focusItem)) {\n      TreeItem.focusItem(focusItem);\n    }\n  }\n  /**\n   * checks if there are any nested tree items\n   */\n\n\n  getValidFocusableItem() {\n    const treeItems = this.getVisibleNodes(); // default to selected element if there is one\n\n    let focusIndex = treeItems.findIndex(this.isSelectedElement);\n\n    if (focusIndex === -1) {\n      // otherwise first focusable tree item\n      focusIndex = treeItems.findIndex(this.isFocusableElement);\n    }\n\n    if (focusIndex !== -1) {\n      return treeItems[focusIndex];\n    }\n\n    return null;\n  }\n  /**\n   * checks if there are any nested tree items\n   */\n\n\n  checkForNestedItems() {\n    return this.slottedTreeItems.some(node => {\n      return isTreeItemElement(node) && node.querySelector(\"[role='treeitem']\");\n    });\n  }\n\n  getVisibleNodes() {\n    return getDisplayedNodes(this, \"[role='treeitem']\") || [];\n  }\n\n}\n\n__decorate([attr({\n  attribute: \"render-collapsed-nodes\"\n})], TreeView.prototype, \"renderCollapsedNodes\", void 0);\n\n__decorate([observable], TreeView.prototype, \"currentSelected\", void 0);\n\n__decorate([observable], TreeView.prototype, \"slottedTreeItems\", void 0);","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/tree-view/tree-view.js"],"names":["__decorate","attr","DOM","observable","getDisplayedNodes","isHTMLElement","keyArrowDown","keyArrowLeft","keyArrowRight","keyArrowUp","keyEnd","keyEnter","keyHome","isTreeItemElement","TreeItem","FoundationElement","TreeView","constructor","arguments","currentFocused","handleFocus","e","slottedTreeItems","length","target","getValidFocusableItem","focusItem","contains","setAttribute","handleBlur","HTMLElement","relatedTarget","handleKeyDown","defaultPrevented","treeItems","getVisibleNodes","key","isFocusableElement","item","childItemLength","expanded","focusNextNode","handleClick","handleSelectedChange","Element","selected","currentSelected","setItems","selectedItem","treeView","querySelector","nested","checkForNestedItems","forEach","node","el","isSelectedElement","slottedTreeItemsChanged","$fastController","isConnected","connectedCallback","queueUpdate","disabled","delta","visibleNodes","indexOf","focusIndex","findIndex","some","attribute","prototype"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,IAAT,EAAeC,GAAf,EAAoBC,UAApB,QAAsC,yBAAtC;AACA,SAASC,iBAAT,EAA4BC,aAA5B,EAA2CC,YAA3C,EAAyDC,YAAzD,EAAuEC,aAAvE,EAAsFC,UAAtF,EAAkGC,MAAlG,EAA0GC,QAA1G,EAAoHC,OAApH,QAAoI,+BAApI;AACA,SAASC,iBAAT,EAA4BC,QAA5B,QAA4C,cAA5C;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,QAAN,SAAuBD,iBAAvB,CAAyC;AAC5CE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGC,SAAT;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,cAAL,GAAsB,IAAtB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,WAAL,GAAoBC,CAAD,IAAO;AACtB,UAAI,KAAKC,gBAAL,CAAsBC,MAAtB,GAA+B,CAAnC,EAAsC;AAClC;AACA;AACH;;AACD,UAAIF,CAAC,CAACG,MAAF,KAAa,IAAjB,EAAuB;AACnB,YAAI,KAAKL,cAAL,KAAwB,IAA5B,EAAkC;AAC9B,eAAKA,cAAL,GAAsB,KAAKM,qBAAL,EAAtB;AACH;;AACD,YAAI,KAAKN,cAAL,KAAwB,IAA5B,EAAkC;AAC9BL,UAAAA,QAAQ,CAACY,SAAT,CAAmB,KAAKP,cAAxB;AACH;;AACD;AACH;;AACD,UAAI,KAAKQ,QAAL,CAAcN,CAAC,CAACG,MAAhB,CAAJ,EAA6B;AACzB,aAAKI,YAAL,CAAkB,UAAlB,EAA8B,IAA9B;AACA,aAAKT,cAAL,GAAsBE,CAAC,CAACG,MAAxB;AACH;AACJ,KAlBD;AAmBA;AACR;AACA;AACA;AACA;;;AACQ,SAAKK,UAAL,GAAmBR,CAAD,IAAO;AACrB,UAAIA,CAAC,CAACG,MAAF,YAAoBM,WAApB,KACCT,CAAC,CAACU,aAAF,KAAoB,IAApB,IAA4B,CAAC,KAAKJ,QAAL,CAAcN,CAAC,CAACU,aAAhB,CAD9B,CAAJ,EACmE;AAC/D,aAAKH,YAAL,CAAkB,UAAlB,EAA8B,GAA9B;AACH;AACJ,KALD;AAMA;AACR;AACA;AACA;AACA;;;AACQ,SAAKI,aAAL,GAAsBX,CAAD,IAAO;AACxB,UAAIA,CAAC,CAACY,gBAAN,EAAwB;AACpB;AACH;;AACD,UAAI,KAAKX,gBAAL,CAAsBC,MAAtB,GAA+B,CAAnC,EAAsC;AAClC,eAAO,IAAP;AACH;;AACD,YAAMW,SAAS,GAAG,KAAKC,eAAL,EAAlB;;AACA,cAAQd,CAAC,CAACe,GAAV;AACI,aAAKxB,OAAL;AACI,cAAIsB,SAAS,CAACX,MAAd,EAAsB;AAClBT,YAAAA,QAAQ,CAACY,SAAT,CAAmBQ,SAAS,CAAC,CAAD,CAA5B;AACH;;AACD;;AACJ,aAAKxB,MAAL;AACI,cAAIwB,SAAS,CAACX,MAAd,EAAsB;AAClBT,YAAAA,QAAQ,CAACY,SAAT,CAAmBQ,SAAS,CAACA,SAAS,CAACX,MAAV,GAAmB,CAApB,CAA5B;AACH;;AACD;;AACJ,aAAKhB,YAAL;AACI,cAAIc,CAAC,CAACG,MAAF,IAAY,KAAKa,kBAAL,CAAwBhB,CAAC,CAACG,MAA1B,CAAhB,EAAmD;AAC/C,kBAAMc,IAAI,GAAGjB,CAAC,CAACG,MAAf;;AACA,gBAAIc,IAAI,YAAYxB,QAAhB,IAA4BwB,IAAI,CAACC,eAAL,KAAyB,CAAzD,EAA4D;AACxDD,cAAAA,IAAI,CAACE,QAAL,GAAgB,KAAhB;AACH;AACJ;;AACD,iBAAO,KAAP;;AACJ,aAAKhC,aAAL;AACI,cAAIa,CAAC,CAACG,MAAF,IAAY,KAAKa,kBAAL,CAAwBhB,CAAC,CAACG,MAA1B,CAAhB,EAAmD;AAC/C,kBAAMc,IAAI,GAAGjB,CAAC,CAACG,MAAf;;AACA,gBAAIc,IAAI,YAAYxB,QAAhB,IAA4BwB,IAAI,CAACC,eAAL,KAAyB,CAAzD,EAA4D;AACxDD,cAAAA,IAAI,CAACE,QAAL,GAAgB,IAAhB;AACH;AACJ;;AACD;;AACJ,aAAKlC,YAAL;AACI,cAAIe,CAAC,CAACG,MAAF,IAAY,KAAKa,kBAAL,CAAwBhB,CAAC,CAACG,MAA1B,CAAhB,EAAmD;AAC/C,iBAAKiB,aAAL,CAAmB,CAAnB,EAAsBpB,CAAC,CAACG,MAAxB;AACH;;AACD;;AACJ,aAAKf,UAAL;AACI,cAAIY,CAAC,CAACG,MAAF,IAAY,KAAKa,kBAAL,CAAwBhB,CAAC,CAACG,MAA1B,CAAhB,EAAmD;AAC/C,iBAAKiB,aAAL,CAAmB,CAAC,CAApB,EAAuBpB,CAAC,CAACG,MAAzB;AACH;;AACD;;AACJ,aAAKb,QAAL;AACI;AACA;AACA,eAAK+B,WAAL,CAAiBrB,CAAjB;AACA;AAzCR,OARwB,CAmDxB;;;AACA,aAAO,IAAP;AACH,KArDD;AAsDA;AACR;AACA;AACA;AACA;AACA;;;AACQ,SAAKsB,oBAAL,GAA6BtB,CAAD,IAAO;AAC/B,UAAIA,CAAC,CAACY,gBAAN,EAAwB;AACpB;AACH;;AACD,UAAI,EAAEZ,CAAC,CAACG,MAAF,YAAoBoB,OAAtB,KAAkC,CAAC/B,iBAAiB,CAACQ,CAAC,CAACG,MAAH,CAAxD,EAAoE;AAChE,eAAO,IAAP;AACH;;AACD,YAAMc,IAAI,GAAGjB,CAAC,CAACG,MAAf;;AACA,UAAIc,IAAI,CAACO,QAAT,EAAmB;AACf,YAAI,KAAKC,eAAL,IAAwB,KAAKA,eAAL,KAAyBR,IAArD,EAA2D;AACvD,eAAKQ,eAAL,CAAqBD,QAArB,GAAgC,KAAhC;AACH,SAHc,CAIf;;;AACA,aAAKC,eAAL,GAAuBR,IAAvB;AACH,OAND,MAOK,IAAI,CAACA,IAAI,CAACO,QAAN,IAAkB,KAAKC,eAAL,KAAyBR,IAA/C,EAAqD;AACtD;AACA,aAAKQ,eAAL,GAAuB,IAAvB;AACH;;AACD;AACH,KApBD;AAqBA;AACR;AACA;;;AACQ,SAAKC,QAAL,GAAgB,MAAM;AAClB;AACA;AACA,YAAMC,YAAY,GAAG,KAAKC,QAAL,CAAcC,aAAd,CAA4B,wBAA5B,CAArB;AACA,WAAKJ,eAAL,GAAuBE,YAAvB,CAJkB,CAKlB;;AACA,UAAI,KAAK7B,cAAL,KAAwB,IAAxB,IAAgC,CAAC,KAAKQ,QAAL,CAAc,KAAKR,cAAnB,CAArC,EAAyE;AACrE,aAAKA,cAAL,GAAsB,KAAKM,qBAAL,EAAtB;AACH,OARiB,CASlB;;;AACA,WAAK0B,MAAL,GAAc,KAAKC,mBAAL,EAAd;AACA,YAAMlB,SAAS,GAAG,KAAKC,eAAL,EAAlB;AACAD,MAAAA,SAAS,CAACmB,OAAV,CAAkBC,IAAI,IAAI;AACtB,YAAIzC,iBAAiB,CAACyC,IAAD,CAArB,EAA6B;AACzBA,UAAAA,IAAI,CAACH,MAAL,GAAc,KAAKA,MAAnB;AACH;AACJ,OAJD;AAKH,KAjBD;AAkBA;AACR;AACA;;;AACQ,SAAKd,kBAAL,GAA2BkB,EAAD,IAAQ;AAC9B,aAAO1C,iBAAiB,CAAC0C,EAAD,CAAxB;AACH,KAFD;;AAGA,SAAKC,iBAAL,GAA0BD,EAAD,IAAQ;AAC7B,aAAOA,EAAE,CAACV,QAAV;AACH,KAFD;AAGH;;AACDY,EAAAA,uBAAuB,GAAG;AACtB,QAAI,KAAKC,eAAL,CAAqBC,WAAzB,EAAsC;AAClC;AACA,WAAKZ,QAAL;AACH;AACJ;;AACDa,EAAAA,iBAAiB,GAAG;AAChB,UAAMA,iBAAN;AACA,SAAKhC,YAAL,CAAkB,UAAlB,EAA8B,GAA9B;AACA1B,IAAAA,GAAG,CAAC2D,WAAJ,CAAgB,MAAM;AAClB,WAAKd,QAAL;AACH,KAFD;AAGH;AACD;AACJ;AACA;AACA;AACA;;;AACIL,EAAAA,WAAW,CAACrB,CAAD,EAAI;AACX,QAAIA,CAAC,CAACY,gBAAN,EAAwB;AACpB;AACA;AACH;;AACD,QAAI,EAAEZ,CAAC,CAACG,MAAF,YAAoBoB,OAAtB,KAAkC,CAAC/B,iBAAiB,CAACQ,CAAC,CAACG,MAAH,CAAxD,EAAoE;AAChE;AACA,aAAO,IAAP;AACH;;AACD,UAAMc,IAAI,GAAGjB,CAAC,CAACG,MAAf;;AACA,QAAI,CAACc,IAAI,CAACwB,QAAV,EAAoB;AAChBxB,MAAAA,IAAI,CAACO,QAAL,GAAgB,CAACP,IAAI,CAACO,QAAtB;AACH;;AACD;AACH;AACD;AACJ;AACA;;;AACIJ,EAAAA,aAAa,CAACsB,KAAD,EAAQzB,IAAR,EAAc;AACvB,UAAM0B,YAAY,GAAG,KAAK7B,eAAL,EAArB;;AACA,QAAI,CAAC6B,YAAL,EAAmB;AACf;AACH;;AACD,UAAMtC,SAAS,GAAGsC,YAAY,CAACA,YAAY,CAACC,OAAb,CAAqB3B,IAArB,IAA6ByB,KAA9B,CAA9B;;AACA,QAAI1D,aAAa,CAACqB,SAAD,CAAjB,EAA8B;AAC1BZ,MAAAA,QAAQ,CAACY,SAAT,CAAmBA,SAAnB;AACH;AACJ;AACD;AACJ;AACA;;;AACID,EAAAA,qBAAqB,GAAG;AACpB,UAAMS,SAAS,GAAG,KAAKC,eAAL,EAAlB,CADoB,CAEpB;;AACA,QAAI+B,UAAU,GAAGhC,SAAS,CAACiC,SAAV,CAAoB,KAAKX,iBAAzB,CAAjB;;AACA,QAAIU,UAAU,KAAK,CAAC,CAApB,EAAuB;AACnB;AACAA,MAAAA,UAAU,GAAGhC,SAAS,CAACiC,SAAV,CAAoB,KAAK9B,kBAAzB,CAAb;AACH;;AACD,QAAI6B,UAAU,KAAK,CAAC,CAApB,EAAuB;AACnB,aAAOhC,SAAS,CAACgC,UAAD,CAAhB;AACH;;AACD,WAAO,IAAP;AACH;AACD;AACJ;AACA;;;AACId,EAAAA,mBAAmB,GAAG;AAClB,WAAO,KAAK9B,gBAAL,CAAsB8C,IAAtB,CAA4Bd,IAAD,IAAU;AACxC,aAAOzC,iBAAiB,CAACyC,IAAD,CAAjB,IAA2BA,IAAI,CAACJ,aAAL,CAAmB,mBAAnB,CAAlC;AACH,KAFM,CAAP;AAGH;;AACDf,EAAAA,eAAe,GAAG;AACd,WAAO/B,iBAAiB,CAAC,IAAD,EAAO,mBAAP,CAAjB,IAAgD,EAAvD;AACH;;AAzO2C;;AA2OhDJ,UAAU,CAAC,CACPC,IAAI,CAAC;AAAEoE,EAAAA,SAAS,EAAE;AAAb,CAAD,CADG,CAAD,EAEPrD,QAAQ,CAACsD,SAFF,EAEa,sBAFb,EAEqC,KAAK,CAF1C,CAAV;;AAGAtE,UAAU,CAAC,CACPG,UADO,CAAD,EAEPa,QAAQ,CAACsD,SAFF,EAEa,iBAFb,EAEgC,KAAK,CAFrC,CAAV;;AAGAtE,UAAU,CAAC,CACPG,UADO,CAAD,EAEPa,QAAQ,CAACsD,SAFF,EAEa,kBAFb,EAEiC,KAAK,CAFtC,CAAV","sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { getDisplayedNodes, isHTMLElement, keyArrowDown, keyArrowLeft, keyArrowRight, keyArrowUp, keyEnd, keyEnter, keyHome, } from \"@microsoft/fast-web-utilities\";\nimport { isTreeItemElement, TreeItem } from \"../tree-item\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A Tree view Custom HTML Element.\n * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.\n *\n * @public\n */\nexport class TreeView extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * The tree item that is designated to be in the tab queue.\n         *\n         * @internal\n         */\n        this.currentFocused = null;\n        /**\n         * Handle focus events\n         *\n         * @internal\n         */\n        this.handleFocus = (e) => {\n            if (this.slottedTreeItems.length < 1) {\n                // no child items, nothing to do\n                return;\n            }\n            if (e.target === this) {\n                if (this.currentFocused === null) {\n                    this.currentFocused = this.getValidFocusableItem();\n                }\n                if (this.currentFocused !== null) {\n                    TreeItem.focusItem(this.currentFocused);\n                }\n                return;\n            }\n            if (this.contains(e.target)) {\n                this.setAttribute(\"tabindex\", \"-1\");\n                this.currentFocused = e.target;\n            }\n        };\n        /**\n         * Handle blur events\n         *\n         * @internal\n         */\n        this.handleBlur = (e) => {\n            if (e.target instanceof HTMLElement &&\n                (e.relatedTarget === null || !this.contains(e.relatedTarget))) {\n                this.setAttribute(\"tabindex\", \"0\");\n            }\n        };\n        /**\n         * KeyDown handler\n         *\n         *  @internal\n         */\n        this.handleKeyDown = (e) => {\n            if (e.defaultPrevented) {\n                return;\n            }\n            if (this.slottedTreeItems.length < 1) {\n                return true;\n            }\n            const treeItems = this.getVisibleNodes();\n            switch (e.key) {\n                case keyHome:\n                    if (treeItems.length) {\n                        TreeItem.focusItem(treeItems[0]);\n                    }\n                    return;\n                case keyEnd:\n                    if (treeItems.length) {\n                        TreeItem.focusItem(treeItems[treeItems.length - 1]);\n                    }\n                    return;\n                case keyArrowLeft:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        const item = e.target;\n                        if (item instanceof TreeItem && item.childItemLength() > 0) {\n                            item.expanded = false;\n                        }\n                    }\n                    return false;\n                case keyArrowRight:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        const item = e.target;\n                        if (item instanceof TreeItem && item.childItemLength() > 0) {\n                            item.expanded = true;\n                        }\n                    }\n                    return;\n                case keyArrowDown:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        this.focusNextNode(1, e.target);\n                    }\n                    return;\n                case keyArrowUp:\n                    if (e.target && this.isFocusableElement(e.target)) {\n                        this.focusNextNode(-1, e.target);\n                    }\n                    return;\n                case keyEnter:\n                    // In single-select trees where selection does not follow focus (see note below),\n                    // the default action is typically to select the focused node.\n                    this.handleClick(e);\n                    return;\n            }\n            // don't prevent default if we took no action\n            return true;\n        };\n        /**\n         * Handles the selected-changed events bubbling up\n         * from child tree items\n         *\n         *  @internal\n         */\n        this.handleSelectedChange = (e) => {\n            if (e.defaultPrevented) {\n                return;\n            }\n            if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n                return true;\n            }\n            const item = e.target;\n            if (item.selected) {\n                if (this.currentSelected && this.currentSelected !== item) {\n                    this.currentSelected.selected = false;\n                }\n                // new selected item\n                this.currentSelected = item;\n            }\n            else if (!item.selected && this.currentSelected === item) {\n                // selected item deselected\n                this.currentSelected = null;\n            }\n            return;\n        };\n        /**\n         * Updates the tree view when slottedTreeItems changes\n         */\n        this.setItems = () => {\n            // force single selection\n            // defaults to first one found\n            const selectedItem = this.treeView.querySelector(\"[aria-selected='true']\");\n            this.currentSelected = selectedItem;\n            // invalidate the current focused item if it is no longer valid\n            if (this.currentFocused === null || !this.contains(this.currentFocused)) {\n                this.currentFocused = this.getValidFocusableItem();\n            }\n            // toggle properties on child elements\n            this.nested = this.checkForNestedItems();\n            const treeItems = this.getVisibleNodes();\n            treeItems.forEach(node => {\n                if (isTreeItemElement(node)) {\n                    node.nested = this.nested;\n                }\n            });\n        };\n        /**\n         * check if the item is focusable\n         */\n        this.isFocusableElement = (el) => {\n            return isTreeItemElement(el);\n        };\n        this.isSelectedElement = (el) => {\n            return el.selected;\n        };\n    }\n    slottedTreeItemsChanged() {\n        if (this.$fastController.isConnected) {\n            // update for slotted children change\n            this.setItems();\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute(\"tabindex\", \"0\");\n        DOM.queueUpdate(() => {\n            this.setItems();\n        });\n    }\n    /**\n     * Handles click events bubbling up\n     *\n     *  @internal\n     */\n    handleClick(e) {\n        if (e.defaultPrevented) {\n            // handled, do nothing\n            return;\n        }\n        if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {\n            // not a tree item, ignore\n            return true;\n        }\n        const item = e.target;\n        if (!item.disabled) {\n            item.selected = !item.selected;\n        }\n        return;\n    }\n    /**\n     * Move focus to a tree item based on its offset from the provided item\n     */\n    focusNextNode(delta, item) {\n        const visibleNodes = this.getVisibleNodes();\n        if (!visibleNodes) {\n            return;\n        }\n        const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];\n        if (isHTMLElement(focusItem)) {\n            TreeItem.focusItem(focusItem);\n        }\n    }\n    /**\n     * checks if there are any nested tree items\n     */\n    getValidFocusableItem() {\n        const treeItems = this.getVisibleNodes();\n        // default to selected element if there is one\n        let focusIndex = treeItems.findIndex(this.isSelectedElement);\n        if (focusIndex === -1) {\n            // otherwise first focusable tree item\n            focusIndex = treeItems.findIndex(this.isFocusableElement);\n        }\n        if (focusIndex !== -1) {\n            return treeItems[focusIndex];\n        }\n        return null;\n    }\n    /**\n     * checks if there are any nested tree items\n     */\n    checkForNestedItems() {\n        return this.slottedTreeItems.some((node) => {\n            return isTreeItemElement(node) && node.querySelector(\"[role='treeitem']\");\n        });\n    }\n    getVisibleNodes() {\n        return getDisplayedNodes(this, \"[role='treeitem']\") || [];\n    }\n}\n__decorate([\n    attr({ attribute: \"render-collapsed-nodes\" })\n], TreeView.prototype, \"renderCollapsedNodes\", void 0);\n__decorate([\n    observable\n], TreeView.prototype, \"currentSelected\", void 0);\n__decorate([\n    observable\n], TreeView.prototype, \"slottedTreeItems\", void 0);\n"]},"metadata":{},"sourceType":"module"}