{"ast":null,"code":"import { calculateOverlayColor, ColorRGBA64, computeAlphaBlend, parseColorHexRGB } from '@microsoft/fast-colors';\nimport { SwatchRGB } from '../swatch';\nimport { directionByIsDark } from '../utilities/direction-by-is-dark';\nimport { GradientSwatchRGB } from './gradient-swatch';\nconst black = new ColorRGBA64(0, 0, 0);\nconst white = new ColorRGBA64(1, 1, 1);\n/**\n * @internal\n */\n\nexport function gradientShadowStroke(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, shadowDelta, direction, shadowPercentage = 10, blendWithReference = false) {\n  const referenceIndex = palette.closestIndexOf(reference);\n\n  if (direction === void 0) {\n    direction = directionByIsDark(reference);\n  }\n\n  function overlayHelper(color) {\n    if (blendWithReference) {\n      const refIndex = palette.closestIndexOf(reference);\n      const refSwatch = palette.get(refIndex);\n      const overlaySolid = color.relativeLuminance < reference.relativeLuminance ? black : white;\n      const overlayColor = calculateOverlayColor(parseColorHexRGB(color.toColorString()), parseColorHexRGB(refSwatch.toColorString()), overlaySolid).roundToPrecision(2);\n      const blend = computeAlphaBlend(parseColorHexRGB(reference.toColorString()), overlayColor);\n      return SwatchRGB.from(blend);\n    } else {\n      return color;\n    }\n  }\n\n  const restIndex = referenceIndex + direction * restDelta;\n  const hoverIndex = restIndex + direction * (hoverDelta - restDelta);\n  const activeIndex = restIndex + direction * (activeDelta - restDelta);\n  const focusIndex = restIndex + direction * (focusDelta - restDelta);\n  const startPosition = direction === -1 ? 0 : 100 - shadowPercentage;\n  const endPosition = direction === -1 ? shadowPercentage : 100;\n\n  function gradientHelper(index, applyShadow) {\n    const color = palette.get(index);\n\n    if (applyShadow) {\n      // Shadow is actually \"highlight\" on top in dark mode.\n      const shadowColor = palette.get(index + direction * shadowDelta);\n      const startColor = direction === -1 ? shadowColor : color;\n      const endColor = direction === -1 ? color : shadowColor;\n      const g = `linear-gradient(${overlayHelper(startColor).toColorString()} ${startPosition}%, ${overlayHelper(endColor).toColorString()} ${endPosition}%)`;\n      return GradientSwatchRGB.fromObject(startColor, g);\n    } else {\n      return overlayHelper(color);\n    }\n  }\n\n  return {\n    rest: gradientHelper(restIndex, true),\n    hover: gradientHelper(hoverIndex, true),\n    active: gradientHelper(activeIndex, false),\n    focus: gradientHelper(focusIndex, true)\n  };\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@fluentui/web-components/dist/esm/color/recipes/gradient-shadow-stroke.js"],"names":["calculateOverlayColor","ColorRGBA64","computeAlphaBlend","parseColorHexRGB","SwatchRGB","directionByIsDark","GradientSwatchRGB","black","white","gradientShadowStroke","palette","reference","restDelta","hoverDelta","activeDelta","focusDelta","shadowDelta","direction","shadowPercentage","blendWithReference","referenceIndex","closestIndexOf","overlayHelper","color","refIndex","refSwatch","get","overlaySolid","relativeLuminance","overlayColor","toColorString","roundToPrecision","blend","from","restIndex","hoverIndex","activeIndex","focusIndex","startPosition","endPosition","gradientHelper","index","applyShadow","shadowColor","startColor","endColor","g","fromObject","rest","hover","active","focus"],"mappings":"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","sourcesContent":["import { calculateOverlayColor, ColorRGBA64, computeAlphaBlend, parseColorHexRGB } from '@microsoft/fast-colors';\nimport { SwatchRGB } from '../swatch';\nimport { directionByIsDark } from '../utilities/direction-by-is-dark';\nimport { GradientSwatchRGB } from './gradient-swatch';\nconst black = new ColorRGBA64(0, 0, 0);\nconst white = new ColorRGBA64(1, 1, 1);\n/**\n * @internal\n */\nexport function gradientShadowStroke(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, shadowDelta, direction, shadowPercentage = 10, blendWithReference = false) {\n    const referenceIndex = palette.closestIndexOf(reference);\n    if (direction === void 0) {\n        direction = directionByIsDark(reference);\n    }\n    function overlayHelper(color) {\n        if (blendWithReference) {\n            const refIndex = palette.closestIndexOf(reference);\n            const refSwatch = palette.get(refIndex);\n            const overlaySolid = color.relativeLuminance < reference.relativeLuminance ? black : white;\n            const overlayColor = calculateOverlayColor(parseColorHexRGB(color.toColorString()), parseColorHexRGB(refSwatch.toColorString()), overlaySolid).roundToPrecision(2);\n            const blend = computeAlphaBlend(parseColorHexRGB(reference.toColorString()), overlayColor);\n            return SwatchRGB.from(blend);\n        }\n        else {\n            return color;\n        }\n    }\n    const restIndex = referenceIndex + direction * restDelta;\n    const hoverIndex = restIndex + direction * (hoverDelta - restDelta);\n    const activeIndex = restIndex + direction * (activeDelta - restDelta);\n    const focusIndex = restIndex + direction * (focusDelta - restDelta);\n    const startPosition = direction === -1 ? 0 : 100 - shadowPercentage;\n    const endPosition = direction === -1 ? shadowPercentage : 100;\n    function gradientHelper(index, applyShadow) {\n        const color = palette.get(index);\n        if (applyShadow) {\n            // Shadow is actually \"highlight\" on top in dark mode.\n            const shadowColor = palette.get(index + direction * shadowDelta);\n            const startColor = direction === -1 ? shadowColor : color;\n            const endColor = direction === -1 ? color : shadowColor;\n            const g = `linear-gradient(${overlayHelper(startColor).toColorString()} ${startPosition}%, ${overlayHelper(endColor).toColorString()} ${endPosition}%)`;\n            return GradientSwatchRGB.fromObject(startColor, g);\n        }\n        else {\n            return overlayHelper(color);\n        }\n    }\n    return {\n        rest: gradientHelper(restIndex, true),\n        hover: gradientHelper(hoverIndex, true),\n        active: gradientHelper(activeIndex, false),\n        focus: gradientHelper(focusIndex, true),\n    };\n}\n"]},"metadata":{},"sourceType":"module"}