{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { getPadding } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { call, createDataKey, warn } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr'; // TODO:\n// During expanding, some node are mis-applied with :active style\n// Async dnd has bug\n\nconst ITEM_SIZE = 30; // 24 + 3 + 3\n\nexport function createTreeMateOptions(keyField, childrenField) {\n  return {\n    getKey(node) {\n      return node[keyField];\n    },\n\n    getChildren(node) {\n      return node[childrenField];\n    },\n\n    getDisabled(node) {\n      return !!(node.disabled || node.checkboxDisabled);\n    }\n\n  };\n}\nexport const treeSharedProps = {\n  filter: Function,\n  defaultExpandAll: Boolean,\n  expandedKeys: Array,\n  keyField: {\n    type: String,\n    default: 'key'\n  },\n  labelField: {\n    type: String,\n    default: 'label'\n  },\n  childrenField: {\n    type: String,\n    default: 'children'\n  },\n  defaultExpandedKeys: {\n    type: Array,\n    default: () => []\n  },\n  indeterminateKeys: Array,\n  onUpdateIndeterminateKeys: [Function, Array],\n  'onUpdate:indeterminateKeys': [Function, Array],\n  onUpdateExpandedKeys: [Function, Array],\n  'onUpdate:expandedKeys': [Function, Array]\n};\nconst treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {\n  data: {\n    type: Array,\n    default: () => []\n  },\n  expandOnDragenter: {\n    type: Boolean,\n    default: true\n  },\n  cancelable: {\n    type: Boolean,\n    default: true\n  },\n  checkable: Boolean,\n  draggable: Boolean,\n  blockNode: Boolean,\n  blockLine: Boolean,\n  disabled: Boolean,\n  checkedKeys: Array,\n  defaultCheckedKeys: {\n    type: Array,\n    default: () => []\n  },\n  selectedKeys: Array,\n  defaultSelectedKeys: {\n    type: Array,\n    default: () => []\n  },\n  leafOnly: Boolean,\n  multiple: Boolean,\n  pattern: {\n    type: String,\n    default: ''\n  },\n  onLoad: Function,\n  cascade: Boolean,\n  selectable: {\n    type: Boolean,\n    default: true\n  },\n  indent: {\n    type: Number,\n    default: 16\n  },\n  allowDrop: {\n    type: Function,\n    default: defaultAllowDrop\n  },\n  animated: {\n    type: Boolean,\n    default: true\n  },\n  virtualScroll: Boolean,\n  watchProps: Array,\n  renderLabel: Function,\n  renderPrefix: Function,\n  renderSuffix: Function,\n  renderSwitcherIcon: Function,\n  nodeProps: Function,\n  onDragenter: [Function, Array],\n  onDragleave: [Function, Array],\n  onDragend: [Function, Array],\n  onDragstart: [Function, Array],\n  onDragover: [Function, Array],\n  onDrop: [Function, Array],\n  onUpdateCheckedKeys: [Function, Array],\n  'onUpdate:checkedKeys': [Function, Array],\n  onUpdateSelectedKeys: [Function, Array],\n  'onUpdate:selectedKeys': [Function, Array]\n}), treeSharedProps), {\n  // internal props for tree-select\n  internalTreeSelect: Boolean,\n  internalScrollable: Boolean,\n  internalScrollablePadding: String,\n  // use it to do check\n  internalDataTreeMate: Object,\n  // use it to display\n  internalDisplayTreeMate: Object,\n  internalHighlightKeySet: Object,\n  internalUnifySelectCheck: Boolean,\n  internalHideFilteredNode: Boolean,\n  internalCheckboxFocusable: {\n    type: Boolean,\n    default: true\n  },\n  internalFocusable: {\n    // Make tree-select take over keyboard operations\n    type: Boolean,\n    default: true\n  },\n  checkStrategy: {\n    type: String,\n    default: 'all'\n  }\n});\nexport default defineComponent({\n  name: 'Tree',\n  props: treeProps,\n\n  setup(props) {\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n    const selfElRef = ref(null);\n    const scrollbarInstRef = ref(null);\n    const virtualListInstRef = ref(null);\n\n    function getScrollContainer() {\n      var _a;\n\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n    }\n\n    function getScrollContent() {\n      var _a;\n\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n    } // We don't expect data source to change so we just determine it once\n\n\n    const displayTreeMateRef = props.internalDisplayTreeMate ? toRef(props, 'internalDisplayTreeMate') : computed(() => createTreeMate(props.data, createTreeMateOptions(props.keyField, props.childrenField)));\n    const dataTreeMateRef = props.internalDataTreeMate ? toRef(props, 'internalDataTreeMate') : displayTreeMateRef;\n    const {\n      watchProps\n    } = props;\n    const uncontrolledCheckedKeysRef = ref([]);\n\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n      watchEffect(() => {\n        uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n      });\n    } else {\n      uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n    }\n\n    const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n    const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n    const checkedStatusRef = computed(() => {\n      const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n        cascade: props.cascade\n      });\n      return value;\n    });\n    const mergedCheckStrategyRef = computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n    const displayedCheckedKeysRef = computed(() => {\n      return checkedStatusRef.value.checkedKeys;\n    });\n    const displayedIndeterminateKeysRef = computed(() => {\n      const {\n        indeterminateKeys\n      } = props;\n      if (indeterminateKeys !== undefined) return indeterminateKeys;\n      return checkedStatusRef.value.indeterminateKeys;\n    });\n    const uncontrolledSelectedKeysRef = ref([]);\n\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n      watchEffect(() => {\n        uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n      });\n    } else {\n      uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n    }\n\n    const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n    const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n    const uncontrolledExpandedKeysRef = ref([]);\n\n    const initUncontrolledExpandedKeys = keys => {\n      uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys === undefined ? props.defaultExpandedKeys : keys;\n    };\n\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n      // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n      watchEffect(() => initUncontrolledExpandedKeys(undefined));\n    } else {\n      // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n      watchEffect(() => initUncontrolledExpandedKeys(props.defaultExpandedKeys));\n    }\n\n    const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n    const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n    const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n    const {\n      pendingNodeKeyRef,\n      handleKeyup,\n      handleKeydown\n    } = useKeyboard({\n      mergedSelectedKeysRef,\n      fNodesRef,\n      mergedExpandedKeysRef,\n      handleSelect,\n      handleSwitcherClick\n    });\n    let expandTimerId = null;\n    let nodeKeyToBeExpanded = null;\n    const uncontrolledHighlightKeySetRef = ref(new Set());\n    const controlledHighlightKeySetRef = toRef(props, 'internalHighlightKeySet');\n    const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n    const loadingKeysRef = ref(new Set());\n    const expandedNonLoadingKeysRef = computed(() => {\n      return mergedExpandedKeysRef.value.filter(key => !loadingKeysRef.value.has(key));\n    });\n    let dragStartX = 0;\n    const draggingNodeRef = ref(null);\n    const droppingNodeRef = ref(null);\n    const droppingMouseNodeRef = ref(null);\n    const droppingPositionRef = ref(null);\n    const droppingOffsetLevelRef = ref(0);\n    const droppingNodeParentRef = computed(() => {\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      if (!droppingNode) return null; // May avoid overlap between line mark of first child & rect mark of parent\n      // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n      //   return null\n      // }\n\n      return droppingNode.parent;\n    });\n    const mergedFilterRef = computed(() => {\n      const {\n        filter\n      } = props;\n      if (filter) return filter;\n      const {\n        labelField\n      } = props;\n      return (pattern, node) => {\n        if (!pattern.length) return true;\n        return node[labelField].toLowerCase().includes(pattern.toLowerCase());\n      };\n    }); // shallow watch data\n\n    watch(toRef(props, 'data'), () => {\n      loadingKeysRef.value.clear();\n      pendingNodeKeyRef.value = null;\n      resetDndState();\n    }, {\n      deep: false\n    });\n    watch(toRef(props, 'pattern'), value => {\n      if (value) {\n        const {\n          expandedKeys: expandedKeysAfterChange,\n          highlightKeySet\n        } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n        uncontrolledHighlightKeySetRef.value = highlightKeySet;\n        doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n      } else {\n        uncontrolledHighlightKeySetRef.value = new Set();\n      }\n    });\n\n    function triggerLoading(node) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          onLoad\n        } = props;\n\n        if (!onLoad) {\n          if (process.env.NODE_ENV !== 'production') {\n            warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n          }\n\n          return yield Promise.resolve();\n        }\n\n        const {\n          value: loadingKeys\n        } = loadingKeysRef;\n        return yield new Promise(resolve => {\n          if (!loadingKeys.has(node.key)) {\n            loadingKeys.add(node.key);\n            onLoad(node.rawNode).then(() => {\n              loadingKeys.delete(node.key);\n              resolve();\n            }).catch(loadError => {\n              console.error(loadError);\n              resetDragExpandState();\n            });\n          }\n        });\n      });\n    }\n\n    watchEffect(() => {\n      var _a;\n\n      const {\n        value: displayTreeMate\n      } = displayTreeMateRef;\n      if (!displayTreeMate) return;\n      const {\n        getNode\n      } = displayTreeMate;\n      (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n        const node = getNode(key);\n\n        if (node && !node.shallowLoaded) {\n          void triggerLoading(node);\n        }\n      });\n    }); // animation in progress\n\n    const aipRef = ref(false); // animation flattened nodes\n\n    const afNodeRef = ref([]); // Note: Since the virtual list depends on min height, if there's a node\n    // whose height starts from 0, the virtual list will have a wrong height\n    // during animation. This will seldom cause wired scrollbar status. It is\n    // fixable and need some changes in vueuc, I've no time so I just leave it\n    // here. Maybe the bug won't be fixed during the life time of the project.\n\n    watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n      if (!props.animated) {\n        void nextTick(syncScrollbar);\n        return;\n      }\n\n      const prevVSet = new Set(prevValue);\n      let addedKey = null;\n      let removedKey = null;\n\n      for (const expandedKey of value) {\n        if (!prevVSet.has(expandedKey)) {\n          if (addedKey !== null) return; // multi expand, not triggered by click\n\n          addedKey = expandedKey;\n        }\n      }\n\n      const currentVSet = new Set(value);\n\n      for (const expandedKey of prevValue) {\n        if (!currentVSet.has(expandedKey)) {\n          if (removedKey !== null) return; // multi collapse, not triggered by click\n\n          removedKey = expandedKey;\n        }\n      }\n\n      if (addedKey !== null && removedKey !== null || addedKey === null && removedKey === null) {\n        // 1. multi action, not triggered by click\n        // 2. no action, don't know what happened\n        return;\n      }\n\n      const {\n        virtualScroll\n      } = props;\n      const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n      const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1;\n\n      if (addedKey !== null) {\n        // play add animation\n        aipRef.value = true;\n        afNodeRef.value = displayTreeMateRef.value.getFlattenedNodes(prevValue);\n        const expandedNodeIndex = afNodeRef.value.findIndex(node => node.key === addedKey);\n\n        if (~expandedNodeIndex) {\n          const expandedChildren = flatten( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          afNodeRef.value[expandedNodeIndex].children, value);\n          afNodeRef.value.splice(expandedNodeIndex + 1, 0, {\n            __motion: true,\n            mode: 'expand',\n            height: virtualScroll ? expandedChildren.length * ITEM_SIZE : undefined,\n            nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren\n          });\n        }\n      }\n\n      if (removedKey !== null) {\n        afNodeRef.value = displayTreeMateRef.value.getFlattenedNodes(value);\n        const collapsedNodeIndex = afNodeRef.value.findIndex(node => node.key === removedKey);\n\n        if (~collapsedNodeIndex) {\n          const collapsedNodeChildren = afNodeRef.value[collapsedNodeIndex].children; // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n          // but maybe children removed\n\n          if (!collapsedNodeChildren) return; // play remove animation\n\n          aipRef.value = true;\n          const collapsedChildren = flatten(collapsedNodeChildren, value);\n          afNodeRef.value.splice(collapsedNodeIndex + 1, 0, {\n            __motion: true,\n            mode: 'collapse',\n            height: virtualScroll ? collapsedChildren.length * ITEM_SIZE : undefined,\n            nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren\n          });\n        }\n      }\n    });\n    const getFIndexRef = computed(() => {\n      return createIndexGetter(fNodesRef.value);\n    });\n    const mergedFNodesRef = computed(() => {\n      if (aipRef.value) return afNodeRef.value;else return fNodesRef.value;\n    });\n\n    function syncScrollbar() {\n      const {\n        value: scrollbarInst\n      } = scrollbarInstRef;\n      if (scrollbarInst) scrollbarInst.sync();\n    }\n\n    function handleAfterEnter() {\n      aipRef.value = false;\n\n      if (props.virtualScroll) {\n        // If virtual scroll, we won't listen to resize during animation, so\n        // resize callback of virtual list won't be called and as a result\n        // scrollbar won't sync. We need to sync scrollbar manually.\n        void nextTick(syncScrollbar);\n      }\n    }\n\n    function getOptionsByKeys(keys) {\n      const {\n        getNode\n      } = dataTreeMateRef.value;\n      return keys.map(key => {\n        var _a;\n\n        return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;\n      });\n    }\n\n    function doUpdateExpandedKeys(value, option) {\n      const {\n        'onUpdate:expandedKeys': _onUpdateExpandedKeys,\n        onUpdateExpandedKeys\n      } = props;\n      uncontrolledExpandedKeysRef.value = value;\n\n      if (_onUpdateExpandedKeys) {\n        call(_onUpdateExpandedKeys, value, option);\n      }\n\n      if (onUpdateExpandedKeys) {\n        call(onUpdateExpandedKeys, value, option);\n      }\n    }\n\n    function doUpdateCheckedKeys(value, option) {\n      const {\n        'onUpdate:checkedKeys': _onUpdateCheckedKeys,\n        onUpdateCheckedKeys\n      } = props;\n      uncontrolledCheckedKeysRef.value = value;\n\n      if (onUpdateCheckedKeys) {\n        call(onUpdateCheckedKeys, value, option);\n      }\n\n      if (_onUpdateCheckedKeys) {\n        call(_onUpdateCheckedKeys, value, option);\n      }\n    }\n\n    function doUpdateIndeterminateKeys(value, option) {\n      const {\n        'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys,\n        onUpdateIndeterminateKeys\n      } = props;\n\n      if (_onUpdateIndeterminateKeys) {\n        call(_onUpdateIndeterminateKeys, value, option);\n      }\n\n      if (onUpdateIndeterminateKeys) {\n        call(onUpdateIndeterminateKeys, value, option);\n      }\n    }\n\n    function doUpdateSelectedKeys(value, option) {\n      const {\n        'onUpdate:selectedKeys': _onUpdateSelectedKeys,\n        onUpdateSelectedKeys\n      } = props;\n      uncontrolledSelectedKeysRef.value = value;\n\n      if (onUpdateSelectedKeys) {\n        call(onUpdateSelectedKeys, value, option);\n      }\n\n      if (_onUpdateSelectedKeys) {\n        call(_onUpdateSelectedKeys, value, option);\n      }\n    } // Drag & Drop\n\n\n    function doDragEnter(info) {\n      const {\n        onDragenter\n      } = props;\n      if (onDragenter) call(onDragenter, info);\n    }\n\n    function doDragLeave(info) {\n      const {\n        onDragleave\n      } = props;\n      if (onDragleave) call(onDragleave, info);\n    }\n\n    function doDragEnd(info) {\n      const {\n        onDragend\n      } = props;\n      if (onDragend) call(onDragend, info);\n    }\n\n    function doDragStart(info) {\n      const {\n        onDragstart\n      } = props;\n      if (onDragstart) call(onDragstart, info);\n    }\n\n    function doDragOver(info) {\n      const {\n        onDragover\n      } = props;\n      if (onDragover) call(onDragover, info);\n    }\n\n    function doDrop(info) {\n      const {\n        onDrop\n      } = props;\n      if (onDrop) call(onDrop, info);\n    }\n\n    function resetDndState() {\n      resetDragState();\n      resetDropState();\n    }\n\n    function resetDragState() {\n      draggingNodeRef.value = null;\n    }\n\n    function resetDropState() {\n      droppingOffsetLevelRef.value = 0;\n      droppingNodeRef.value = null;\n      droppingMouseNodeRef.value = null;\n      droppingPositionRef.value = null;\n      resetDragExpandState();\n    }\n\n    function resetDragExpandState() {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n\n      nodeKeyToBeExpanded = null;\n    }\n\n    function handleCheck(node, checked) {\n      // We don't guard for leaf only since we have done it in view layer\n      if (props.disabled || node.disabled) {\n        return;\n      }\n\n      if (props.internalUnifySelectCheck && !props.multiple) {\n        handleSelect(node);\n        return;\n      }\n\n      const {\n        checkedKeys,\n        indeterminateKeys\n      } = dataTreeMateRef.value[checked ? 'check' : 'uncheck'](node.key, displayedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        checkStrategy: mergedCheckStrategyRef.value\n      });\n      doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys));\n      doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n    }\n\n    function toggleExpand(key) {\n      if (props.disabled) return;\n      const {\n        value: mergedExpandedKeys\n      } = mergedExpandedKeysRef;\n      const index = mergedExpandedKeys.findIndex(expandNodeId => expandNodeId === key);\n\n      if (~index) {\n        const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n        expandedKeysAfterChange.splice(index, 1);\n        doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n      } else {\n        const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n\n        if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n          return;\n        }\n\n        const nextKeys = mergedExpandedKeys.concat(key);\n        doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n      }\n    }\n\n    function handleSwitcherClick(node) {\n      if (props.disabled || aipRef.value) return;\n      toggleExpand(node.key);\n    }\n\n    function handleSelect(node) {\n      if (props.disabled || node.disabled || !props.selectable || props.internalTreeSelect && !props.multiple && mergedCheckStrategyRef.value === 'child' && !node.isLeaf) {\n        return;\n      }\n\n      pendingNodeKeyRef.value = node.key;\n\n      if (props.internalUnifySelectCheck) {\n        const {\n          value: {\n            checkedKeys,\n            indeterminateKeys\n          }\n        } = checkedStatusRef;\n\n        if (props.multiple) {\n          handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));\n        } else {\n          doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]));\n        }\n      }\n\n      if (props.multiple) {\n        const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n        const index = selectedKeys.findIndex(key => key === node.key);\n\n        if (~index) {\n          if (props.cancelable) {\n            selectedKeys.splice(index, 1);\n          }\n        } else if (!~index) {\n          selectedKeys.push(node.key);\n        }\n\n        doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys));\n      } else {\n        const selectedKeys = mergedSelectedKeysRef.value;\n\n        if (selectedKeys.includes(node.key)) {\n          if (props.cancelable) {\n            doUpdateSelectedKeys([], []);\n          }\n        } else {\n          doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]));\n        }\n      }\n    }\n\n    function expandDragEnterNode(node) {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      } // Don't expand leaf node.\n\n\n      if (node.isLeaf) return;\n      nodeKeyToBeExpanded = node.key;\n\n      const expand = () => {\n        if (nodeKeyToBeExpanded !== node.key) return;\n        const {\n          value: droppingMouseNode\n        } = droppingMouseNodeRef;\n\n        if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {\n          const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n          doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n        }\n\n        expandTimerId = null;\n        nodeKeyToBeExpanded = null;\n      };\n\n      if (!node.shallowLoaded) {\n        expandTimerId = window.setTimeout(() => {\n          void triggerLoading(node).then(() => {\n            expand();\n          });\n        }, 1000);\n      } else {\n        expandTimerId = window.setTimeout(() => {\n          expand();\n        }, 1000);\n      }\n    } // Dnd\n\n\n    function handleDragEnter({\n      event,\n      node\n    }) {\n      // node should be a tmNode\n      if (!props.draggable || props.disabled || node.disabled) return;\n      handleDragOver({\n        event,\n        node\n      }, false);\n      doDragEnter({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragLeave({\n      event,\n      node\n    }) {\n      if (!props.draggable || props.disabled || node.disabled) return;\n      doDragLeave({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragLeaveTree(e) {\n      if (e.target !== e.currentTarget) return;\n      resetDropState();\n    } // Dragend is ok, we don't need to add global listener to reset drag status\n\n\n    function handleDragEnd({\n      event,\n      node\n    }) {\n      resetDndState();\n      if (!props.draggable || props.disabled || node.disabled) return;\n      doDragEnd({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragStart({\n      event,\n      node\n    }) {\n      var _a;\n\n      if (!props.draggable || props.disabled || node.disabled) return; // Most of time, the image will block user's view\n\n      emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n      dragStartX = event.clientX;\n      draggingNodeRef.value = node;\n      doDragStart({\n        event,\n        node: node.rawNode\n      });\n    }\n\n    function handleDragOver({\n      event,\n      node\n    }, emit = true) {\n      var _a;\n\n      if (!props.draggable || props.disabled || node.disabled) return;\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      if (!draggingNode) return;\n      const {\n        allowDrop,\n        indent\n      } = props;\n      if (emit) doDragOver({\n        event,\n        node: node.rawNode\n      }); // Update dropping node\n\n      const el = event.currentTarget;\n      const {\n        height: elOffsetHeight,\n        top: elClientTop\n      } = el.getBoundingClientRect();\n      const eventOffsetY = event.clientY - elClientTop;\n      let mousePosition;\n      const allowDropInside = allowDrop({\n        node: node.rawNode,\n        dropPosition: 'inside',\n        phase: 'drag'\n      });\n\n      if (allowDropInside) {\n        if (eventOffsetY <= 8) {\n          mousePosition = 'before';\n        } else if (eventOffsetY >= elOffsetHeight - 8) {\n          mousePosition = 'after';\n        } else {\n          mousePosition = 'inside';\n        }\n      } else {\n        if (eventOffsetY <= elOffsetHeight / 2) {\n          mousePosition = 'before';\n        } else {\n          mousePosition = 'after';\n        }\n      }\n\n      const {\n        value: getFindex\n      } = getFIndexRef;\n      /** determine the drop position and drop node */\n\n      /** the dropping node needn't to be the mouse hovering node! */\n\n      /**\n       * if there is something i've learned from implementing a complex\n       * drag & drop. that is never write unit test before you really figure\n       * out what behavior is exactly you want.\n       */\n\n      let finalDropNode;\n      let finalDropPosition;\n      const hoverNodeFIndex = getFindex(node.key);\n\n      if (hoverNodeFIndex === null) {\n        resetDropState();\n        return;\n      }\n\n      let mouseAtExpandedNonLeafNode = false;\n\n      if (mousePosition === 'inside') {\n        finalDropNode = node;\n        finalDropPosition = 'inside';\n      } else {\n        if (mousePosition === 'before') {\n          if (node.isFirstChild) {\n            finalDropNode = node;\n            finalDropPosition = 'before';\n          } else {\n            finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n            finalDropPosition = 'after';\n          }\n        } else {\n          finalDropNode = node;\n          finalDropPosition = 'after';\n        }\n      } // If the node is non-leaf and it is expanded, we don't allow it to\n      // drop after it and change it to drop before its next view sibling\n\n\n      if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n        mouseAtExpandedNonLeafNode = true;\n\n        if (finalDropPosition === 'after') {\n          finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n\n          if (!finalDropNode) {\n            // maybe there is no next view sibling when non-leaf node has no\n            // children and it is the last node in the tree\n            finalDropNode = node;\n            finalDropPosition = 'inside';\n          } else {\n            finalDropPosition = 'before';\n          }\n        }\n      }\n\n      const droppingMouseNode = finalDropNode;\n      droppingMouseNodeRef.value = droppingMouseNode; // This is a speacial case, user is dragging a last child itself, so we\n      // only view it as they are trying to drop after it.\n      // There are some relevant codes in bailout 1's child branch.\n      // Also, the expand bailout should have a high priority. If it's non-leaf\n      // node and expanded, keep its origin drop position\n\n      if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {\n        finalDropPosition = 'after';\n      }\n\n      if (finalDropPosition === 'after') {\n        let offset = dragStartX - event.clientX; // drag left => > 0\n\n        let offsetLevel = 0;\n\n        while (offset >= indent / 2 && // divide by 2 to make it easier to trigger\n        finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {\n          offset -= indent;\n          offsetLevel += 1;\n          finalDropNode = finalDropNode.parent;\n        }\n\n        droppingOffsetLevelRef.value = offsetLevel;\n      } else {\n        droppingOffsetLevelRef.value = 0;\n      } // Bailout 1\n      // Drag self into self\n      // Drag it into direct parent\n\n\n      if (draggingNode.contains(finalDropNode) || finalDropPosition === 'inside' && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {\n        if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key) {// This is special case that we want ui to show a mark to guide user\n          // to start dragging. Nor they will think nothing happens.\n          // However this is an invalid drop, we need to guard it inside\n          // handleDrop\n        } else {\n          resetDropState();\n          return;\n        }\n      } // Bailout 3\n\n\n      if (!allowDrop({\n        node: finalDropNode.rawNode,\n        dropPosition: finalDropPosition,\n        phase: 'drag'\n      })) {\n        resetDropState();\n        return;\n      }\n\n      if (draggingNode.key === finalDropNode.key) {\n        // don't expand when drag on itself\n        resetDragExpandState();\n      } else {\n        if (nodeKeyToBeExpanded !== finalDropNode.key) {\n          if (finalDropPosition === 'inside') {\n            if (props.expandOnDragenter) {\n              expandDragEnterNode(finalDropNode); // Bailout 4\n              // not try to loading\n\n              if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {\n                resetDndState();\n                return;\n              }\n            } else {\n              // Bailout 5\n              // never expands on drag\n              if (!finalDropNode.shallowLoaded) {\n                resetDndState();\n                return;\n              }\n            }\n          } else {\n            resetDragExpandState();\n          }\n        } else {\n          if (finalDropPosition !== 'inside') {\n            resetDragExpandState();\n          }\n        }\n      }\n\n      droppingPositionRef.value = finalDropPosition;\n      droppingNodeRef.value = finalDropNode;\n    }\n\n    function handleDrop({\n      event,\n      node,\n      dropPosition\n    }) {\n      if (!props.draggable || props.disabled || node.disabled) {\n        return;\n      }\n\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      const {\n        value: droppingPosition\n      } = droppingPositionRef;\n\n      if (!draggingNode || !droppingNode || !droppingPosition) {\n        return;\n      } // Bailout 1\n\n\n      if (!props.allowDrop({\n        node: droppingNode.rawNode,\n        dropPosition: droppingPosition,\n        phase: 'drag'\n      })) {\n        return;\n      } // Bailout 2\n      // This is a special case to guard since we want ui to show the status\n      // but not to emit a event\n\n\n      if (draggingNode.key === droppingNode.key) {\n        return;\n      } // Bailout 3\n      // insert before its next node\n      // insert after its prev node\n\n\n      if (droppingPosition === 'before') {\n        const nextNode = draggingNode.getNext({\n          includeDisabled: true\n        });\n\n        if (nextNode) {\n          if (nextNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n\n      if (droppingPosition === 'after') {\n        const prevNode = draggingNode.getPrev({\n          includeDisabled: true\n        });\n\n        if (prevNode) {\n          if (prevNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n\n      doDrop({\n        event,\n        node: droppingNode.rawNode,\n        dragNode: draggingNode.rawNode,\n        dropPosition\n      });\n      resetDndState();\n    }\n\n    function handleScroll() {\n      syncScrollbar();\n    }\n\n    function handleResize() {\n      syncScrollbar();\n    }\n\n    function handleFocusout(e) {\n      var _a;\n\n      if (props.virtualScroll || props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n\n        if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n          return;\n        }\n\n        pendingNodeKeyRef.value = null;\n      } else {\n        const {\n          value: selfEl\n        } = selfElRef;\n        if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget)) return;\n        pendingNodeKeyRef.value = null;\n      }\n    }\n\n    watch(pendingNodeKeyRef, value => {\n      var _a, _b;\n\n      if (value === null) return;\n\n      if (props.virtualScroll) {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({\n          key: value\n        });\n      } else if (props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if (scrollbarInst === null) return;\n        const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n        if (!targetEl) return;\n        scrollbarInst.scrollTo({\n          el: targetEl\n        });\n      }\n    });\n    provide(treeInjectionKey, {\n      loadingKeysRef,\n      highlightKeySetRef: mergedHighlightKeySetRef,\n      displayedCheckedKeysRef,\n      displayedIndeterminateKeysRef,\n      mergedSelectedKeysRef,\n      mergedExpandedKeysRef,\n      mergedThemeRef: themeRef,\n      mergedCheckStrategyRef,\n      nodePropsRef: toRef(props, 'nodeProps'),\n      disabledRef: toRef(props, 'disabled'),\n      checkableRef: toRef(props, 'checkable'),\n      selectableRef: toRef(props, 'selectable'),\n      onLoadRef: toRef(props, 'onLoad'),\n      draggableRef: toRef(props, 'draggable'),\n      blockLineRef: toRef(props, 'blockLine'),\n      indentRef: toRef(props, 'indent'),\n      cascadeRef: toRef(props, 'cascade'),\n      droppingMouseNodeRef,\n      droppingNodeParentRef,\n      draggingNodeRef,\n      droppingPositionRef,\n      droppingOffsetLevelRef,\n      fNodesRef,\n      pendingNodeKeyRef,\n      internalScrollableRef: toRef(props, 'internalScrollable'),\n      internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n      internalTreeSelect: props.internalTreeSelect,\n      renderLabelRef: toRef(props, 'renderLabel'),\n      renderPrefixRef: toRef(props, 'renderPrefix'),\n      renderSuffixRef: toRef(props, 'renderSuffix'),\n      renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n      labelFieldRef: toRef(props, 'labelField'),\n      multipleRef: toRef(props, 'multiple'),\n      handleSwitcherClick,\n      handleDragEnd,\n      handleDragEnter,\n      handleDragLeave,\n      handleDragStart,\n      handleDrop,\n      handleDragOver,\n      handleSelect,\n      handleCheck\n    });\n    const exposedMethods = {\n      handleKeydown,\n      handleKeyup\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          fontSize,\n          nodeBorderRadius,\n          nodeColorHover,\n          nodeColorPressed,\n          nodeColorActive,\n          arrowColor,\n          loadingColor,\n          nodeTextColor,\n          nodeTextColorDisabled,\n          dropMarkColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-arrow-color': arrowColor,\n        '--n-loading-color': loadingColor,\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-font-size': fontSize,\n        '--n-node-border-radius': nodeBorderRadius,\n        '--n-node-color-active': nodeColorActive,\n        '--n-node-color-hover': nodeColorHover,\n        '--n-node-color-pressed': nodeColorPressed,\n        '--n-node-text-color': nodeTextColor,\n        '--n-node-text-color-disabled': nodeTextColorDisabled,\n        '--n-drop-mark-color': dropMarkColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tree', undefined, cssVarsRef, props) : undefined;\n    return {\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedTheme: themeRef,\n      fNodes: mergedFNodesRef,\n      aip: aipRef,\n      selfElRef,\n      virtualListInstRef,\n      scrollbarInstRef,\n      handleFocusout,\n      handleDragLeaveTree,\n      handleScroll,\n      getScrollContainer,\n      getScrollContent,\n      handleAfterEnter,\n      handleResize,\n      handleKeydown: exposedMethods.handleKeydown,\n      handleKeyup: exposedMethods.handleKeyup,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    };\n  },\n\n  render() {\n    var _a;\n\n    const {\n      mergedClsPrefix,\n      blockNode,\n      blockLine,\n      draggable,\n      disabled,\n      internalFocusable,\n      checkable,\n      handleKeyup,\n      handleKeydown,\n      handleFocusout\n    } = this;\n    const mergedFocusable = internalFocusable && !disabled;\n    const tabindex = mergedFocusable ? '0' : undefined;\n    const treeClass = [`${mergedClsPrefix}-tree`, checkable && `${mergedClsPrefix}-tree--checkable`, (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`, blockLine && `${mergedClsPrefix}-tree--block-line`];\n\n    const createNode = tmNode => {\n      return '__motion' in tmNode ? h(MotionWrapper, {\n        height: tmNode.height,\n        nodes: tmNode.nodes,\n        clsPrefix: mergedClsPrefix,\n        mode: tmNode.mode,\n        onAfterEnter: this.handleAfterEnter\n      }) : h(NTreeNode, {\n        key: tmNode.key,\n        tmNode: tmNode,\n        clsPrefix: mergedClsPrefix\n      });\n    };\n\n    if (this.virtualScroll) {\n      const {\n        mergedTheme,\n        internalScrollablePadding\n      } = this;\n      const padding = getPadding(internalScrollablePadding || '0');\n      return h(NxScrollbar, {\n        ref: \"scrollbarInstRef\",\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n        container: this.getScrollContainer,\n        content: this.getScrollContent,\n        class: treeClass,\n        theme: mergedTheme.peers.Scrollbar,\n        themeOverrides: mergedTheme.peerOverrides.Scrollbar,\n        tabindex: tabindex,\n        onKeyup: mergedFocusable ? handleKeyup : undefined,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined\n      }, {\n        default: () => {\n          var _a;\n\n          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n          return h(VVirtualList, {\n            ref: \"virtualListInstRef\",\n            items: this.fNodes,\n            itemSize: ITEM_SIZE,\n            ignoreItemResize: this.aip,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            class: this.themeClass,\n            style: [this.cssVars, {\n              paddingLeft: padding.left,\n              paddingRight: padding.right\n            }],\n            onScroll: this.handleScroll,\n            onResize: this.handleResize,\n            showScrollbar: false,\n            itemResizable: true\n          }, {\n            default: ({\n              item\n            }) => createNode(item)\n          });\n        }\n      });\n    }\n\n    const {\n      internalScrollable\n    } = this;\n    treeClass.push(this.themeClass);\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (internalScrollable) {\n      return h(NxScrollbar, {\n        class: treeClass,\n        tabindex: tabindex,\n        onKeyup: mergedFocusable ? handleKeyup : undefined,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        style: this.cssVars,\n        contentStyle: {\n          padding: this.internalScrollablePadding\n        }\n      }, {\n        default: () => h(\"div\", {\n          onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n          ref: \"selfElRef\"\n        }, this.fNodes.map(createNode))\n      });\n    } else {\n      return h(\"div\", {\n        class: treeClass,\n        tabindex: tabindex,\n        ref: \"selfElRef\",\n        style: this.cssVars,\n        onKeyup: mergedFocusable ? handleKeyup : undefined,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined\n      }, this.fNodes.map(createNode));\n    }\n  }\n\n});","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/tree/src/Tree.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","h","ref","toRef","computed","defineComponent","provide","watch","nextTick","watchEffect","createTreeMate","flatten","createIndexGetter","useMergedState","VVirtualList","getPadding","useConfig","useTheme","useThemeClass","call","createDataKey","warn","NxScrollbar","treeLight","NTreeNode","keysWithFilter","emptyImage","useKeyboard","treeInjectionKey","MotionWrapper","defaultAllowDrop","style","ITEM_SIZE","createTreeMateOptions","keyField","childrenField","getKey","node","getChildren","getDisabled","disabled","checkboxDisabled","treeSharedProps","filter","Function","defaultExpandAll","Boolean","expandedKeys","Array","type","String","default","labelField","defaultExpandedKeys","indeterminateKeys","onUpdateIndeterminateKeys","onUpdateExpandedKeys","treeProps","Object","assign","props","data","expandOnDragenter","cancelable","checkable","draggable","blockNode","blockLine","checkedKeys","defaultCheckedKeys","selectedKeys","defaultSelectedKeys","leafOnly","multiple","pattern","onLoad","cascade","selectable","indent","Number","allowDrop","animated","virtualScroll","watchProps","renderLabel","renderPrefix","renderSuffix","renderSwitcherIcon","nodeProps","onDragenter","onDragleave","onDragend","onDragstart","onDragover","onDrop","onUpdateCheckedKeys","onUpdateSelectedKeys","internalTreeSelect","internalScrollable","internalScrollablePadding","internalDataTreeMate","internalDisplayTreeMate","internalHighlightKeySet","internalUnifySelectCheck","internalHideFilteredNode","internalCheckboxFocusable","internalFocusable","checkStrategy","name","setup","mergedClsPrefixRef","inlineThemeDisabled","themeRef","selfElRef","scrollbarInstRef","virtualListInstRef","getScrollContainer","_a","listElRef","getScrollContent","itemsElRef","displayTreeMateRef","dataTreeMateRef","uncontrolledCheckedKeysRef","includes","controlledCheckedKeysRef","mergedCheckedKeysRef","checkedStatusRef","getCheckedKeys","mergedCheckStrategyRef","displayedCheckedKeysRef","displayedIndeterminateKeysRef","undefined","uncontrolledSelectedKeysRef","controlledSelectedKeysRef","mergedSelectedKeysRef","uncontrolledExpandedKeysRef","initUncontrolledExpandedKeys","keys","getNonLeafKeys","controlledExpandedKeysRef","mergedExpandedKeysRef","fNodesRef","getFlattenedNodes","pendingNodeKeyRef","handleKeyup","handleKeydown","handleSelect","handleSwitcherClick","expandTimerId","nodeKeyToBeExpanded","uncontrolledHighlightKeySetRef","Set","controlledHighlightKeySetRef","mergedHighlightKeySetRef","loadingKeysRef","expandedNonLoadingKeysRef","key","has","dragStartX","draggingNodeRef","droppingNodeRef","droppingMouseNodeRef","droppingPositionRef","droppingOffsetLevelRef","droppingNodeParentRef","droppingNode","parent","mergedFilterRef","length","toLowerCase","clear","resetDndState","deep","expandedKeysAfterChange","highlightKeySet","doUpdateExpandedKeys","getOptionsByKeys","triggerLoading","process","env","NODE_ENV","loadingKeys","add","rawNode","delete","catch","loadError","console","error","resetDragExpandState","displayTreeMate","getNode","forEach","shallowLoaded","aipRef","afNodeRef","prevValue","syncScrollbar","prevVSet","addedKey","removedKey","expandedKey","currentVSet","viewportHeight","offsetHeight","viewportItemCount","Math","ceil","expandedNodeIndex","findIndex","expandedChildren","children","splice","__motion","mode","height","nodes","slice","collapsedNodeIndex","collapsedNodeChildren","collapsedChildren","getFIndexRef","mergedFNodesRef","scrollbarInst","sync","handleAfterEnter","map","option","_onUpdateExpandedKeys","doUpdateCheckedKeys","_onUpdateCheckedKeys","doUpdateIndeterminateKeys","_onUpdateIndeterminateKeys","doUpdateSelectedKeys","_onUpdateSelectedKeys","doDragEnter","info","doDragLeave","doDragEnd","doDragStart","doDragOver","doDrop","resetDragState","resetDropState","window","clearTimeout","handleCheck","checked","toggleExpand","mergedExpandedKeys","index","expandNodeId","from","nodeToBeExpanded","isLeaf","nextKeys","concat","push","expandDragEnterNode","expand","droppingMouseNode","setTimeout","handleDragEnter","event","handleDragOver","handleDragLeave","handleDragLeaveTree","target","currentTarget","handleDragEnd","handleDragStart","dataTransfer","setDragImage","clientX","emit","draggingNode","el","elOffsetHeight","top","elClientTop","getBoundingClientRect","eventOffsetY","clientY","mousePosition","allowDropInside","dropPosition","phase","getFindex","finalDropNode","finalDropPosition","hoverNodeFIndex","mouseAtExpandedNonLeafNode","isFirstChild","isLastChild","offset","offsetLevel","contains","handleDrop","droppingPosition","nextNode","getNext","includeDisabled","prevNode","getPrev","dragNode","handleScroll","handleResize","handleFocusout","containerRef","relatedTarget","selfEl","_b","scrollTo","targetEl","contentRef","querySelector","highlightKeySetRef","mergedThemeRef","nodePropsRef","disabledRef","checkableRef","selectableRef","onLoadRef","draggableRef","blockLineRef","indentRef","cascadeRef","internalScrollableRef","internalCheckboxFocusableRef","renderLabelRef","renderPrefixRef","renderSuffixRef","renderSwitcherIconRef","labelFieldRef","multipleRef","exposedMethods","cssVarsRef","common","cubicBezierEaseInOut","self","fontSize","nodeBorderRadius","nodeColorHover","nodeColorPressed","nodeColorActive","arrowColor","loadingColor","nodeTextColor","nodeTextColorDisabled","dropMarkColor","themeClassHandle","mergedClsPrefix","mergedTheme","fNodes","aip","cssVars","themeClass","onRender","render","mergedFocusable","tabindex","treeClass","createNode","tmNode","clsPrefix","onAfterEnter","padding","container","content","class","theme","peers","Scrollbar","themeOverrides","peerOverrides","onKeyup","onKeydown","onFocusout","items","itemSize","ignoreItemResize","paddingTop","paddingBottom","bottom","paddingLeft","left","paddingRight","right","onScroll","onResize","showScrollbar","itemResizable","item","contentStyle"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { getPadding } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { call, createDataKey, warn } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr';\n// TODO:\n// During expanding, some node are mis-applied with :active style\n// Async dnd has bug\nconst ITEM_SIZE = 30; // 24 + 3 + 3\nexport function createTreeMateOptions(keyField, childrenField) {\n    return {\n        getKey(node) {\n            return node[keyField];\n        },\n        getChildren(node) {\n            return node[childrenField];\n        },\n        getDisabled(node) {\n            return !!(node.disabled || node.checkboxDisabled);\n        }\n    };\n}\nexport const treeSharedProps = {\n    filter: Function,\n    defaultExpandAll: Boolean,\n    expandedKeys: Array,\n    keyField: {\n        type: String,\n        default: 'key'\n    },\n    labelField: {\n        type: String,\n        default: 'label'\n    },\n    childrenField: {\n        type: String,\n        default: 'children'\n    },\n    defaultExpandedKeys: {\n        type: Array,\n        default: () => []\n    },\n    indeterminateKeys: Array,\n    onUpdateIndeterminateKeys: [Function, Array],\n    'onUpdate:indeterminateKeys': [Function, Array],\n    onUpdateExpandedKeys: [Function, Array],\n    'onUpdate:expandedKeys': [Function, Array]\n};\nconst treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { data: {\n        type: Array,\n        default: () => []\n    }, expandOnDragenter: {\n        type: Boolean,\n        default: true\n    }, cancelable: {\n        type: Boolean,\n        default: true\n    }, checkable: Boolean, draggable: Boolean, blockNode: Boolean, blockLine: Boolean, disabled: Boolean, checkedKeys: Array, defaultCheckedKeys: {\n        type: Array,\n        default: () => []\n    }, selectedKeys: Array, defaultSelectedKeys: {\n        type: Array,\n        default: () => []\n    }, leafOnly: Boolean, multiple: Boolean, pattern: {\n        type: String,\n        default: ''\n    }, onLoad: Function, cascade: Boolean, selectable: {\n        type: Boolean,\n        default: true\n    }, indent: {\n        type: Number,\n        default: 16\n    }, allowDrop: {\n        type: Function,\n        default: defaultAllowDrop\n    }, animated: {\n        type: Boolean,\n        default: true\n    }, virtualScroll: Boolean, watchProps: Array, renderLabel: Function, renderPrefix: Function, renderSuffix: Function, renderSwitcherIcon: Function, nodeProps: Function, onDragenter: [Function, Array], onDragleave: [Function, Array], onDragend: [Function, Array], onDragstart: [Function, Array], onDragover: [Function, Array], onDrop: [Function, Array], onUpdateCheckedKeys: [Function, Array], 'onUpdate:checkedKeys': [Function, Array], onUpdateSelectedKeys: [Function, Array], 'onUpdate:selectedKeys': [Function, Array] }), treeSharedProps), { \n    // internal props for tree-select\n    internalTreeSelect: Boolean, internalScrollable: Boolean, internalScrollablePadding: String, \n    // use it to do check\n    internalDataTreeMate: Object, \n    // use it to display\n    internalDisplayTreeMate: Object, internalHighlightKeySet: Object, internalUnifySelectCheck: Boolean, internalHideFilteredNode: Boolean, internalCheckboxFocusable: {\n        type: Boolean,\n        default: true\n    }, internalFocusable: {\n        // Make tree-select take over keyboard operations\n        type: Boolean,\n        default: true\n    }, checkStrategy: {\n        type: String,\n        default: 'all'\n    } });\nexport default defineComponent({\n    name: 'Tree',\n    props: treeProps,\n    setup(props) {\n        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);\n        const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n        const selfElRef = ref(null);\n        const scrollbarInstRef = ref(null);\n        const virtualListInstRef = ref(null);\n        function getScrollContainer() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n        }\n        function getScrollContent() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n        }\n        // We don't expect data source to change so we just determine it once\n        const displayTreeMateRef = props.internalDisplayTreeMate\n            ? toRef(props, 'internalDisplayTreeMate')\n            : computed(() => createTreeMate(props.data, createTreeMateOptions(props.keyField, props.childrenField)));\n        const dataTreeMateRef = props.internalDataTreeMate\n            ? toRef(props, 'internalDataTreeMate')\n            : displayTreeMateRef;\n        const { watchProps } = props;\n        const uncontrolledCheckedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n            watchEffect(() => {\n                uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n            });\n        }\n        else {\n            uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n        }\n        const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n        const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n        const checkedStatusRef = computed(() => {\n            const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n                cascade: props.cascade\n            });\n            return value;\n        });\n        const mergedCheckStrategyRef = computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n        const displayedCheckedKeysRef = computed(() => {\n            return checkedStatusRef.value.checkedKeys;\n        });\n        const displayedIndeterminateKeysRef = computed(() => {\n            const { indeterminateKeys } = props;\n            if (indeterminateKeys !== undefined)\n                return indeterminateKeys;\n            return checkedStatusRef.value.indeterminateKeys;\n        });\n        const uncontrolledSelectedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n            watchEffect(() => {\n                uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n            });\n        }\n        else {\n            uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n        }\n        const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n        const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n        const uncontrolledExpandedKeysRef = ref([]);\n        const initUncontrolledExpandedKeys = (keys) => {\n            uncontrolledExpandedKeysRef.value = props.defaultExpandAll\n                ? dataTreeMateRef.value.getNonLeafKeys()\n                : keys === undefined\n                    ? props.defaultExpandedKeys\n                    : keys;\n        };\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n            // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n            watchEffect(() => initUncontrolledExpandedKeys(undefined));\n        }\n        else {\n            // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n            watchEffect(() => initUncontrolledExpandedKeys(props.defaultExpandedKeys));\n        }\n        const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n        const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n        const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n        const { pendingNodeKeyRef, handleKeyup, handleKeydown } = useKeyboard({\n            mergedSelectedKeysRef,\n            fNodesRef,\n            mergedExpandedKeysRef,\n            handleSelect,\n            handleSwitcherClick\n        });\n        let expandTimerId = null;\n        let nodeKeyToBeExpanded = null;\n        const uncontrolledHighlightKeySetRef = ref(new Set());\n        const controlledHighlightKeySetRef = toRef(props, 'internalHighlightKeySet');\n        const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n        const loadingKeysRef = ref(new Set());\n        const expandedNonLoadingKeysRef = computed(() => {\n            return mergedExpandedKeysRef.value.filter((key) => !loadingKeysRef.value.has(key));\n        });\n        let dragStartX = 0;\n        const draggingNodeRef = ref(null);\n        const droppingNodeRef = ref(null);\n        const droppingMouseNodeRef = ref(null);\n        const droppingPositionRef = ref(null);\n        const droppingOffsetLevelRef = ref(0);\n        const droppingNodeParentRef = computed(() => {\n            const { value: droppingNode } = droppingNodeRef;\n            if (!droppingNode)\n                return null;\n            // May avoid overlap between line mark of first child & rect mark of parent\n            // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n            //   return null\n            // }\n            return droppingNode.parent;\n        });\n        const mergedFilterRef = computed(() => {\n            const { filter } = props;\n            if (filter)\n                return filter;\n            const { labelField } = props;\n            return (pattern, node) => {\n                if (!pattern.length)\n                    return true;\n                return node[labelField]\n                    .toLowerCase()\n                    .includes(pattern.toLowerCase());\n            };\n        });\n        // shallow watch data\n        watch(toRef(props, 'data'), () => {\n            loadingKeysRef.value.clear();\n            pendingNodeKeyRef.value = null;\n            resetDndState();\n        }, {\n            deep: false\n        });\n        watch(toRef(props, 'pattern'), (value) => {\n            if (value) {\n                const { expandedKeys: expandedKeysAfterChange, highlightKeySet } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n                uncontrolledHighlightKeySetRef.value = highlightKeySet;\n                doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n            }\n            else {\n                uncontrolledHighlightKeySetRef.value = new Set();\n            }\n        });\n        function triggerLoading(node) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { onLoad } = props;\n                if (!onLoad) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n                    }\n                    return yield Promise.resolve();\n                }\n                const { value: loadingKeys } = loadingKeysRef;\n                return yield new Promise((resolve) => {\n                    if (!loadingKeys.has(node.key)) {\n                        loadingKeys.add(node.key);\n                        onLoad(node.rawNode)\n                            .then(() => {\n                            loadingKeys.delete(node.key);\n                            resolve();\n                        })\n                            .catch((loadError) => {\n                            console.error(loadError);\n                            resetDragExpandState();\n                        });\n                    }\n                });\n            });\n        }\n        watchEffect(() => {\n            var _a;\n            const { value: displayTreeMate } = displayTreeMateRef;\n            if (!displayTreeMate)\n                return;\n            const { getNode } = displayTreeMate;\n            (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const node = getNode(key);\n                if (node && !node.shallowLoaded) {\n                    void triggerLoading(node);\n                }\n            });\n        });\n        // animation in progress\n        const aipRef = ref(false);\n        // animation flattened nodes\n        const afNodeRef = ref([]);\n        // Note: Since the virtual list depends on min height, if there's a node\n        // whose height starts from 0, the virtual list will have a wrong height\n        // during animation. This will seldom cause wired scrollbar status. It is\n        // fixable and need some changes in vueuc, I've no time so I just leave it\n        // here. Maybe the bug won't be fixed during the life time of the project.\n        watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n            if (!props.animated) {\n                void nextTick(syncScrollbar);\n                return;\n            }\n            const prevVSet = new Set(prevValue);\n            let addedKey = null;\n            let removedKey = null;\n            for (const expandedKey of value) {\n                if (!prevVSet.has(expandedKey)) {\n                    if (addedKey !== null)\n                        return; // multi expand, not triggered by click\n                    addedKey = expandedKey;\n                }\n            }\n            const currentVSet = new Set(value);\n            for (const expandedKey of prevValue) {\n                if (!currentVSet.has(expandedKey)) {\n                    if (removedKey !== null)\n                        return; // multi collapse, not triggered by click\n                    removedKey = expandedKey;\n                }\n            }\n            if ((addedKey !== null && removedKey !== null) ||\n                (addedKey === null && removedKey === null)) {\n                // 1. multi action, not triggered by click\n                // 2. no action, don't know what happened\n                return;\n            }\n            const { virtualScroll } = props;\n            const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n            const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1;\n            if (addedKey !== null) {\n                // play add animation\n                aipRef.value = true;\n                afNodeRef.value = displayTreeMateRef.value.getFlattenedNodes(prevValue);\n                const expandedNodeIndex = afNodeRef.value.findIndex((node) => node.key === addedKey);\n                if (~expandedNodeIndex) {\n                    const expandedChildren = flatten(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    afNodeRef.value[expandedNodeIndex].children, value);\n                    afNodeRef.value.splice(expandedNodeIndex + 1, 0, {\n                        __motion: true,\n                        mode: 'expand',\n                        height: virtualScroll\n                            ? expandedChildren.length * ITEM_SIZE\n                            : undefined,\n                        nodes: virtualScroll\n                            ? expandedChildren.slice(0, viewportItemCount)\n                            : expandedChildren\n                    });\n                }\n            }\n            if (removedKey !== null) {\n                afNodeRef.value = displayTreeMateRef.value.getFlattenedNodes(value);\n                const collapsedNodeIndex = afNodeRef.value.findIndex((node) => node.key === removedKey);\n                if (~collapsedNodeIndex) {\n                    const collapsedNodeChildren = afNodeRef.value[collapsedNodeIndex].children;\n                    // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n                    // but maybe children removed\n                    if (!collapsedNodeChildren)\n                        return;\n                    // play remove animation\n                    aipRef.value = true;\n                    const collapsedChildren = flatten(collapsedNodeChildren, value);\n                    afNodeRef.value.splice(collapsedNodeIndex + 1, 0, {\n                        __motion: true,\n                        mode: 'collapse',\n                        height: virtualScroll\n                            ? collapsedChildren.length * ITEM_SIZE\n                            : undefined,\n                        nodes: virtualScroll\n                            ? collapsedChildren.slice(0, viewportItemCount)\n                            : collapsedChildren\n                    });\n                }\n            }\n        });\n        const getFIndexRef = computed(() => {\n            return createIndexGetter(fNodesRef.value);\n        });\n        const mergedFNodesRef = computed(() => {\n            if (aipRef.value)\n                return afNodeRef.value;\n            else\n                return fNodesRef.value;\n        });\n        function syncScrollbar() {\n            const { value: scrollbarInst } = scrollbarInstRef;\n            if (scrollbarInst)\n                scrollbarInst.sync();\n        }\n        function handleAfterEnter() {\n            aipRef.value = false;\n            if (props.virtualScroll) {\n                // If virtual scroll, we won't listen to resize during animation, so\n                // resize callback of virtual list won't be called and as a result\n                // scrollbar won't sync. We need to sync scrollbar manually.\n                void nextTick(syncScrollbar);\n            }\n        }\n        function getOptionsByKeys(keys) {\n            const { getNode } = dataTreeMateRef.value;\n            return keys.map((key) => { var _a; return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; });\n        }\n        function doUpdateExpandedKeys(value, option) {\n            const { 'onUpdate:expandedKeys': _onUpdateExpandedKeys, onUpdateExpandedKeys } = props;\n            uncontrolledExpandedKeysRef.value = value;\n            if (_onUpdateExpandedKeys) {\n                call(_onUpdateExpandedKeys, value, option);\n            }\n            if (onUpdateExpandedKeys) {\n                call(onUpdateExpandedKeys, value, option);\n            }\n        }\n        function doUpdateCheckedKeys(value, option) {\n            const { 'onUpdate:checkedKeys': _onUpdateCheckedKeys, onUpdateCheckedKeys } = props;\n            uncontrolledCheckedKeysRef.value = value;\n            if (onUpdateCheckedKeys) {\n                call(onUpdateCheckedKeys, value, option);\n            }\n            if (_onUpdateCheckedKeys) {\n                call(_onUpdateCheckedKeys, value, option);\n            }\n        }\n        function doUpdateIndeterminateKeys(value, option) {\n            const { 'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys, onUpdateIndeterminateKeys } = props;\n            if (_onUpdateIndeterminateKeys) {\n                call(_onUpdateIndeterminateKeys, value, option);\n            }\n            if (onUpdateIndeterminateKeys) {\n                call(onUpdateIndeterminateKeys, value, option);\n            }\n        }\n        function doUpdateSelectedKeys(value, option) {\n            const { 'onUpdate:selectedKeys': _onUpdateSelectedKeys, onUpdateSelectedKeys } = props;\n            uncontrolledSelectedKeysRef.value = value;\n            if (onUpdateSelectedKeys) {\n                call(onUpdateSelectedKeys, value, option);\n            }\n            if (_onUpdateSelectedKeys) {\n                call(_onUpdateSelectedKeys, value, option);\n            }\n        }\n        // Drag & Drop\n        function doDragEnter(info) {\n            const { onDragenter } = props;\n            if (onDragenter)\n                call(onDragenter, info);\n        }\n        function doDragLeave(info) {\n            const { onDragleave } = props;\n            if (onDragleave)\n                call(onDragleave, info);\n        }\n        function doDragEnd(info) {\n            const { onDragend } = props;\n            if (onDragend)\n                call(onDragend, info);\n        }\n        function doDragStart(info) {\n            const { onDragstart } = props;\n            if (onDragstart)\n                call(onDragstart, info);\n        }\n        function doDragOver(info) {\n            const { onDragover } = props;\n            if (onDragover)\n                call(onDragover, info);\n        }\n        function doDrop(info) {\n            const { onDrop } = props;\n            if (onDrop)\n                call(onDrop, info);\n        }\n        function resetDndState() {\n            resetDragState();\n            resetDropState();\n        }\n        function resetDragState() {\n            draggingNodeRef.value = null;\n        }\n        function resetDropState() {\n            droppingOffsetLevelRef.value = 0;\n            droppingNodeRef.value = null;\n            droppingMouseNodeRef.value = null;\n            droppingPositionRef.value = null;\n            resetDragExpandState();\n        }\n        function resetDragExpandState() {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            nodeKeyToBeExpanded = null;\n        }\n        function handleCheck(node, checked) {\n            // We don't guard for leaf only since we have done it in view layer\n            if (props.disabled || node.disabled) {\n                return;\n            }\n            if (props.internalUnifySelectCheck && !props.multiple) {\n                handleSelect(node);\n                return;\n            }\n            const { checkedKeys, indeterminateKeys } = dataTreeMateRef.value[checked ? 'check' : 'uncheck'](node.key, displayedCheckedKeysRef.value, {\n                cascade: props.cascade,\n                checkStrategy: mergedCheckStrategyRef.value\n            });\n            doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys));\n            doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n        }\n        function toggleExpand(key) {\n            if (props.disabled)\n                return;\n            const { value: mergedExpandedKeys } = mergedExpandedKeysRef;\n            const index = mergedExpandedKeys.findIndex((expandNodeId) => expandNodeId === key);\n            if (~index) {\n                const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n                expandedKeysAfterChange.splice(index, 1);\n                doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n            }\n            else {\n                const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n                if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n                    return;\n                }\n                const nextKeys = mergedExpandedKeys.concat(key);\n                doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n            }\n        }\n        function handleSwitcherClick(node) {\n            if (props.disabled || aipRef.value)\n                return;\n            toggleExpand(node.key);\n        }\n        function handleSelect(node) {\n            if (props.disabled ||\n                node.disabled ||\n                !props.selectable ||\n                (props.internalTreeSelect &&\n                    !props.multiple &&\n                    mergedCheckStrategyRef.value === 'child' &&\n                    !node.isLeaf)) {\n                return;\n            }\n            pendingNodeKeyRef.value = node.key;\n            if (props.internalUnifySelectCheck) {\n                const { value: { checkedKeys, indeterminateKeys } } = checkedStatusRef;\n                if (props.multiple) {\n                    handleCheck(node, !(checkedKeys.includes(node.key) ||\n                        indeterminateKeys.includes(node.key)));\n                }\n                else {\n                    doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]));\n                }\n            }\n            if (props.multiple) {\n                const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n                const index = selectedKeys.findIndex((key) => key === node.key);\n                if (~index) {\n                    if (props.cancelable) {\n                        selectedKeys.splice(index, 1);\n                    }\n                }\n                else if (!~index) {\n                    selectedKeys.push(node.key);\n                }\n                doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys));\n            }\n            else {\n                const selectedKeys = mergedSelectedKeysRef.value;\n                if (selectedKeys.includes(node.key)) {\n                    if (props.cancelable) {\n                        doUpdateSelectedKeys([], []);\n                    }\n                }\n                else {\n                    doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]));\n                }\n            }\n        }\n        function expandDragEnterNode(node) {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            // Don't expand leaf node.\n            if (node.isLeaf)\n                return;\n            nodeKeyToBeExpanded = node.key;\n            const expand = () => {\n                if (nodeKeyToBeExpanded !== node.key)\n                    return;\n                const { value: droppingMouseNode } = droppingMouseNodeRef;\n                if (droppingMouseNode &&\n                    droppingMouseNode.key === node.key &&\n                    !mergedExpandedKeysRef.value.includes(node.key)) {\n                    const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n                    doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n                }\n                expandTimerId = null;\n                nodeKeyToBeExpanded = null;\n            };\n            if (!node.shallowLoaded) {\n                expandTimerId = window.setTimeout(() => {\n                    void triggerLoading(node).then(() => {\n                        expand();\n                    });\n                }, 1000);\n            }\n            else {\n                expandTimerId = window.setTimeout(() => {\n                    expand();\n                }, 1000);\n            }\n        }\n        // Dnd\n        function handleDragEnter({ event, node }) {\n            // node should be a tmNode\n            if (!props.draggable || props.disabled || node.disabled)\n                return;\n            handleDragOver({ event, node }, false);\n            doDragEnter({ event, node: node.rawNode });\n        }\n        function handleDragLeave({ event, node }) {\n            if (!props.draggable || props.disabled || node.disabled)\n                return;\n            doDragLeave({ event, node: node.rawNode });\n        }\n        function handleDragLeaveTree(e) {\n            if (e.target !== e.currentTarget)\n                return;\n            resetDropState();\n        }\n        // Dragend is ok, we don't need to add global listener to reset drag status\n        function handleDragEnd({ event, node }) {\n            resetDndState();\n            if (!props.draggable || props.disabled || node.disabled)\n                return;\n            doDragEnd({ event, node: node.rawNode });\n        }\n        function handleDragStart({ event, node }) {\n            var _a;\n            if (!props.draggable || props.disabled || node.disabled)\n                return;\n            // Most of time, the image will block user's view\n            emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n            dragStartX = event.clientX;\n            draggingNodeRef.value = node;\n            doDragStart({ event, node: node.rawNode });\n        }\n        function handleDragOver({ event, node }, emit = true) {\n            var _a;\n            if (!props.draggable || props.disabled || node.disabled)\n                return;\n            const { value: draggingNode } = draggingNodeRef;\n            if (!draggingNode)\n                return;\n            const { allowDrop, indent } = props;\n            if (emit)\n                doDragOver({ event, node: node.rawNode });\n            // Update dropping node\n            const el = event.currentTarget;\n            const { height: elOffsetHeight, top: elClientTop } = el.getBoundingClientRect();\n            const eventOffsetY = event.clientY - elClientTop;\n            let mousePosition;\n            const allowDropInside = allowDrop({\n                node: node.rawNode,\n                dropPosition: 'inside',\n                phase: 'drag'\n            });\n            if (allowDropInside) {\n                if (eventOffsetY <= 8) {\n                    mousePosition = 'before';\n                }\n                else if (eventOffsetY >= elOffsetHeight - 8) {\n                    mousePosition = 'after';\n                }\n                else {\n                    mousePosition = 'inside';\n                }\n            }\n            else {\n                if (eventOffsetY <= elOffsetHeight / 2) {\n                    mousePosition = 'before';\n                }\n                else {\n                    mousePosition = 'after';\n                }\n            }\n            const { value: getFindex } = getFIndexRef;\n            /** determine the drop position and drop node */\n            /** the dropping node needn't to be the mouse hovering node! */\n            /**\n             * if there is something i've learned from implementing a complex\n             * drag & drop. that is never write unit test before you really figure\n             * out what behavior is exactly you want.\n             */\n            let finalDropNode;\n            let finalDropPosition;\n            const hoverNodeFIndex = getFindex(node.key);\n            if (hoverNodeFIndex === null) {\n                resetDropState();\n                return;\n            }\n            let mouseAtExpandedNonLeafNode = false;\n            if (mousePosition === 'inside') {\n                finalDropNode = node;\n                finalDropPosition = 'inside';\n            }\n            else {\n                if (mousePosition === 'before') {\n                    if (node.isFirstChild) {\n                        finalDropNode = node;\n                        finalDropPosition = 'before';\n                    }\n                    else {\n                        finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n                        finalDropPosition = 'after';\n                    }\n                }\n                else {\n                    finalDropNode = node;\n                    finalDropPosition = 'after';\n                }\n            }\n            // If the node is non-leaf and it is expanded, we don't allow it to\n            // drop after it and change it to drop before its next view sibling\n            if (!finalDropNode.isLeaf &&\n                mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n                mouseAtExpandedNonLeafNode = true;\n                if (finalDropPosition === 'after') {\n                    finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n                    if (!finalDropNode) {\n                        // maybe there is no next view sibling when non-leaf node has no\n                        // children and it is the last node in the tree\n                        finalDropNode = node;\n                        finalDropPosition = 'inside';\n                    }\n                    else {\n                        finalDropPosition = 'before';\n                    }\n                }\n            }\n            const droppingMouseNode = finalDropNode;\n            droppingMouseNodeRef.value = droppingMouseNode;\n            // This is a speacial case, user is dragging a last child itself, so we\n            // only view it as they are trying to drop after it.\n            // There are some relevant codes in bailout 1's child branch.\n            // Also, the expand bailout should have a high priority. If it's non-leaf\n            // node and expanded, keep its origin drop position\n            if (!mouseAtExpandedNonLeafNode &&\n                draggingNode.isLastChild &&\n                draggingNode.key === finalDropNode.key) {\n                finalDropPosition = 'after';\n            }\n            if (finalDropPosition === 'after') {\n                let offset = dragStartX - event.clientX; // drag left => > 0\n                let offsetLevel = 0;\n                while (offset >= indent / 2 && // divide by 2 to make it easier to trigger\n                    finalDropNode.parent !== null &&\n                    finalDropNode.isLastChild &&\n                    offsetLevel < 1) {\n                    offset -= indent;\n                    offsetLevel += 1;\n                    finalDropNode = finalDropNode.parent;\n                }\n                droppingOffsetLevelRef.value = offsetLevel;\n            }\n            else {\n                droppingOffsetLevelRef.value = 0;\n            }\n            // Bailout 1\n            // Drag self into self\n            // Drag it into direct parent\n            if (draggingNode.contains(finalDropNode) ||\n                (finalDropPosition === 'inside' &&\n                    ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key)) {\n                if (draggingNode.key === droppingMouseNode.key &&\n                    draggingNode.key === finalDropNode.key) {\n                    // This is special case that we want ui to show a mark to guide user\n                    // to start dragging. Nor they will think nothing happens.\n                    // However this is an invalid drop, we need to guard it inside\n                    // handleDrop\n                }\n                else {\n                    resetDropState();\n                    return;\n                }\n            }\n            // Bailout 3\n            if (!allowDrop({\n                node: finalDropNode.rawNode,\n                dropPosition: finalDropPosition,\n                phase: 'drag'\n            })) {\n                resetDropState();\n                return;\n            }\n            if (draggingNode.key === finalDropNode.key) {\n                // don't expand when drag on itself\n                resetDragExpandState();\n            }\n            else {\n                if (nodeKeyToBeExpanded !== finalDropNode.key) {\n                    if (finalDropPosition === 'inside') {\n                        if (props.expandOnDragenter) {\n                            expandDragEnterNode(finalDropNode);\n                            // Bailout 4\n                            // not try to loading\n                            if (!finalDropNode.shallowLoaded &&\n                                nodeKeyToBeExpanded !== finalDropNode.key) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                        else {\n                            // Bailout 5\n                            // never expands on drag\n                            if (!finalDropNode.shallowLoaded) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                    }\n                    else {\n                        resetDragExpandState();\n                    }\n                }\n                else {\n                    if (finalDropPosition !== 'inside') {\n                        resetDragExpandState();\n                    }\n                }\n            }\n            droppingPositionRef.value = finalDropPosition;\n            droppingNodeRef.value = finalDropNode;\n        }\n        function handleDrop({ event, node, dropPosition }) {\n            if (!props.draggable || props.disabled || node.disabled) {\n                return;\n            }\n            const { value: draggingNode } = draggingNodeRef;\n            const { value: droppingNode } = droppingNodeRef;\n            const { value: droppingPosition } = droppingPositionRef;\n            if (!draggingNode || !droppingNode || !droppingPosition) {\n                return;\n            }\n            // Bailout 1\n            if (!props.allowDrop({\n                node: droppingNode.rawNode,\n                dropPosition: droppingPosition,\n                phase: 'drag'\n            })) {\n                return;\n            }\n            // Bailout 2\n            // This is a special case to guard since we want ui to show the status\n            // but not to emit a event\n            if (draggingNode.key === droppingNode.key) {\n                return;\n            }\n            // Bailout 3\n            // insert before its next node\n            // insert after its prev node\n            if (droppingPosition === 'before') {\n                const nextNode = draggingNode.getNext({ includeDisabled: true });\n                if (nextNode) {\n                    if (nextNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            if (droppingPosition === 'after') {\n                const prevNode = draggingNode.getPrev({ includeDisabled: true });\n                if (prevNode) {\n                    if (prevNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            doDrop({\n                event,\n                node: droppingNode.rawNode,\n                dragNode: draggingNode.rawNode,\n                dropPosition\n            });\n            resetDndState();\n        }\n        function handleScroll() {\n            syncScrollbar();\n        }\n        function handleResize() {\n            syncScrollbar();\n        }\n        function handleFocusout(e) {\n            var _a;\n            if (props.virtualScroll || props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n                    return;\n                }\n                pendingNodeKeyRef.value = null;\n            }\n            else {\n                const { value: selfEl } = selfElRef;\n                if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget))\n                    return;\n                pendingNodeKeyRef.value = null;\n            }\n        }\n        watch(pendingNodeKeyRef, (value) => {\n            var _a, _b;\n            if (value === null)\n                return;\n            if (props.virtualScroll) {\n                (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ key: value });\n            }\n            else if (props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if (scrollbarInst === null)\n                    return;\n                const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n                if (!targetEl)\n                    return;\n                scrollbarInst.scrollTo({\n                    el: targetEl\n                });\n            }\n        });\n        provide(treeInjectionKey, {\n            loadingKeysRef,\n            highlightKeySetRef: mergedHighlightKeySetRef,\n            displayedCheckedKeysRef,\n            displayedIndeterminateKeysRef,\n            mergedSelectedKeysRef,\n            mergedExpandedKeysRef,\n            mergedThemeRef: themeRef,\n            mergedCheckStrategyRef,\n            nodePropsRef: toRef(props, 'nodeProps'),\n            disabledRef: toRef(props, 'disabled'),\n            checkableRef: toRef(props, 'checkable'),\n            selectableRef: toRef(props, 'selectable'),\n            onLoadRef: toRef(props, 'onLoad'),\n            draggableRef: toRef(props, 'draggable'),\n            blockLineRef: toRef(props, 'blockLine'),\n            indentRef: toRef(props, 'indent'),\n            cascadeRef: toRef(props, 'cascade'),\n            droppingMouseNodeRef,\n            droppingNodeParentRef,\n            draggingNodeRef,\n            droppingPositionRef,\n            droppingOffsetLevelRef,\n            fNodesRef,\n            pendingNodeKeyRef,\n            internalScrollableRef: toRef(props, 'internalScrollable'),\n            internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n            internalTreeSelect: props.internalTreeSelect,\n            renderLabelRef: toRef(props, 'renderLabel'),\n            renderPrefixRef: toRef(props, 'renderPrefix'),\n            renderSuffixRef: toRef(props, 'renderSuffix'),\n            renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n            labelFieldRef: toRef(props, 'labelField'),\n            multipleRef: toRef(props, 'multiple'),\n            handleSwitcherClick,\n            handleDragEnd,\n            handleDragEnter,\n            handleDragLeave,\n            handleDragStart,\n            handleDrop,\n            handleDragOver,\n            handleSelect,\n            handleCheck\n        });\n        const exposedMethods = {\n            handleKeydown,\n            handleKeyup\n        };\n        const cssVarsRef = computed(() => {\n            const { common: { cubicBezierEaseInOut }, self: { fontSize, nodeBorderRadius, nodeColorHover, nodeColorPressed, nodeColorActive, arrowColor, loadingColor, nodeTextColor, nodeTextColorDisabled, dropMarkColor } } = themeRef.value;\n            return {\n                '--n-arrow-color': arrowColor,\n                '--n-loading-color': loadingColor,\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-font-size': fontSize,\n                '--n-node-border-radius': nodeBorderRadius,\n                '--n-node-color-active': nodeColorActive,\n                '--n-node-color-hover': nodeColorHover,\n                '--n-node-color-pressed': nodeColorPressed,\n                '--n-node-text-color': nodeTextColor,\n                '--n-node-text-color-disabled': nodeTextColorDisabled,\n                '--n-drop-mark-color': dropMarkColor\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('tree', undefined, cssVarsRef, props)\n            : undefined;\n        return {\n            mergedClsPrefix: mergedClsPrefixRef,\n            mergedTheme: themeRef,\n            fNodes: mergedFNodesRef,\n            aip: aipRef,\n            selfElRef,\n            virtualListInstRef,\n            scrollbarInstRef,\n            handleFocusout,\n            handleDragLeaveTree,\n            handleScroll,\n            getScrollContainer,\n            getScrollContent,\n            handleAfterEnter,\n            handleResize,\n            handleKeydown: exposedMethods.handleKeydown,\n            handleKeyup: exposedMethods.handleKeyup,\n            cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n        };\n    },\n    render() {\n        var _a;\n        const { mergedClsPrefix, blockNode, blockLine, draggable, disabled, internalFocusable, checkable, handleKeyup, handleKeydown, handleFocusout } = this;\n        const mergedFocusable = internalFocusable && !disabled;\n        const tabindex = mergedFocusable ? '0' : undefined;\n        const treeClass = [\n            `${mergedClsPrefix}-tree`,\n            checkable && `${mergedClsPrefix}-tree--checkable`,\n            (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`,\n            blockLine && `${mergedClsPrefix}-tree--block-line`\n        ];\n        const createNode = (tmNode) => {\n            return '__motion' in tmNode ? (h(MotionWrapper, { height: tmNode.height, nodes: tmNode.nodes, clsPrefix: mergedClsPrefix, mode: tmNode.mode, onAfterEnter: this.handleAfterEnter })) : (h(NTreeNode, { key: tmNode.key, tmNode: tmNode, clsPrefix: mergedClsPrefix }));\n        };\n        if (this.virtualScroll) {\n            const { mergedTheme, internalScrollablePadding } = this;\n            const padding = getPadding(internalScrollablePadding || '0');\n            return (h(NxScrollbar, { ref: \"scrollbarInstRef\", onDragleave: draggable ? this.handleDragLeaveTree : undefined, container: this.getScrollContainer, content: this.getScrollContent, class: treeClass, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, tabindex: tabindex, onKeyup: mergedFocusable ? handleKeyup : undefined, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined }, {\n                default: () => {\n                    var _a;\n                    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n                    return (h(VVirtualList, { ref: \"virtualListInstRef\", items: this.fNodes, itemSize: ITEM_SIZE, ignoreItemResize: this.aip, paddingTop: padding.top, paddingBottom: padding.bottom, class: this.themeClass, style: [\n                            this.cssVars,\n                            {\n                                paddingLeft: padding.left,\n                                paddingRight: padding.right\n                            }\n                        ], onScroll: this.handleScroll, onResize: this.handleResize, showScrollbar: false, itemResizable: true }, {\n                        default: ({ item }) => createNode(item)\n                    }));\n                }\n            }));\n        }\n        const { internalScrollable } = this;\n        treeClass.push(this.themeClass);\n        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (internalScrollable) {\n            return (h(NxScrollbar, { class: treeClass, tabindex: tabindex, onKeyup: mergedFocusable ? handleKeyup : undefined, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, style: this.cssVars, contentStyle: { padding: this.internalScrollablePadding } }, {\n                default: () => (h(\"div\", { onDragleave: draggable ? this.handleDragLeaveTree : undefined, ref: \"selfElRef\" }, this.fNodes.map(createNode)))\n            }));\n        }\n        else {\n            return (h(\"div\", { class: treeClass, tabindex: tabindex, ref: \"selfElRef\", style: this.cssVars, onKeyup: mergedFocusable ? handleKeyup : undefined, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, onDragleave: draggable ? this.handleDragLeaveTree : undefined }, this.fNodes.map(createNode)));\n        }\n    }\n});\n"]},"metadata":{},"sourceType":"module"}