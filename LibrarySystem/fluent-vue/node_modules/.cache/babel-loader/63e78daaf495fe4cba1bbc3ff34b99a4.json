{"ast":null,"code":"import { DOM } from \"../dom\";\nimport { ExecutionContext, Observable } from \"../observation/observable\";\nimport { TargetedHTMLDirective } from \"./html-directive\";\n\nfunction normalBind(source, context) {\n  this.source = source;\n  this.context = context;\n\n  if (this.bindingObserver === null) {\n    this.bindingObserver = Observable.binding(this.binding, this, this.isBindingVolatile);\n  }\n\n  this.updateTarget(this.bindingObserver.observe(source, context));\n}\n\nfunction triggerBind(source, context) {\n  this.source = source;\n  this.context = context;\n  this.target.addEventListener(this.targetName, this);\n}\n\nfunction normalUnbind() {\n  this.bindingObserver.disconnect();\n  this.source = null;\n  this.context = null;\n}\n\nfunction contentUnbind() {\n  this.bindingObserver.disconnect();\n  this.source = null;\n  this.context = null;\n  const view = this.target.$fastView;\n\n  if (view !== void 0 && view.isComposed) {\n    view.unbind();\n    view.needsBindOnly = true;\n  }\n}\n\nfunction triggerUnbind() {\n  this.target.removeEventListener(this.targetName, this);\n  this.source = null;\n  this.context = null;\n}\n\nfunction updateAttributeTarget(value) {\n  DOM.setAttribute(this.target, this.targetName, value);\n}\n\nfunction updateBooleanAttributeTarget(value) {\n  DOM.setBooleanAttribute(this.target, this.targetName, value);\n}\n\nfunction updateContentTarget(value) {\n  // If there's no actual value, then this equates to the\n  // empty string for the purposes of content bindings.\n  if (value === null || value === undefined) {\n    value = \"\";\n  } // If the value has a \"create\" method, then it's a template-like.\n\n\n  if (value.create) {\n    this.target.textContent = \"\";\n    let view = this.target.$fastView; // If there's no previous view that we might be able to\n    // reuse then create a new view from the template.\n\n    if (view === void 0) {\n      view = value.create();\n    } else {\n      // If there is a previous view, but it wasn't created\n      // from the same template as the new value, then we\n      // need to remove the old view if it's still in the DOM\n      // and create a new view from the template.\n      if (this.target.$fastTemplate !== value) {\n        if (view.isComposed) {\n          view.remove();\n          view.unbind();\n        }\n\n        view = value.create();\n      }\n    } // It's possible that the value is the same as the previous template\n    // and that there's actually no need to compose it.\n\n\n    if (!view.isComposed) {\n      view.isComposed = true;\n      view.bind(this.source, this.context);\n      view.insertBefore(this.target);\n      this.target.$fastView = view;\n      this.target.$fastTemplate = value;\n    } else if (view.needsBindOnly) {\n      view.needsBindOnly = false;\n      view.bind(this.source, this.context);\n    }\n  } else {\n    const view = this.target.$fastView; // If there is a view and it's currently composed into\n    // the DOM, then we need to remove it.\n\n    if (view !== void 0 && view.isComposed) {\n      view.isComposed = false;\n      view.remove();\n\n      if (view.needsBindOnly) {\n        view.needsBindOnly = false;\n      } else {\n        view.unbind();\n      }\n    }\n\n    this.target.textContent = value;\n  }\n}\n\nfunction updatePropertyTarget(value) {\n  this.target[this.targetName] = value;\n}\n\nfunction updateClassTarget(value) {\n  const classVersions = this.classVersions || Object.create(null);\n  const target = this.target;\n  let version = this.version || 0; // Add the classes, tracking the version at which they were added.\n\n  if (value !== null && value !== undefined && value.length) {\n    const names = value.split(/\\s+/);\n\n    for (let i = 0, ii = names.length; i < ii; ++i) {\n      const currentName = names[i];\n\n      if (currentName === \"\") {\n        continue;\n      }\n\n      classVersions[currentName] = version;\n      target.classList.add(currentName);\n    }\n  }\n\n  this.classVersions = classVersions;\n  this.version = version + 1; // If this is the first call to add classes, there's no need to remove old ones.\n\n  if (version === 0) {\n    return;\n  } // Remove classes from the previous version.\n\n\n  version -= 1;\n\n  for (const name in classVersions) {\n    if (classVersions[name] === version) {\n      target.classList.remove(name);\n    }\n  }\n}\n/**\n * A directive that configures data binding to element content and attributes.\n * @public\n */\n\n\nexport class HTMLBindingDirective extends TargetedHTMLDirective {\n  /**\n   * Creates an instance of BindingDirective.\n   * @param binding - A binding that returns the data used to update the DOM.\n   */\n  constructor(binding) {\n    super();\n    this.binding = binding;\n    this.bind = normalBind;\n    this.unbind = normalUnbind;\n    this.updateTarget = updateAttributeTarget;\n    this.isBindingVolatile = Observable.isVolatileBinding(this.binding);\n  }\n  /**\n   * Gets/sets the name of the attribute or property that this\n   * binding is targeting.\n   */\n\n\n  get targetName() {\n    return this.originalTargetName;\n  }\n\n  set targetName(value) {\n    this.originalTargetName = value;\n\n    if (value === void 0) {\n      return;\n    }\n\n    switch (value[0]) {\n      case \":\":\n        this.cleanedTargetName = value.substr(1);\n        this.updateTarget = updatePropertyTarget;\n\n        if (this.cleanedTargetName === \"innerHTML\") {\n          const binding = this.binding;\n\n          this.binding = (s, c) => DOM.createHTML(binding(s, c));\n        }\n\n        break;\n\n      case \"?\":\n        this.cleanedTargetName = value.substr(1);\n        this.updateTarget = updateBooleanAttributeTarget;\n        break;\n\n      case \"@\":\n        this.cleanedTargetName = value.substr(1);\n        this.bind = triggerBind;\n        this.unbind = triggerUnbind;\n        break;\n\n      default:\n        this.cleanedTargetName = value;\n\n        if (value === \"class\") {\n          this.updateTarget = updateClassTarget;\n        }\n\n        break;\n    }\n  }\n  /**\n   * Makes this binding target the content of an element rather than\n   * a particular attribute or property.\n   */\n\n\n  targetAtContent() {\n    this.updateTarget = updateContentTarget;\n    this.unbind = contentUnbind;\n  }\n  /**\n   * Creates the runtime BindingBehavior instance based on the configuration\n   * information stored in the BindingDirective.\n   * @param target - The target node that the binding behavior should attach to.\n   */\n\n\n  createBehavior(target) {\n    /* eslint-disable-next-line @typescript-eslint/no-use-before-define */\n    return new BindingBehavior(target, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);\n  }\n\n}\n/**\n * A behavior that updates content and attributes based on a configured\n * BindingDirective.\n * @public\n */\n\nexport class BindingBehavior {\n  /**\n   * Creates an instance of BindingBehavior.\n   * @param target - The target of the data updates.\n   * @param binding - The binding that returns the latest value for an update.\n   * @param isBindingVolatile - Indicates whether the binding has volatile dependencies.\n   * @param bind - The operation to perform during binding.\n   * @param unbind - The operation to perform during unbinding.\n   * @param updateTarget - The operation to perform when updating.\n   * @param targetName - The name of the target attribute or property to update.\n   */\n  constructor(target, binding, isBindingVolatile, bind, unbind, updateTarget, targetName) {\n    /** @internal */\n    this.source = null;\n    /** @internal */\n\n    this.context = null;\n    /** @internal */\n\n    this.bindingObserver = null;\n    this.target = target;\n    this.binding = binding;\n    this.isBindingVolatile = isBindingVolatile;\n    this.bind = bind;\n    this.unbind = unbind;\n    this.updateTarget = updateTarget;\n    this.targetName = targetName;\n  }\n  /** @internal */\n\n\n  handleChange() {\n    this.updateTarget(this.bindingObserver.observe(this.source, this.context));\n  }\n  /** @internal */\n\n\n  handleEvent(event) {\n    ExecutionContext.setEvent(event);\n    const result = this.binding(this.source, this.context);\n    ExecutionContext.setEvent(null);\n\n    if (result !== true) {\n      event.preventDefault();\n    }\n  }\n\n}","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-element/dist/esm/templating/binding.js"],"names":["DOM","ExecutionContext","Observable","TargetedHTMLDirective","normalBind","source","context","bindingObserver","binding","isBindingVolatile","updateTarget","observe","triggerBind","target","addEventListener","targetName","normalUnbind","disconnect","contentUnbind","view","$fastView","isComposed","unbind","needsBindOnly","triggerUnbind","removeEventListener","updateAttributeTarget","value","setAttribute","updateBooleanAttributeTarget","setBooleanAttribute","updateContentTarget","undefined","create","textContent","$fastTemplate","remove","bind","insertBefore","updatePropertyTarget","updateClassTarget","classVersions","Object","version","length","names","split","i","ii","currentName","classList","add","name","HTMLBindingDirective","constructor","isVolatileBinding","originalTargetName","cleanedTargetName","substr","s","c","createHTML","targetAtContent","createBehavior","BindingBehavior","handleChange","handleEvent","event","setEvent","result","preventDefault"],"mappings":"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","sourcesContent":["import { DOM } from \"../dom\";\nimport { ExecutionContext, Observable, } from \"../observation/observable\";\nimport { TargetedHTMLDirective } from \"./html-directive\";\nfunction normalBind(source, context) {\n    this.source = source;\n    this.context = context;\n    if (this.bindingObserver === null) {\n        this.bindingObserver = Observable.binding(this.binding, this, this.isBindingVolatile);\n    }\n    this.updateTarget(this.bindingObserver.observe(source, context));\n}\nfunction triggerBind(source, context) {\n    this.source = source;\n    this.context = context;\n    this.target.addEventListener(this.targetName, this);\n}\nfunction normalUnbind() {\n    this.bindingObserver.disconnect();\n    this.source = null;\n    this.context = null;\n}\nfunction contentUnbind() {\n    this.bindingObserver.disconnect();\n    this.source = null;\n    this.context = null;\n    const view = this.target.$fastView;\n    if (view !== void 0 && view.isComposed) {\n        view.unbind();\n        view.needsBindOnly = true;\n    }\n}\nfunction triggerUnbind() {\n    this.target.removeEventListener(this.targetName, this);\n    this.source = null;\n    this.context = null;\n}\nfunction updateAttributeTarget(value) {\n    DOM.setAttribute(this.target, this.targetName, value);\n}\nfunction updateBooleanAttributeTarget(value) {\n    DOM.setBooleanAttribute(this.target, this.targetName, value);\n}\nfunction updateContentTarget(value) {\n    // If there's no actual value, then this equates to the\n    // empty string for the purposes of content bindings.\n    if (value === null || value === undefined) {\n        value = \"\";\n    }\n    // If the value has a \"create\" method, then it's a template-like.\n    if (value.create) {\n        this.target.textContent = \"\";\n        let view = this.target.$fastView;\n        // If there's no previous view that we might be able to\n        // reuse then create a new view from the template.\n        if (view === void 0) {\n            view = value.create();\n        }\n        else {\n            // If there is a previous view, but it wasn't created\n            // from the same template as the new value, then we\n            // need to remove the old view if it's still in the DOM\n            // and create a new view from the template.\n            if (this.target.$fastTemplate !== value) {\n                if (view.isComposed) {\n                    view.remove();\n                    view.unbind();\n                }\n                view = value.create();\n            }\n        }\n        // It's possible that the value is the same as the previous template\n        // and that there's actually no need to compose it.\n        if (!view.isComposed) {\n            view.isComposed = true;\n            view.bind(this.source, this.context);\n            view.insertBefore(this.target);\n            this.target.$fastView = view;\n            this.target.$fastTemplate = value;\n        }\n        else if (view.needsBindOnly) {\n            view.needsBindOnly = false;\n            view.bind(this.source, this.context);\n        }\n    }\n    else {\n        const view = this.target.$fastView;\n        // If there is a view and it's currently composed into\n        // the DOM, then we need to remove it.\n        if (view !== void 0 && view.isComposed) {\n            view.isComposed = false;\n            view.remove();\n            if (view.needsBindOnly) {\n                view.needsBindOnly = false;\n            }\n            else {\n                view.unbind();\n            }\n        }\n        this.target.textContent = value;\n    }\n}\nfunction updatePropertyTarget(value) {\n    this.target[this.targetName] = value;\n}\nfunction updateClassTarget(value) {\n    const classVersions = this.classVersions || Object.create(null);\n    const target = this.target;\n    let version = this.version || 0;\n    // Add the classes, tracking the version at which they were added.\n    if (value !== null && value !== undefined && value.length) {\n        const names = value.split(/\\s+/);\n        for (let i = 0, ii = names.length; i < ii; ++i) {\n            const currentName = names[i];\n            if (currentName === \"\") {\n                continue;\n            }\n            classVersions[currentName] = version;\n            target.classList.add(currentName);\n        }\n    }\n    this.classVersions = classVersions;\n    this.version = version + 1;\n    // If this is the first call to add classes, there's no need to remove old ones.\n    if (version === 0) {\n        return;\n    }\n    // Remove classes from the previous version.\n    version -= 1;\n    for (const name in classVersions) {\n        if (classVersions[name] === version) {\n            target.classList.remove(name);\n        }\n    }\n}\n/**\n * A directive that configures data binding to element content and attributes.\n * @public\n */\nexport class HTMLBindingDirective extends TargetedHTMLDirective {\n    /**\n     * Creates an instance of BindingDirective.\n     * @param binding - A binding that returns the data used to update the DOM.\n     */\n    constructor(binding) {\n        super();\n        this.binding = binding;\n        this.bind = normalBind;\n        this.unbind = normalUnbind;\n        this.updateTarget = updateAttributeTarget;\n        this.isBindingVolatile = Observable.isVolatileBinding(this.binding);\n    }\n    /**\n     * Gets/sets the name of the attribute or property that this\n     * binding is targeting.\n     */\n    get targetName() {\n        return this.originalTargetName;\n    }\n    set targetName(value) {\n        this.originalTargetName = value;\n        if (value === void 0) {\n            return;\n        }\n        switch (value[0]) {\n            case \":\":\n                this.cleanedTargetName = value.substr(1);\n                this.updateTarget = updatePropertyTarget;\n                if (this.cleanedTargetName === \"innerHTML\") {\n                    const binding = this.binding;\n                    this.binding = (s, c) => DOM.createHTML(binding(s, c));\n                }\n                break;\n            case \"?\":\n                this.cleanedTargetName = value.substr(1);\n                this.updateTarget = updateBooleanAttributeTarget;\n                break;\n            case \"@\":\n                this.cleanedTargetName = value.substr(1);\n                this.bind = triggerBind;\n                this.unbind = triggerUnbind;\n                break;\n            default:\n                this.cleanedTargetName = value;\n                if (value === \"class\") {\n                    this.updateTarget = updateClassTarget;\n                }\n                break;\n        }\n    }\n    /**\n     * Makes this binding target the content of an element rather than\n     * a particular attribute or property.\n     */\n    targetAtContent() {\n        this.updateTarget = updateContentTarget;\n        this.unbind = contentUnbind;\n    }\n    /**\n     * Creates the runtime BindingBehavior instance based on the configuration\n     * information stored in the BindingDirective.\n     * @param target - The target node that the binding behavior should attach to.\n     */\n    createBehavior(target) {\n        /* eslint-disable-next-line @typescript-eslint/no-use-before-define */\n        return new BindingBehavior(target, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);\n    }\n}\n/**\n * A behavior that updates content and attributes based on a configured\n * BindingDirective.\n * @public\n */\nexport class BindingBehavior {\n    /**\n     * Creates an instance of BindingBehavior.\n     * @param target - The target of the data updates.\n     * @param binding - The binding that returns the latest value for an update.\n     * @param isBindingVolatile - Indicates whether the binding has volatile dependencies.\n     * @param bind - The operation to perform during binding.\n     * @param unbind - The operation to perform during unbinding.\n     * @param updateTarget - The operation to perform when updating.\n     * @param targetName - The name of the target attribute or property to update.\n     */\n    constructor(target, binding, isBindingVolatile, bind, unbind, updateTarget, targetName) {\n        /** @internal */\n        this.source = null;\n        /** @internal */\n        this.context = null;\n        /** @internal */\n        this.bindingObserver = null;\n        this.target = target;\n        this.binding = binding;\n        this.isBindingVolatile = isBindingVolatile;\n        this.bind = bind;\n        this.unbind = unbind;\n        this.updateTarget = updateTarget;\n        this.targetName = targetName;\n    }\n    /** @internal */\n    handleChange() {\n        this.updateTarget(this.bindingObserver.observe(this.source, this.context));\n    }\n    /** @internal */\n    handleEvent(event) {\n        ExecutionContext.setEvent(event);\n        const result = this.binding(this.source, this.context);\n        ExecutionContext.setEvent(null);\n        if (result !== true) {\n            event.preventDefault();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}