{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { Direction, eventResize, eventScroll } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element\";\nimport { getDirection } from \"../utilities/direction\";\nimport { IntersectionService } from \"../utilities/intersection-service\";\n/**\n * An anchored region Custom HTML Element.\n *\n * @public\n */\n\nexport class AnchoredRegion extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * The HTML ID of the anchor element this region is positioned relative to\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: anchor\n     */\n\n    this.anchor = \"\";\n    /**\n     * The HTML ID of the viewport element this region is positioned relative to\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: anchor\n     */\n\n    this.viewport = \"\";\n    /**\n     * Sets what logic the component uses to determine horizontal placement.\n     * 'locktodefault' forces the default position\n     * 'dynamic' decides placement based on available space\n     * 'uncontrolled' does not control placement on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-positioning-mode\n     */\n\n    this.horizontalPositioningMode = \"uncontrolled\";\n    /**\n     * The default horizontal position of the region relative to the anchor element\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-default-position\n     */\n\n    this.horizontalDefaultPosition = \"unset\";\n    /**\n     * Whether the region remains in the viewport (ie. detaches from the anchor) on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-viewport-lock\n     */\n\n    this.horizontalViewportLock = false;\n    /**\n     * Whether the region overlaps the anchor on the horizontal axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-inset\n     */\n\n    this.horizontalInset = false;\n    /**\n     * Defines how the width of the region is calculated\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: horizontal-scaling\n     */\n\n    this.horizontalScaling = \"content\";\n    /**\n     * Sets what logic the component uses to determine vertical placement.\n     * 'locktodefault' forces the default position\n     * 'dynamic' decides placement based on available space\n     * 'uncontrolled' does not control placement on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-positioning-mode\n     */\n\n    this.verticalPositioningMode = \"uncontrolled\";\n    /**\n     * The default vertical position of the region relative to the anchor element\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-default-position\n     */\n\n    this.verticalDefaultPosition = \"unset\";\n    /**\n     * Whether the region remains in the viewport (ie. detaches from the anchor) on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-viewport-lock\n     */\n\n    this.verticalViewportLock = false;\n    /**\n     * Whether the region overlaps the anchor on the vertical axis\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-inset\n     */\n\n    this.verticalInset = false;\n    /**\n     * Defines how the height of the region is calculated\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: vertical-scaling\n     */\n\n    this.verticalScaling = \"content\";\n    /**\n     * Whether the region is positioned using css \"position: fixed\".\n     * Otherwise the region uses \"position: absolute\".\n     * Fixed placement allows the region to break out of parent containers,\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: fixed-placement\n     */\n\n    this.fixedPlacement = false;\n    /**\n     * Defines what triggers the anchored region to revaluate positioning\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: auto-update-mode\n     */\n\n    this.autoUpdateMode = \"anchor\";\n    /**\n     * The HTML element being used as the anchor\n     *\n     * @public\n     */\n\n    this.anchorElement = null;\n    /**\n     * The HTML element being used as the viewport\n     *\n     * @public\n     */\n\n    this.viewportElement = null;\n    /**\n     * indicates that an initial positioning pass on layout has completed\n     *\n     * @internal\n     */\n\n    this.initialLayoutComplete = false;\n    this.resizeDetector = null;\n    /**\n     * base offsets between the positioner's base position and the anchor's\n     */\n\n    this.baseHorizontalOffset = 0;\n    this.baseVerticalOffset = 0;\n    this.pendingPositioningUpdate = false;\n    this.pendingReset = false;\n    this.currentDirection = Direction.ltr;\n    this.regionVisible = false; // indicates that a layout update should occur even if geometry has not changed\n    // used to ensure some attribute changes are applied\n\n    this.forceUpdate = false; // defines how big a difference in pixels there must be between states to\n    // justify a layout update that affects the dom (prevents repeated sub-pixel corrections)\n\n    this.updateThreshold = 0.5;\n    /**\n     * update position\n     */\n\n    this.update = () => {\n      if (!this.pendingPositioningUpdate) {\n        this.requestPositionUpdates();\n      }\n    };\n    /**\n     * starts observers\n     */\n\n\n    this.startObservers = () => {\n      this.stopObservers();\n\n      if (this.anchorElement === null) {\n        return;\n      }\n\n      this.requestPositionUpdates();\n\n      if (this.resizeDetector !== null) {\n        this.resizeDetector.observe(this.anchorElement);\n        this.resizeDetector.observe(this);\n      }\n    };\n    /**\n     * get position updates\n     */\n\n\n    this.requestPositionUpdates = () => {\n      if (this.anchorElement === null || this.pendingPositioningUpdate) {\n        return;\n      }\n\n      AnchoredRegion.intersectionService.requestPosition(this, this.handleIntersection);\n      AnchoredRegion.intersectionService.requestPosition(this.anchorElement, this.handleIntersection);\n\n      if (this.viewportElement !== null) {\n        AnchoredRegion.intersectionService.requestPosition(this.viewportElement, this.handleIntersection);\n      }\n\n      this.pendingPositioningUpdate = true;\n    };\n    /**\n     * stops observers\n     */\n\n\n    this.stopObservers = () => {\n      if (this.pendingPositioningUpdate) {\n        this.pendingPositioningUpdate = false;\n        AnchoredRegion.intersectionService.cancelRequestPosition(this, this.handleIntersection);\n\n        if (this.anchorElement !== null) {\n          AnchoredRegion.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection);\n        }\n\n        if (this.viewportElement !== null) {\n          AnchoredRegion.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection);\n        }\n      }\n\n      if (this.resizeDetector !== null) {\n        this.resizeDetector.disconnect();\n      }\n    };\n    /**\n     * Gets the viewport element by id, or defaults to document root\n     */\n\n\n    this.getViewport = () => {\n      if (typeof this.viewport !== \"string\" || this.viewport === \"\") {\n        return document.documentElement;\n      }\n\n      return document.getElementById(this.viewport);\n    };\n    /**\n     *  Gets the anchor element by id\n     */\n\n\n    this.getAnchor = () => {\n      return document.getElementById(this.anchor);\n    };\n    /**\n     *  Handle intersections\n     */\n\n\n    this.handleIntersection = entries => {\n      if (!this.pendingPositioningUpdate) {\n        return;\n      }\n\n      this.pendingPositioningUpdate = false;\n\n      if (!this.applyIntersectionEntries(entries)) {\n        return;\n      }\n\n      this.updateLayout();\n    };\n    /**\n     *  iterate through intersection entries and apply data\n     */\n\n\n    this.applyIntersectionEntries = entries => {\n      const regionEntry = entries.find(x => x.target === this);\n      const anchorEntry = entries.find(x => x.target === this.anchorElement);\n      const viewportEntry = entries.find(x => x.target === this.viewportElement);\n\n      if (regionEntry === undefined || viewportEntry === undefined || anchorEntry === undefined) {\n        return false;\n      } // don't update the dom unless there is a significant difference in rect positions\n\n\n      if (!this.regionVisible || this.forceUpdate || this.regionRect === undefined || this.anchorRect === undefined || this.viewportRect === undefined || this.isRectDifferent(this.anchorRect, anchorEntry.boundingClientRect) || this.isRectDifferent(this.viewportRect, viewportEntry.boundingClientRect) || this.isRectDifferent(this.regionRect, regionEntry.boundingClientRect)) {\n        this.regionRect = regionEntry.boundingClientRect;\n        this.anchorRect = anchorEntry.boundingClientRect;\n\n        if (this.viewportElement === document.documentElement) {\n          this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x + document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y + document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);\n        } else {\n          this.viewportRect = viewportEntry.boundingClientRect;\n        }\n\n        this.updateRegionOffset();\n        this.forceUpdate = false;\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     *  Update the offset values\n     */\n\n\n    this.updateRegionOffset = () => {\n      if (this.anchorRect && this.regionRect) {\n        this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorRect.left - this.regionRect.left) + (this.translateX - this.baseHorizontalOffset);\n        this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorRect.top - this.regionRect.top) + (this.translateY - this.baseVerticalOffset);\n      }\n    };\n    /**\n     *  compare rects to see if there is enough change to justify a DOM update\n     */\n\n\n    this.isRectDifferent = (rectA, rectB) => {\n      if (Math.abs(rectA.top - rectB.top) > this.updateThreshold || Math.abs(rectA.right - rectB.right) > this.updateThreshold || Math.abs(rectA.bottom - rectB.bottom) > this.updateThreshold || Math.abs(rectA.left - rectB.left) > this.updateThreshold) {\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     *  Handle resize events\n     */\n\n\n    this.handleResize = entries => {\n      this.update();\n    };\n    /**\n     * resets the component\n     */\n\n\n    this.reset = () => {\n      if (!this.pendingReset) {\n        return;\n      }\n\n      this.pendingReset = false;\n\n      if (this.anchorElement === null) {\n        this.anchorElement = this.getAnchor();\n      }\n\n      if (this.viewportElement === null) {\n        this.viewportElement = this.getViewport();\n      }\n\n      this.currentDirection = getDirection(this);\n      this.startObservers();\n    };\n    /**\n     *  Recalculate layout related state values\n     */\n\n\n    this.updateLayout = () => {\n      let desiredVerticalPosition = undefined;\n      let desiredHorizontalPosition = undefined;\n\n      if (this.horizontalPositioningMode !== \"uncontrolled\") {\n        const horizontalOptions = this.getPositioningOptions(this.horizontalInset);\n\n        if (this.horizontalDefaultPosition === \"center\") {\n          desiredHorizontalPosition = \"center\";\n        } else if (this.horizontalDefaultPosition !== \"unset\") {\n          let dirCorrectedHorizontalDefaultPosition = this.horizontalDefaultPosition;\n\n          if (dirCorrectedHorizontalDefaultPosition === \"start\" || dirCorrectedHorizontalDefaultPosition === \"end\") {\n            // if direction changes we reset the layout\n            const newDirection = getDirection(this);\n\n            if (newDirection !== this.currentDirection) {\n              this.currentDirection = newDirection;\n              this.initialize();\n              return;\n            }\n\n            if (this.currentDirection === Direction.ltr) {\n              dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === \"start\" ? \"left\" : \"right\";\n            } else {\n              dirCorrectedHorizontalDefaultPosition = dirCorrectedHorizontalDefaultPosition === \"start\" ? \"right\" : \"left\";\n            }\n          }\n\n          switch (dirCorrectedHorizontalDefaultPosition) {\n            case \"left\":\n              desiredHorizontalPosition = this.horizontalInset ? \"insetStart\" : \"start\";\n              break;\n\n            case \"right\":\n              desiredHorizontalPosition = this.horizontalInset ? \"insetEnd\" : \"end\";\n              break;\n          }\n        }\n\n        const horizontalThreshold = this.horizontalThreshold !== undefined ? this.horizontalThreshold : this.regionRect !== undefined ? this.regionRect.width : 0;\n        const anchorLeft = this.anchorRect !== undefined ? this.anchorRect.left : 0;\n        const anchorRight = this.anchorRect !== undefined ? this.anchorRect.right : 0;\n        const anchorWidth = this.anchorRect !== undefined ? this.anchorRect.width : 0;\n        const viewportLeft = this.viewportRect !== undefined ? this.viewportRect.left : 0;\n        const viewportRight = this.viewportRect !== undefined ? this.viewportRect.right : 0;\n\n        if (desiredHorizontalPosition === undefined || !(this.horizontalPositioningMode === \"locktodefault\") && this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold) {\n          desiredHorizontalPosition = this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) > this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) ? horizontalOptions[0] : horizontalOptions[1];\n        }\n      }\n\n      if (this.verticalPositioningMode !== \"uncontrolled\") {\n        const verticalOptions = this.getPositioningOptions(this.verticalInset);\n\n        if (this.verticalDefaultPosition === \"center\") {\n          desiredVerticalPosition = \"center\";\n        } else if (this.verticalDefaultPosition !== \"unset\") {\n          switch (this.verticalDefaultPosition) {\n            case \"top\":\n              desiredVerticalPosition = this.verticalInset ? \"insetStart\" : \"start\";\n              break;\n\n            case \"bottom\":\n              desiredVerticalPosition = this.verticalInset ? \"insetEnd\" : \"end\";\n              break;\n          }\n        }\n\n        const verticalThreshold = this.verticalThreshold !== undefined ? this.verticalThreshold : this.regionRect !== undefined ? this.regionRect.height : 0;\n        const anchorTop = this.anchorRect !== undefined ? this.anchorRect.top : 0;\n        const anchorBottom = this.anchorRect !== undefined ? this.anchorRect.bottom : 0;\n        const anchorHeight = this.anchorRect !== undefined ? this.anchorRect.height : 0;\n        const viewportTop = this.viewportRect !== undefined ? this.viewportRect.top : 0;\n        const viewportBottom = this.viewportRect !== undefined ? this.viewportRect.bottom : 0;\n\n        if (desiredVerticalPosition === undefined || !(this.verticalPositioningMode === \"locktodefault\") && this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold) {\n          desiredVerticalPosition = this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) > this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) ? verticalOptions[0] : verticalOptions[1];\n        }\n      }\n\n      const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);\n      const positionChanged = this.horizontalPosition !== desiredHorizontalPosition || this.verticalPosition !== desiredVerticalPosition;\n      this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);\n      this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);\n      this.updateRegionStyle();\n\n      if (!this.initialLayoutComplete) {\n        this.initialLayoutComplete = true;\n        this.requestPositionUpdates();\n        return;\n      }\n\n      if (!this.regionVisible) {\n        this.regionVisible = true;\n        this.style.removeProperty(\"pointer-events\");\n        this.style.removeProperty(\"opacity\");\n        this.classList.toggle(\"loaded\", true);\n        this.$emit(\"loaded\", this, {\n          bubbles: false\n        });\n      }\n\n      this.updatePositionClasses();\n\n      if (positionChanged) {\n        // emit change event\n        this.$emit(\"positionchange\", this, {\n          bubbles: false\n        });\n      }\n    };\n    /**\n     *  Updates the style string applied to the region element as well as the css classes attached\n     *  to the root element\n     */\n\n\n    this.updateRegionStyle = () => {\n      this.style.width = this.regionWidth;\n      this.style.height = this.regionHeight;\n      this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;\n    };\n    /**\n     *  Updates the css classes that reflect the current position of the element\n     */\n\n\n    this.updatePositionClasses = () => {\n      this.classList.toggle(\"top\", this.verticalPosition === \"start\");\n      this.classList.toggle(\"bottom\", this.verticalPosition === \"end\");\n      this.classList.toggle(\"inset-top\", this.verticalPosition === \"insetStart\");\n      this.classList.toggle(\"inset-bottom\", this.verticalPosition === \"insetEnd\");\n      this.classList.toggle(\"vertical-center\", this.verticalPosition === \"center\");\n      this.classList.toggle(\"left\", this.horizontalPosition === \"start\");\n      this.classList.toggle(\"right\", this.horizontalPosition === \"end\");\n      this.classList.toggle(\"inset-left\", this.horizontalPosition === \"insetStart\");\n      this.classList.toggle(\"inset-right\", this.horizontalPosition === \"insetEnd\");\n      this.classList.toggle(\"horizontal-center\", this.horizontalPosition === \"center\");\n    };\n    /**\n     * Get horizontal positioning state based on desired position\n     */\n\n\n    this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {\n      if (desiredHorizontalPosition === undefined || this.regionRect === undefined || this.anchorRect === undefined || this.viewportRect === undefined) {\n        return;\n      }\n\n      let nextRegionWidth = 0;\n\n      switch (this.horizontalScaling) {\n        case \"anchor\":\n        case \"fill\":\n          nextRegionWidth = nextPositionerDimension.width;\n          this.regionWidth = `${nextRegionWidth}px`;\n          break;\n\n        case \"content\":\n          nextRegionWidth = this.regionRect.width;\n          this.regionWidth = \"unset\";\n          break;\n      }\n\n      let sizeDelta = 0;\n\n      switch (desiredHorizontalPosition) {\n        case \"start\":\n          this.translateX = this.baseHorizontalOffset - nextRegionWidth;\n\n          if (this.horizontalViewportLock && this.anchorRect.left > this.viewportRect.right) {\n            this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.right);\n          }\n\n          break;\n\n        case \"insetStart\":\n          this.translateX = this.baseHorizontalOffset - nextRegionWidth + this.anchorRect.width;\n\n          if (this.horizontalViewportLock && this.anchorRect.right > this.viewportRect.right) {\n            this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.right);\n          }\n\n          break;\n\n        case \"insetEnd\":\n          this.translateX = this.baseHorizontalOffset;\n\n          if (this.horizontalViewportLock && this.anchorRect.left < this.viewportRect.left) {\n            this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.left);\n          }\n\n          break;\n\n        case \"end\":\n          this.translateX = this.baseHorizontalOffset + this.anchorRect.width;\n\n          if (this.horizontalViewportLock && this.anchorRect.right < this.viewportRect.left) {\n            this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.left);\n          }\n\n          break;\n\n        case \"center\":\n          sizeDelta = (this.anchorRect.width - nextRegionWidth) / 2;\n          this.translateX = this.baseHorizontalOffset + sizeDelta;\n\n          if (this.horizontalViewportLock) {\n            const regionLeft = this.anchorRect.left + sizeDelta;\n            const regionRight = this.anchorRect.right - sizeDelta;\n\n            if (regionLeft < this.viewportRect.left && !(regionRight > this.viewportRect.right)) {\n              this.translateX = this.translateX - (regionLeft - this.viewportRect.left);\n            } else if (regionRight > this.viewportRect.right && !(regionLeft < this.viewportRect.left)) {\n              this.translateX = this.translateX - (regionRight - this.viewportRect.right);\n            }\n          }\n\n          break;\n      }\n\n      this.horizontalPosition = desiredHorizontalPosition;\n    };\n    /**\n     * Set vertical positioning state based on desired position\n     */\n\n\n    this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {\n      if (desiredVerticalPosition === undefined || this.regionRect === undefined || this.anchorRect === undefined || this.viewportRect === undefined) {\n        return;\n      }\n\n      let nextRegionHeight = 0;\n\n      switch (this.verticalScaling) {\n        case \"anchor\":\n        case \"fill\":\n          nextRegionHeight = nextPositionerDimension.height;\n          this.regionHeight = `${nextRegionHeight}px`;\n          break;\n\n        case \"content\":\n          nextRegionHeight = this.regionRect.height;\n          this.regionHeight = \"unset\";\n          break;\n      }\n\n      let sizeDelta = 0;\n\n      switch (desiredVerticalPosition) {\n        case \"start\":\n          this.translateY = this.baseVerticalOffset - nextRegionHeight;\n\n          if (this.verticalViewportLock && this.anchorRect.top > this.viewportRect.bottom) {\n            this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.bottom);\n          }\n\n          break;\n\n        case \"insetStart\":\n          this.translateY = this.baseVerticalOffset - nextRegionHeight + this.anchorRect.height;\n\n          if (this.verticalViewportLock && this.anchorRect.bottom > this.viewportRect.bottom) {\n            this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.bottom);\n          }\n\n          break;\n\n        case \"insetEnd\":\n          this.translateY = this.baseVerticalOffset;\n\n          if (this.verticalViewportLock && this.anchorRect.top < this.viewportRect.top) {\n            this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.top);\n          }\n\n          break;\n\n        case \"end\":\n          this.translateY = this.baseVerticalOffset + this.anchorRect.height;\n\n          if (this.verticalViewportLock && this.anchorRect.bottom < this.viewportRect.top) {\n            this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.top);\n          }\n\n          break;\n\n        case \"center\":\n          sizeDelta = (this.anchorRect.height - nextRegionHeight) / 2;\n          this.translateY = this.baseVerticalOffset + sizeDelta;\n\n          if (this.verticalViewportLock) {\n            const regionTop = this.anchorRect.top + sizeDelta;\n            const regionBottom = this.anchorRect.bottom - sizeDelta;\n\n            if (regionTop < this.viewportRect.top && !(regionBottom > this.viewportRect.bottom)) {\n              this.translateY = this.translateY - (regionTop - this.viewportRect.top);\n            } else if (regionBottom > this.viewportRect.bottom && !(regionTop < this.viewportRect.top)) {\n              this.translateY = this.translateY - (regionBottom - this.viewportRect.bottom);\n            }\n          }\n\n      }\n\n      this.verticalPosition = desiredVerticalPosition;\n    };\n    /**\n     *  Get available positions based on positioning mode\n     */\n\n\n    this.getPositioningOptions = inset => {\n      if (inset) {\n        return [\"insetStart\", \"insetEnd\"];\n      }\n\n      return [\"start\", \"end\"];\n    };\n    /**\n     *  Get the space available for a particular relative position\n     */\n\n\n    this.getAvailableSpace = (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) => {\n      const spaceStart = anchorStart - viewportStart;\n      const spaceEnd = viewportEnd - (anchorStart + anchorSpan);\n\n      switch (positionOption) {\n        case \"start\":\n          return spaceStart;\n\n        case \"insetStart\":\n          return spaceStart + anchorSpan;\n\n        case \"insetEnd\":\n          return spaceEnd + anchorSpan;\n\n        case \"end\":\n          return spaceEnd;\n\n        case \"center\":\n          return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;\n      }\n    };\n    /**\n     * Get region dimensions\n     */\n\n\n    this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {\n      const newRegionDimension = {\n        height: this.regionRect !== undefined ? this.regionRect.height : 0,\n        width: this.regionRect !== undefined ? this.regionRect.width : 0\n      };\n\n      if (desiredHorizontalPosition !== undefined && this.horizontalScaling === \"fill\") {\n        newRegionDimension.width = this.getAvailableSpace(desiredHorizontalPosition, this.anchorRect !== undefined ? this.anchorRect.left : 0, this.anchorRect !== undefined ? this.anchorRect.right : 0, this.anchorRect !== undefined ? this.anchorRect.width : 0, this.viewportRect !== undefined ? this.viewportRect.left : 0, this.viewportRect !== undefined ? this.viewportRect.right : 0);\n      } else if (this.horizontalScaling === \"anchor\") {\n        newRegionDimension.width = this.anchorRect !== undefined ? this.anchorRect.width : 0;\n      }\n\n      if (desiredVerticalPosition !== undefined && this.verticalScaling === \"fill\") {\n        newRegionDimension.height = this.getAvailableSpace(desiredVerticalPosition, this.anchorRect !== undefined ? this.anchorRect.top : 0, this.anchorRect !== undefined ? this.anchorRect.bottom : 0, this.anchorRect !== undefined ? this.anchorRect.height : 0, this.viewportRect !== undefined ? this.viewportRect.top : 0, this.viewportRect !== undefined ? this.viewportRect.bottom : 0);\n      } else if (this.verticalScaling === \"anchor\") {\n        newRegionDimension.height = this.anchorRect !== undefined ? this.anchorRect.height : 0;\n      }\n\n      return newRegionDimension;\n    };\n    /**\n     * starts event listeners that can trigger auto updating\n     */\n\n\n    this.startAutoUpdateEventListeners = () => {\n      window.addEventListener(eventResize, this.update, {\n        passive: true\n      });\n      window.addEventListener(eventScroll, this.update, {\n        passive: true,\n        capture: true\n      });\n\n      if (this.resizeDetector !== null && this.viewportElement !== null) {\n        this.resizeDetector.observe(this.viewportElement);\n      }\n    };\n    /**\n     * stops event listeners that can trigger auto updating\n     */\n\n\n    this.stopAutoUpdateEventListeners = () => {\n      window.removeEventListener(eventResize, this.update);\n      window.removeEventListener(eventScroll, this.update);\n\n      if (this.resizeDetector !== null && this.viewportElement !== null) {\n        this.resizeDetector.unobserve(this.viewportElement);\n      }\n    };\n  }\n\n  anchorChanged() {\n    if (this.initialLayoutComplete) {\n      this.anchorElement = this.getAnchor();\n    }\n  }\n\n  viewportChanged() {\n    if (this.initialLayoutComplete) {\n      this.viewportElement = this.getViewport();\n    }\n  }\n\n  horizontalPositioningModeChanged() {\n    this.requestReset();\n  }\n\n  horizontalDefaultPositionChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalViewportLockChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalInsetChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalThresholdChanged() {\n    this.updateForAttributeChange();\n  }\n\n  horizontalScalingChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalPositioningModeChanged() {\n    this.requestReset();\n  }\n\n  verticalDefaultPositionChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalViewportLockChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalInsetChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalThresholdChanged() {\n    this.updateForAttributeChange();\n  }\n\n  verticalScalingChanged() {\n    this.updateForAttributeChange();\n  }\n\n  fixedPlacementChanged() {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      this.initialize();\n    }\n  }\n\n  autoUpdateModeChanged(prevMode, newMode) {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      if (prevMode === \"auto\") {\n        this.stopAutoUpdateEventListeners();\n      }\n\n      if (newMode === \"auto\") {\n        this.startAutoUpdateEventListeners();\n      }\n    }\n  }\n\n  anchorElementChanged() {\n    this.requestReset();\n  }\n\n  viewportElementChanged() {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      this.initialize();\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (this.autoUpdateMode === \"auto\") {\n      this.startAutoUpdateEventListeners();\n    }\n\n    this.initialize();\n  }\n  /**\n   * @internal\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    if (this.autoUpdateMode === \"auto\") {\n      this.stopAutoUpdateEventListeners();\n    }\n\n    this.stopObservers();\n    this.disconnectResizeDetector();\n  }\n  /**\n   * @internal\n   */\n\n\n  adoptedCallback() {\n    this.initialize();\n  }\n  /**\n   * destroys the instance's resize observer\n   */\n\n\n  disconnectResizeDetector() {\n    if (this.resizeDetector !== null) {\n      this.resizeDetector.disconnect();\n      this.resizeDetector = null;\n    }\n  }\n  /**\n   * initializes the instance's resize observer\n   */\n\n\n  initializeResizeDetector() {\n    this.disconnectResizeDetector();\n    this.resizeDetector = new window.ResizeObserver(this.handleResize);\n  }\n  /**\n   * react to attribute changes that don't require a reset\n   */\n\n\n  updateForAttributeChange() {\n    if (this.$fastController.isConnected && this.initialLayoutComplete) {\n      this.forceUpdate = true;\n      this.update();\n    }\n  }\n  /**\n   * fully initializes the component\n   */\n\n\n  initialize() {\n    this.initializeResizeDetector();\n\n    if (this.anchorElement === null) {\n      this.anchorElement = this.getAnchor();\n    }\n\n    this.requestReset();\n  }\n  /**\n   * Request a reset if there are currently no open requests\n   */\n\n\n  requestReset() {\n    if (this.$fastController.isConnected && this.pendingReset === false) {\n      this.setInitialState();\n      DOM.queueUpdate(() => this.reset());\n      this.pendingReset = true;\n    }\n  }\n  /**\n   * sets the starting configuration for component internal values\n   */\n\n\n  setInitialState() {\n    this.initialLayoutComplete = false;\n    this.regionVisible = false;\n    this.translateX = 0;\n    this.translateY = 0;\n    this.baseHorizontalOffset = 0;\n    this.baseVerticalOffset = 0;\n    this.viewportRect = undefined;\n    this.regionRect = undefined;\n    this.anchorRect = undefined;\n    this.verticalPosition = undefined;\n    this.horizontalPosition = undefined;\n    this.style.opacity = \"0\";\n    this.style.pointerEvents = \"none\";\n    this.forceUpdate = false;\n    this.style.position = this.fixedPlacement ? \"fixed\" : \"absolute\";\n    this.updatePositionClasses();\n    this.updateRegionStyle();\n  }\n\n}\nAnchoredRegion.intersectionService = new IntersectionService();\n\n__decorate([attr], AnchoredRegion.prototype, \"anchor\", void 0);\n\n__decorate([attr], AnchoredRegion.prototype, \"viewport\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-positioning-mode\"\n})], AnchoredRegion.prototype, \"horizontalPositioningMode\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-default-position\"\n})], AnchoredRegion.prototype, \"horizontalDefaultPosition\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-viewport-lock\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"horizontalViewportLock\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-inset\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"horizontalInset\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-threshold\"\n})], AnchoredRegion.prototype, \"horizontalThreshold\", void 0);\n\n__decorate([attr({\n  attribute: \"horizontal-scaling\"\n})], AnchoredRegion.prototype, \"horizontalScaling\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-positioning-mode\"\n})], AnchoredRegion.prototype, \"verticalPositioningMode\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-default-position\"\n})], AnchoredRegion.prototype, \"verticalDefaultPosition\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-viewport-lock\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"verticalViewportLock\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-inset\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"verticalInset\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-threshold\"\n})], AnchoredRegion.prototype, \"verticalThreshold\", void 0);\n\n__decorate([attr({\n  attribute: \"vertical-scaling\"\n})], AnchoredRegion.prototype, \"verticalScaling\", void 0);\n\n__decorate([attr({\n  attribute: \"fixed-placement\",\n  mode: \"boolean\"\n})], AnchoredRegion.prototype, \"fixedPlacement\", void 0);\n\n__decorate([attr({\n  attribute: \"auto-update-mode\"\n})], AnchoredRegion.prototype, \"autoUpdateMode\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"anchorElement\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"viewportElement\", void 0);\n\n__decorate([observable], AnchoredRegion.prototype, \"initialLayoutComplete\", void 0);","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/anchored-region/anchored-region.js"],"names":["__decorate","attr","DOM","observable","Direction","eventResize","eventScroll","FoundationElement","getDirection","IntersectionService","AnchoredRegion","constructor","arguments","anchor","viewport","horizontalPositioningMode","horizontalDefaultPosition","horizontalViewportLock","horizontalInset","horizontalScaling","verticalPositioningMode","verticalDefaultPosition","verticalViewportLock","verticalInset","verticalScaling","fixedPlacement","autoUpdateMode","anchorElement","viewportElement","initialLayoutComplete","resizeDetector","baseHorizontalOffset","baseVerticalOffset","pendingPositioningUpdate","pendingReset","currentDirection","ltr","regionVisible","forceUpdate","updateThreshold","update","requestPositionUpdates","startObservers","stopObservers","observe","intersectionService","requestPosition","handleIntersection","cancelRequestPosition","disconnect","getViewport","document","documentElement","getElementById","getAnchor","entries","applyIntersectionEntries","updateLayout","regionEntry","find","x","target","anchorEntry","viewportEntry","undefined","regionRect","anchorRect","viewportRect","isRectDifferent","boundingClientRect","DOMRectReadOnly","scrollLeft","y","scrollTop","width","height","updateRegionOffset","left","translateX","top","translateY","rectA","rectB","Math","abs","right","bottom","handleResize","reset","desiredVerticalPosition","desiredHorizontalPosition","horizontalOptions","getPositioningOptions","dirCorrectedHorizontalDefaultPosition","newDirection","initialize","horizontalThreshold","anchorLeft","anchorRight","anchorWidth","viewportLeft","viewportRight","getAvailableSpace","verticalOptions","verticalThreshold","anchorTop","anchorBottom","anchorHeight","viewportTop","viewportBottom","nextPositionerDimension","getNextRegionDimension","positionChanged","horizontalPosition","verticalPosition","setHorizontalPosition","setVerticalPosition","updateRegionStyle","style","removeProperty","classList","toggle","$emit","bubbles","updatePositionClasses","regionWidth","regionHeight","transform","nextRegionWidth","sizeDelta","regionLeft","regionRight","nextRegionHeight","regionTop","regionBottom","inset","positionOption","anchorStart","anchorEnd","anchorSpan","viewportStart","viewportEnd","spaceStart","spaceEnd","min","newRegionDimension","startAutoUpdateEventListeners","window","addEventListener","passive","capture","stopAutoUpdateEventListeners","removeEventListener","unobserve","anchorChanged","viewportChanged","horizontalPositioningModeChanged","requestReset","horizontalDefaultPositionChanged","updateForAttributeChange","horizontalViewportLockChanged","horizontalInsetChanged","horizontalThresholdChanged","horizontalScalingChanged","verticalPositioningModeChanged","verticalDefaultPositionChanged","verticalViewportLockChanged","verticalInsetChanged","verticalThresholdChanged","verticalScalingChanged","fixedPlacementChanged","$fastController","isConnected","autoUpdateModeChanged","prevMode","newMode","anchorElementChanged","viewportElementChanged","connectedCallback","disconnectedCallback","disconnectResizeDetector","adoptedCallback","initializeResizeDetector","ResizeObserver","setInitialState","queueUpdate","opacity","pointerEvents","position","prototype","attribute","mode"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,IAAT,EAAeC,GAAf,EAAoBC,UAApB,QAAsC,yBAAtC;AACA,SAASC,SAAT,EAAoBC,WAApB,EAAiCC,WAAjC,QAAoD,+BAApD;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA,SAASC,YAAT,QAA6B,wBAA7B;AACA,SAASC,mBAAT,QAAoC,mCAApC;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,cAAN,SAA6BH,iBAA7B,CAA+C;AAClDI,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGC,SAAT;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,MAAL,GAAc,EAAd;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,QAAL,GAAgB,EAAhB;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,yBAAL,GAAiC,cAAjC;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,yBAAL,GAAiC,OAAjC;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,sBAAL,GAA8B,KAA9B;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,KAAvB;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,iBAAL,GAAyB,SAAzB;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,uBAAL,GAA+B,cAA/B;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,uBAAL,GAA+B,OAA/B;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,oBAAL,GAA4B,KAA5B;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,aAAL,GAAqB,KAArB;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,SAAvB;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,cAAL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","sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, observable } from \"@microsoft/fast-element\";\nimport { Direction, eventResize, eventScroll } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element\";\nimport { getDirection } from \"../utilities/direction\";\nimport { IntersectionService } from \"../utilities/intersection-service\";\n/**\n * An anchored region Custom HTML Element.\n *\n * @public\n */\nexport class AnchoredRegion extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * The HTML ID of the anchor element this region is positioned relative to\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: anchor\n         */\n        this.anchor = \"\";\n        /**\n         * The HTML ID of the viewport element this region is positioned relative to\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: anchor\n         */\n        this.viewport = \"\";\n        /**\n         * Sets what logic the component uses to determine horizontal placement.\n         * 'locktodefault' forces the default position\n         * 'dynamic' decides placement based on available space\n         * 'uncontrolled' does not control placement on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-positioning-mode\n         */\n        this.horizontalPositioningMode = \"uncontrolled\";\n        /**\n         * The default horizontal position of the region relative to the anchor element\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-default-position\n         */\n        this.horizontalDefaultPosition = \"unset\";\n        /**\n         * Whether the region remains in the viewport (ie. detaches from the anchor) on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-viewport-lock\n         */\n        this.horizontalViewportLock = false;\n        /**\n         * Whether the region overlaps the anchor on the horizontal axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-inset\n         */\n        this.horizontalInset = false;\n        /**\n         * Defines how the width of the region is calculated\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: horizontal-scaling\n         */\n        this.horizontalScaling = \"content\";\n        /**\n         * Sets what logic the component uses to determine vertical placement.\n         * 'locktodefault' forces the default position\n         * 'dynamic' decides placement based on available space\n         * 'uncontrolled' does not control placement on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-positioning-mode\n         */\n        this.verticalPositioningMode = \"uncontrolled\";\n        /**\n         * The default vertical position of the region relative to the anchor element\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-default-position\n         */\n        this.verticalDefaultPosition = \"unset\";\n        /**\n         * Whether the region remains in the viewport (ie. detaches from the anchor) on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-viewport-lock\n         */\n        this.verticalViewportLock = false;\n        /**\n         * Whether the region overlaps the anchor on the vertical axis\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-inset\n         */\n        this.verticalInset = false;\n        /**\n         * Defines how the height of the region is calculated\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: vertical-scaling\n         */\n        this.verticalScaling = \"content\";\n        /**\n         * Whether the region is positioned using css \"position: fixed\".\n         * Otherwise the region uses \"position: absolute\".\n         * Fixed placement allows the region to break out of parent containers,\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: fixed-placement\n         */\n        this.fixedPlacement = false;\n        /**\n         * Defines what triggers the anchored region to revaluate positioning\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: auto-update-mode\n         */\n        this.autoUpdateMode = \"anchor\";\n        /**\n         * The HTML element being used as the anchor\n         *\n         * @public\n         */\n        this.anchorElement = null;\n        /**\n         * The HTML element being used as the viewport\n         *\n         * @public\n         */\n        this.viewportElement = null;\n        /**\n         * indicates that an initial positioning pass on layout has completed\n         *\n         * @internal\n         */\n        this.initialLayoutComplete = false;\n        this.resizeDetector = null;\n        /**\n         * base offsets between the positioner's base position and the anchor's\n         */\n        this.baseHorizontalOffset = 0;\n        this.baseVerticalOffset = 0;\n        this.pendingPositioningUpdate = false;\n        this.pendingReset = false;\n        this.currentDirection = Direction.ltr;\n        this.regionVisible = false;\n        // indicates that a layout update should occur even if geometry has not changed\n        // used to ensure some attribute changes are applied\n        this.forceUpdate = false;\n        // defines how big a difference in pixels there must be between states to\n        // justify a layout update that affects the dom (prevents repeated sub-pixel corrections)\n        this.updateThreshold = 0.5;\n        /**\n         * update position\n         */\n        this.update = () => {\n            if (!this.pendingPositioningUpdate) {\n                this.requestPositionUpdates();\n            }\n        };\n        /**\n         * starts observers\n         */\n        this.startObservers = () => {\n            this.stopObservers();\n            if (this.anchorElement === null) {\n                return;\n            }\n            this.requestPositionUpdates();\n            if (this.resizeDetector !== null) {\n                this.resizeDetector.observe(this.anchorElement);\n                this.resizeDetector.observe(this);\n            }\n        };\n        /**\n         * get position updates\n         */\n        this.requestPositionUpdates = () => {\n            if (this.anchorElement === null || this.pendingPositioningUpdate) {\n                return;\n            }\n            AnchoredRegion.intersectionService.requestPosition(this, this.handleIntersection);\n            AnchoredRegion.intersectionService.requestPosition(this.anchorElement, this.handleIntersection);\n            if (this.viewportElement !== null) {\n                AnchoredRegion.intersectionService.requestPosition(this.viewportElement, this.handleIntersection);\n            }\n            this.pendingPositioningUpdate = true;\n        };\n        /**\n         * stops observers\n         */\n        this.stopObservers = () => {\n            if (this.pendingPositioningUpdate) {\n                this.pendingPositioningUpdate = false;\n                AnchoredRegion.intersectionService.cancelRequestPosition(this, this.handleIntersection);\n                if (this.anchorElement !== null) {\n                    AnchoredRegion.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection);\n                }\n                if (this.viewportElement !== null) {\n                    AnchoredRegion.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection);\n                }\n            }\n            if (this.resizeDetector !== null) {\n                this.resizeDetector.disconnect();\n            }\n        };\n        /**\n         * Gets the viewport element by id, or defaults to document root\n         */\n        this.getViewport = () => {\n            if (typeof this.viewport !== \"string\" || this.viewport === \"\") {\n                return document.documentElement;\n            }\n            return document.getElementById(this.viewport);\n        };\n        /**\n         *  Gets the anchor element by id\n         */\n        this.getAnchor = () => {\n            return document.getElementById(this.anchor);\n        };\n        /**\n         *  Handle intersections\n         */\n        this.handleIntersection = (entries) => {\n            if (!this.pendingPositioningUpdate) {\n                return;\n            }\n            this.pendingPositioningUpdate = false;\n            if (!this.applyIntersectionEntries(entries)) {\n                return;\n            }\n            this.updateLayout();\n        };\n        /**\n         *  iterate through intersection entries and apply data\n         */\n        this.applyIntersectionEntries = (entries) => {\n            const regionEntry = entries.find(x => x.target === this);\n            const anchorEntry = entries.find(x => x.target === this.anchorElement);\n            const viewportEntry = entries.find(x => x.target === this.viewportElement);\n            if (regionEntry === undefined ||\n                viewportEntry === undefined ||\n                anchorEntry === undefined) {\n                return false;\n            }\n            // don't update the dom unless there is a significant difference in rect positions\n            if (!this.regionVisible ||\n                this.forceUpdate ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined ||\n                this.isRectDifferent(this.anchorRect, anchorEntry.boundingClientRect) ||\n                this.isRectDifferent(this.viewportRect, viewportEntry.boundingClientRect) ||\n                this.isRectDifferent(this.regionRect, regionEntry.boundingClientRect)) {\n                this.regionRect = regionEntry.boundingClientRect;\n                this.anchorRect = anchorEntry.boundingClientRect;\n                if (this.viewportElement === document.documentElement) {\n                    this.viewportRect = new DOMRectReadOnly(viewportEntry.boundingClientRect.x +\n                        document.documentElement.scrollLeft, viewportEntry.boundingClientRect.y +\n                        document.documentElement.scrollTop, viewportEntry.boundingClientRect.width, viewportEntry.boundingClientRect.height);\n                }\n                else {\n                    this.viewportRect = viewportEntry.boundingClientRect;\n                }\n                this.updateRegionOffset();\n                this.forceUpdate = false;\n                return true;\n            }\n            return false;\n        };\n        /**\n         *  Update the offset values\n         */\n        this.updateRegionOffset = () => {\n            if (this.anchorRect && this.regionRect) {\n                this.baseHorizontalOffset =\n                    this.baseHorizontalOffset +\n                        (this.anchorRect.left - this.regionRect.left) +\n                        (this.translateX - this.baseHorizontalOffset);\n                this.baseVerticalOffset =\n                    this.baseVerticalOffset +\n                        (this.anchorRect.top - this.regionRect.top) +\n                        (this.translateY - this.baseVerticalOffset);\n            }\n        };\n        /**\n         *  compare rects to see if there is enough change to justify a DOM update\n         */\n        this.isRectDifferent = (rectA, rectB) => {\n            if (Math.abs(rectA.top - rectB.top) > this.updateThreshold ||\n                Math.abs(rectA.right - rectB.right) > this.updateThreshold ||\n                Math.abs(rectA.bottom - rectB.bottom) > this.updateThreshold ||\n                Math.abs(rectA.left - rectB.left) > this.updateThreshold) {\n                return true;\n            }\n            return false;\n        };\n        /**\n         *  Handle resize events\n         */\n        this.handleResize = (entries) => {\n            this.update();\n        };\n        /**\n         * resets the component\n         */\n        this.reset = () => {\n            if (!this.pendingReset) {\n                return;\n            }\n            this.pendingReset = false;\n            if (this.anchorElement === null) {\n                this.anchorElement = this.getAnchor();\n            }\n            if (this.viewportElement === null) {\n                this.viewportElement = this.getViewport();\n            }\n            this.currentDirection = getDirection(this);\n            this.startObservers();\n        };\n        /**\n         *  Recalculate layout related state values\n         */\n        this.updateLayout = () => {\n            let desiredVerticalPosition = undefined;\n            let desiredHorizontalPosition = undefined;\n            if (this.horizontalPositioningMode !== \"uncontrolled\") {\n                const horizontalOptions = this.getPositioningOptions(this.horizontalInset);\n                if (this.horizontalDefaultPosition === \"center\") {\n                    desiredHorizontalPosition = \"center\";\n                }\n                else if (this.horizontalDefaultPosition !== \"unset\") {\n                    let dirCorrectedHorizontalDefaultPosition = this\n                        .horizontalDefaultPosition;\n                    if (dirCorrectedHorizontalDefaultPosition === \"start\" ||\n                        dirCorrectedHorizontalDefaultPosition === \"end\") {\n                        // if direction changes we reset the layout\n                        const newDirection = getDirection(this);\n                        if (newDirection !== this.currentDirection) {\n                            this.currentDirection = newDirection;\n                            this.initialize();\n                            return;\n                        }\n                        if (this.currentDirection === Direction.ltr) {\n                            dirCorrectedHorizontalDefaultPosition =\n                                dirCorrectedHorizontalDefaultPosition === \"start\"\n                                    ? \"left\"\n                                    : \"right\";\n                        }\n                        else {\n                            dirCorrectedHorizontalDefaultPosition =\n                                dirCorrectedHorizontalDefaultPosition === \"start\"\n                                    ? \"right\"\n                                    : \"left\";\n                        }\n                    }\n                    switch (dirCorrectedHorizontalDefaultPosition) {\n                        case \"left\":\n                            desiredHorizontalPosition = this.horizontalInset\n                                ? \"insetStart\"\n                                : \"start\";\n                            break;\n                        case \"right\":\n                            desiredHorizontalPosition = this.horizontalInset\n                                ? \"insetEnd\"\n                                : \"end\";\n                            break;\n                    }\n                }\n                const horizontalThreshold = this.horizontalThreshold !== undefined\n                    ? this.horizontalThreshold\n                    : this.regionRect !== undefined\n                        ? this.regionRect.width\n                        : 0;\n                const anchorLeft = this.anchorRect !== undefined ? this.anchorRect.left : 0;\n                const anchorRight = this.anchorRect !== undefined ? this.anchorRect.right : 0;\n                const anchorWidth = this.anchorRect !== undefined ? this.anchorRect.width : 0;\n                const viewportLeft = this.viewportRect !== undefined ? this.viewportRect.left : 0;\n                const viewportRight = this.viewportRect !== undefined ? this.viewportRect.right : 0;\n                if (desiredHorizontalPosition === undefined ||\n                    (!(this.horizontalPositioningMode === \"locktodefault\") &&\n                        this.getAvailableSpace(desiredHorizontalPosition, anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) < horizontalThreshold)) {\n                    desiredHorizontalPosition =\n                        this.getAvailableSpace(horizontalOptions[0], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight) >\n                            this.getAvailableSpace(horizontalOptions[1], anchorLeft, anchorRight, anchorWidth, viewportLeft, viewportRight)\n                            ? horizontalOptions[0]\n                            : horizontalOptions[1];\n                }\n            }\n            if (this.verticalPositioningMode !== \"uncontrolled\") {\n                const verticalOptions = this.getPositioningOptions(this.verticalInset);\n                if (this.verticalDefaultPosition === \"center\") {\n                    desiredVerticalPosition = \"center\";\n                }\n                else if (this.verticalDefaultPosition !== \"unset\") {\n                    switch (this.verticalDefaultPosition) {\n                        case \"top\":\n                            desiredVerticalPosition = this.verticalInset\n                                ? \"insetStart\"\n                                : \"start\";\n                            break;\n                        case \"bottom\":\n                            desiredVerticalPosition = this.verticalInset ? \"insetEnd\" : \"end\";\n                            break;\n                    }\n                }\n                const verticalThreshold = this.verticalThreshold !== undefined\n                    ? this.verticalThreshold\n                    : this.regionRect !== undefined\n                        ? this.regionRect.height\n                        : 0;\n                const anchorTop = this.anchorRect !== undefined ? this.anchorRect.top : 0;\n                const anchorBottom = this.anchorRect !== undefined ? this.anchorRect.bottom : 0;\n                const anchorHeight = this.anchorRect !== undefined ? this.anchorRect.height : 0;\n                const viewportTop = this.viewportRect !== undefined ? this.viewportRect.top : 0;\n                const viewportBottom = this.viewportRect !== undefined ? this.viewportRect.bottom : 0;\n                if (desiredVerticalPosition === undefined ||\n                    (!(this.verticalPositioningMode === \"locktodefault\") &&\n                        this.getAvailableSpace(desiredVerticalPosition, anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) < verticalThreshold)) {\n                    desiredVerticalPosition =\n                        this.getAvailableSpace(verticalOptions[0], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom) >\n                            this.getAvailableSpace(verticalOptions[1], anchorTop, anchorBottom, anchorHeight, viewportTop, viewportBottom)\n                            ? verticalOptions[0]\n                            : verticalOptions[1];\n                }\n            }\n            const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);\n            const positionChanged = this.horizontalPosition !== desiredHorizontalPosition ||\n                this.verticalPosition !== desiredVerticalPosition;\n            this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);\n            this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);\n            this.updateRegionStyle();\n            if (!this.initialLayoutComplete) {\n                this.initialLayoutComplete = true;\n                this.requestPositionUpdates();\n                return;\n            }\n            if (!this.regionVisible) {\n                this.regionVisible = true;\n                this.style.removeProperty(\"pointer-events\");\n                this.style.removeProperty(\"opacity\");\n                this.classList.toggle(\"loaded\", true);\n                this.$emit(\"loaded\", this, { bubbles: false });\n            }\n            this.updatePositionClasses();\n            if (positionChanged) {\n                // emit change event\n                this.$emit(\"positionchange\", this, { bubbles: false });\n            }\n        };\n        /**\n         *  Updates the style string applied to the region element as well as the css classes attached\n         *  to the root element\n         */\n        this.updateRegionStyle = () => {\n            this.style.width = this.regionWidth;\n            this.style.height = this.regionHeight;\n            this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;\n        };\n        /**\n         *  Updates the css classes that reflect the current position of the element\n         */\n        this.updatePositionClasses = () => {\n            this.classList.toggle(\"top\", this.verticalPosition === \"start\");\n            this.classList.toggle(\"bottom\", this.verticalPosition === \"end\");\n            this.classList.toggle(\"inset-top\", this.verticalPosition === \"insetStart\");\n            this.classList.toggle(\"inset-bottom\", this.verticalPosition === \"insetEnd\");\n            this.classList.toggle(\"vertical-center\", this.verticalPosition === \"center\");\n            this.classList.toggle(\"left\", this.horizontalPosition === \"start\");\n            this.classList.toggle(\"right\", this.horizontalPosition === \"end\");\n            this.classList.toggle(\"inset-left\", this.horizontalPosition === \"insetStart\");\n            this.classList.toggle(\"inset-right\", this.horizontalPosition === \"insetEnd\");\n            this.classList.toggle(\"horizontal-center\", this.horizontalPosition === \"center\");\n        };\n        /**\n         * Get horizontal positioning state based on desired position\n         */\n        this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {\n            if (desiredHorizontalPosition === undefined ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined) {\n                return;\n            }\n            let nextRegionWidth = 0;\n            switch (this.horizontalScaling) {\n                case \"anchor\":\n                case \"fill\":\n                    nextRegionWidth = nextPositionerDimension.width;\n                    this.regionWidth = `${nextRegionWidth}px`;\n                    break;\n                case \"content\":\n                    nextRegionWidth = this.regionRect.width;\n                    this.regionWidth = \"unset\";\n                    break;\n            }\n            let sizeDelta = 0;\n            switch (desiredHorizontalPosition) {\n                case \"start\":\n                    this.translateX = this.baseHorizontalOffset - nextRegionWidth;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.left > this.viewportRect.right) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.left - this.viewportRect.right);\n                    }\n                    break;\n                case \"insetStart\":\n                    this.translateX =\n                        this.baseHorizontalOffset - nextRegionWidth + this.anchorRect.width;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.right > this.viewportRect.right) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.right - this.viewportRect.right);\n                    }\n                    break;\n                case \"insetEnd\":\n                    this.translateX = this.baseHorizontalOffset;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.left < this.viewportRect.left) {\n                        this.translateX =\n                            this.translateX - (this.anchorRect.left - this.viewportRect.left);\n                    }\n                    break;\n                case \"end\":\n                    this.translateX = this.baseHorizontalOffset + this.anchorRect.width;\n                    if (this.horizontalViewportLock &&\n                        this.anchorRect.right < this.viewportRect.left) {\n                        this.translateX =\n                            this.translateX -\n                                (this.anchorRect.right - this.viewportRect.left);\n                    }\n                    break;\n                case \"center\":\n                    sizeDelta = (this.anchorRect.width - nextRegionWidth) / 2;\n                    this.translateX = this.baseHorizontalOffset + sizeDelta;\n                    if (this.horizontalViewportLock) {\n                        const regionLeft = this.anchorRect.left + sizeDelta;\n                        const regionRight = this.anchorRect.right - sizeDelta;\n                        if (regionLeft < this.viewportRect.left &&\n                            !(regionRight > this.viewportRect.right)) {\n                            this.translateX =\n                                this.translateX - (regionLeft - this.viewportRect.left);\n                        }\n                        else if (regionRight > this.viewportRect.right &&\n                            !(regionLeft < this.viewportRect.left)) {\n                            this.translateX =\n                                this.translateX - (regionRight - this.viewportRect.right);\n                        }\n                    }\n                    break;\n            }\n            this.horizontalPosition = desiredHorizontalPosition;\n        };\n        /**\n         * Set vertical positioning state based on desired position\n         */\n        this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {\n            if (desiredVerticalPosition === undefined ||\n                this.regionRect === undefined ||\n                this.anchorRect === undefined ||\n                this.viewportRect === undefined) {\n                return;\n            }\n            let nextRegionHeight = 0;\n            switch (this.verticalScaling) {\n                case \"anchor\":\n                case \"fill\":\n                    nextRegionHeight = nextPositionerDimension.height;\n                    this.regionHeight = `${nextRegionHeight}px`;\n                    break;\n                case \"content\":\n                    nextRegionHeight = this.regionRect.height;\n                    this.regionHeight = \"unset\";\n                    break;\n            }\n            let sizeDelta = 0;\n            switch (desiredVerticalPosition) {\n                case \"start\":\n                    this.translateY = this.baseVerticalOffset - nextRegionHeight;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.top > this.viewportRect.bottom) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.top - this.viewportRect.bottom);\n                    }\n                    break;\n                case \"insetStart\":\n                    this.translateY =\n                        this.baseVerticalOffset - nextRegionHeight + this.anchorRect.height;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.bottom > this.viewportRect.bottom) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.bottom - this.viewportRect.bottom);\n                    }\n                    break;\n                case \"insetEnd\":\n                    this.translateY = this.baseVerticalOffset;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.top < this.viewportRect.top) {\n                        this.translateY =\n                            this.translateY - (this.anchorRect.top - this.viewportRect.top);\n                    }\n                    break;\n                case \"end\":\n                    this.translateY = this.baseVerticalOffset + this.anchorRect.height;\n                    if (this.verticalViewportLock &&\n                        this.anchorRect.bottom < this.viewportRect.top) {\n                        this.translateY =\n                            this.translateY -\n                                (this.anchorRect.bottom - this.viewportRect.top);\n                    }\n                    break;\n                case \"center\":\n                    sizeDelta = (this.anchorRect.height - nextRegionHeight) / 2;\n                    this.translateY = this.baseVerticalOffset + sizeDelta;\n                    if (this.verticalViewportLock) {\n                        const regionTop = this.anchorRect.top + sizeDelta;\n                        const regionBottom = this.anchorRect.bottom - sizeDelta;\n                        if (regionTop < this.viewportRect.top &&\n                            !(regionBottom > this.viewportRect.bottom)) {\n                            this.translateY =\n                                this.translateY - (regionTop - this.viewportRect.top);\n                        }\n                        else if (regionBottom > this.viewportRect.bottom &&\n                            !(regionTop < this.viewportRect.top)) {\n                            this.translateY =\n                                this.translateY - (regionBottom - this.viewportRect.bottom);\n                        }\n                    }\n            }\n            this.verticalPosition = desiredVerticalPosition;\n        };\n        /**\n         *  Get available positions based on positioning mode\n         */\n        this.getPositioningOptions = (inset) => {\n            if (inset) {\n                return [\"insetStart\", \"insetEnd\"];\n            }\n            return [\"start\", \"end\"];\n        };\n        /**\n         *  Get the space available for a particular relative position\n         */\n        this.getAvailableSpace = (positionOption, anchorStart, anchorEnd, anchorSpan, viewportStart, viewportEnd) => {\n            const spaceStart = anchorStart - viewportStart;\n            const spaceEnd = viewportEnd - (anchorStart + anchorSpan);\n            switch (positionOption) {\n                case \"start\":\n                    return spaceStart;\n                case \"insetStart\":\n                    return spaceStart + anchorSpan;\n                case \"insetEnd\":\n                    return spaceEnd + anchorSpan;\n                case \"end\":\n                    return spaceEnd;\n                case \"center\":\n                    return Math.min(spaceStart, spaceEnd) * 2 + anchorSpan;\n            }\n        };\n        /**\n         * Get region dimensions\n         */\n        this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {\n            const newRegionDimension = {\n                height: this.regionRect !== undefined ? this.regionRect.height : 0,\n                width: this.regionRect !== undefined ? this.regionRect.width : 0,\n            };\n            if (desiredHorizontalPosition !== undefined &&\n                this.horizontalScaling === \"fill\") {\n                newRegionDimension.width = this.getAvailableSpace(desiredHorizontalPosition, this.anchorRect !== undefined ? this.anchorRect.left : 0, this.anchorRect !== undefined ? this.anchorRect.right : 0, this.anchorRect !== undefined ? this.anchorRect.width : 0, this.viewportRect !== undefined ? this.viewportRect.left : 0, this.viewportRect !== undefined ? this.viewportRect.right : 0);\n            }\n            else if (this.horizontalScaling === \"anchor\") {\n                newRegionDimension.width =\n                    this.anchorRect !== undefined ? this.anchorRect.width : 0;\n            }\n            if (desiredVerticalPosition !== undefined && this.verticalScaling === \"fill\") {\n                newRegionDimension.height = this.getAvailableSpace(desiredVerticalPosition, this.anchorRect !== undefined ? this.anchorRect.top : 0, this.anchorRect !== undefined ? this.anchorRect.bottom : 0, this.anchorRect !== undefined ? this.anchorRect.height : 0, this.viewportRect !== undefined ? this.viewportRect.top : 0, this.viewportRect !== undefined ? this.viewportRect.bottom : 0);\n            }\n            else if (this.verticalScaling === \"anchor\") {\n                newRegionDimension.height =\n                    this.anchorRect !== undefined ? this.anchorRect.height : 0;\n            }\n            return newRegionDimension;\n        };\n        /**\n         * starts event listeners that can trigger auto updating\n         */\n        this.startAutoUpdateEventListeners = () => {\n            window.addEventListener(eventResize, this.update, { passive: true });\n            window.addEventListener(eventScroll, this.update, {\n                passive: true,\n                capture: true,\n            });\n            if (this.resizeDetector !== null && this.viewportElement !== null) {\n                this.resizeDetector.observe(this.viewportElement);\n            }\n        };\n        /**\n         * stops event listeners that can trigger auto updating\n         */\n        this.stopAutoUpdateEventListeners = () => {\n            window.removeEventListener(eventResize, this.update);\n            window.removeEventListener(eventScroll, this.update);\n            if (this.resizeDetector !== null && this.viewportElement !== null) {\n                this.resizeDetector.unobserve(this.viewportElement);\n            }\n        };\n    }\n    anchorChanged() {\n        if (this.initialLayoutComplete) {\n            this.anchorElement = this.getAnchor();\n        }\n    }\n    viewportChanged() {\n        if (this.initialLayoutComplete) {\n            this.viewportElement = this.getViewport();\n        }\n    }\n    horizontalPositioningModeChanged() {\n        this.requestReset();\n    }\n    horizontalDefaultPositionChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalViewportLockChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalInsetChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalThresholdChanged() {\n        this.updateForAttributeChange();\n    }\n    horizontalScalingChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalPositioningModeChanged() {\n        this.requestReset();\n    }\n    verticalDefaultPositionChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalViewportLockChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalInsetChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalThresholdChanged() {\n        this.updateForAttributeChange();\n    }\n    verticalScalingChanged() {\n        this.updateForAttributeChange();\n    }\n    fixedPlacementChanged() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.initialize();\n        }\n    }\n    autoUpdateModeChanged(prevMode, newMode) {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            if (prevMode === \"auto\") {\n                this.stopAutoUpdateEventListeners();\n            }\n            if (newMode === \"auto\") {\n                this.startAutoUpdateEventListeners();\n            }\n        }\n    }\n    anchorElementChanged() {\n        this.requestReset();\n    }\n    viewportElementChanged() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.initialize();\n        }\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.autoUpdateMode === \"auto\") {\n            this.startAutoUpdateEventListeners();\n        }\n        this.initialize();\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        if (this.autoUpdateMode === \"auto\") {\n            this.stopAutoUpdateEventListeners();\n        }\n        this.stopObservers();\n        this.disconnectResizeDetector();\n    }\n    /**\n     * @internal\n     */\n    adoptedCallback() {\n        this.initialize();\n    }\n    /**\n     * destroys the instance's resize observer\n     */\n    disconnectResizeDetector() {\n        if (this.resizeDetector !== null) {\n            this.resizeDetector.disconnect();\n            this.resizeDetector = null;\n        }\n    }\n    /**\n     * initializes the instance's resize observer\n     */\n    initializeResizeDetector() {\n        this.disconnectResizeDetector();\n        this.resizeDetector = new window.ResizeObserver(this.handleResize);\n    }\n    /**\n     * react to attribute changes that don't require a reset\n     */\n    updateForAttributeChange() {\n        if (this.$fastController.isConnected &&\n            this.initialLayoutComplete) {\n            this.forceUpdate = true;\n            this.update();\n        }\n    }\n    /**\n     * fully initializes the component\n     */\n    initialize() {\n        this.initializeResizeDetector();\n        if (this.anchorElement === null) {\n            this.anchorElement = this.getAnchor();\n        }\n        this.requestReset();\n    }\n    /**\n     * Request a reset if there are currently no open requests\n     */\n    requestReset() {\n        if (this.$fastController.isConnected &&\n            this.pendingReset === false) {\n            this.setInitialState();\n            DOM.queueUpdate(() => this.reset());\n            this.pendingReset = true;\n        }\n    }\n    /**\n     * sets the starting configuration for component internal values\n     */\n    setInitialState() {\n        this.initialLayoutComplete = false;\n        this.regionVisible = false;\n        this.translateX = 0;\n        this.translateY = 0;\n        this.baseHorizontalOffset = 0;\n        this.baseVerticalOffset = 0;\n        this.viewportRect = undefined;\n        this.regionRect = undefined;\n        this.anchorRect = undefined;\n        this.verticalPosition = undefined;\n        this.horizontalPosition = undefined;\n        this.style.opacity = \"0\";\n        this.style.pointerEvents = \"none\";\n        this.forceUpdate = false;\n        this.style.position = this.fixedPlacement ? \"fixed\" : \"absolute\";\n        this.updatePositionClasses();\n        this.updateRegionStyle();\n    }\n}\nAnchoredRegion.intersectionService = new IntersectionService();\n__decorate([\n    attr\n], AnchoredRegion.prototype, \"anchor\", void 0);\n__decorate([\n    attr\n], AnchoredRegion.prototype, \"viewport\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-positioning-mode\" })\n], AnchoredRegion.prototype, \"horizontalPositioningMode\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-default-position\" })\n], AnchoredRegion.prototype, \"horizontalDefaultPosition\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-viewport-lock\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"horizontalViewportLock\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-inset\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"horizontalInset\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-threshold\" })\n], AnchoredRegion.prototype, \"horizontalThreshold\", void 0);\n__decorate([\n    attr({ attribute: \"horizontal-scaling\" })\n], AnchoredRegion.prototype, \"horizontalScaling\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-positioning-mode\" })\n], AnchoredRegion.prototype, \"verticalPositioningMode\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-default-position\" })\n], AnchoredRegion.prototype, \"verticalDefaultPosition\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-viewport-lock\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"verticalViewportLock\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-inset\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"verticalInset\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-threshold\" })\n], AnchoredRegion.prototype, \"verticalThreshold\", void 0);\n__decorate([\n    attr({ attribute: \"vertical-scaling\" })\n], AnchoredRegion.prototype, \"verticalScaling\", void 0);\n__decorate([\n    attr({ attribute: \"fixed-placement\", mode: \"boolean\" })\n], AnchoredRegion.prototype, \"fixedPlacement\", void 0);\n__decorate([\n    attr({ attribute: \"auto-update-mode\" })\n], AnchoredRegion.prototype, \"autoUpdateMode\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"anchorElement\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"viewportElement\", void 0);\n__decorate([\n    observable\n], AnchoredRegion.prototype, \"initialLayoutComplete\", void 0);\n"]},"metadata":{},"sourceType":"module"}