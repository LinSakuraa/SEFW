{"ast":null,"code":"import { emptyArray } from \"../platform\";\n/** @internal */\n\nexport function newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\n\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  const rowCount = oldEnd - oldStart + 1;\n  const columnCount = currentEnd - currentStart + 1;\n  const distances = new Array(rowCount);\n  let north;\n  let west; // \"Addition\" rows. Initialize null column.\n\n  for (let i = 0; i < rowCount; ++i) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  } // Initialize null row\n\n\n  for (let j = 0; j < columnCount; ++j) {\n    distances[0][j] = j;\n  }\n\n  for (let i = 1; i < rowCount; ++i) {\n    for (let j = 1; j < columnCount; ++j) {\n      if (current[currentStart + j - 1] === old[oldStart + i - 1]) {\n        distances[i][j] = distances[i - 1][j - 1];\n      } else {\n        north = distances[i - 1][j] + 1;\n        west = distances[i][j - 1] + 1;\n        distances[i][j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n} // This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\n\n\nfunction spliceOperationsFromEditDistances(distances) {\n  let i = distances.length - 1;\n  let j = distances[0].length - 1;\n  let current = distances[i][j];\n  const edits = [];\n\n  while (i > 0 || j > 0) {\n    if (i === 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n\n    if (j === 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n\n    const northWest = distances[i - 1][j - 1];\n    const west = distances[i - 1][j];\n    const north = distances[i][j - 1];\n    let min;\n\n    if (west < north) {\n      min = west < northWest ? west : northWest;\n    } else {\n      min = north < northWest ? north : northWest;\n    }\n\n    if (min === northWest) {\n      if (northWest === current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n\n      i--;\n      j--;\n    } else if (min === west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (let i = 0; i < searchLength; ++i) {\n    if (current[i] !== old[i]) {\n      return i;\n    }\n  }\n\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  let index1 = current.length;\n  let index2 = old.length;\n  let count = 0;\n\n  while (count < searchLength && current[--index1] === old[--index2]) {\n    count++;\n  }\n\n  return count;\n}\n\nfunction intersect(start1, end1, start2, end2) {\n  // Disjoint\n  if (end1 < start2 || end2 < start1) {\n    return -1;\n  } // Adjacent\n\n\n  if (end1 === start2 || end2 === start1) {\n    return 0;\n  } // Non-zero intersect, span1 first\n\n\n  if (start1 < start2) {\n    if (end1 < end2) {\n      return end1 - start2; // Overlap\n    }\n\n    return end2 - start2; // Contained\n  } // Non-zero intersect, span2 first\n\n\n  if (end2 < end1) {\n    return end2 - start1; // Overlap\n  }\n\n  return end1 - start1; // Contained\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * @internal\n * @remarks\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\n\n\nexport function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  let prefixCount = 0;\n  let suffixCount = 0;\n  const minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\n  if (currentStart === 0 && oldStart === 0) {\n    prefixCount = sharedPrefix(current, old, minLength);\n  }\n\n  if (currentEnd === current.length && oldEnd === old.length) {\n    suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  }\n\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n\n  if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {\n    return emptyArray;\n  }\n\n  if (currentStart === currentEnd) {\n    const splice = newSplice(currentStart, [], 0);\n\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart === oldEnd) {\n    return [newSplice(currentStart, [], currentEnd - currentStart)];\n  }\n\n  const ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  const splices = [];\n  let splice = void 0;\n  let index = currentStart;\n  let oldIndex = oldStart;\n\n  for (let i = 0; i < ops.length; ++i) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice !== void 0) {\n          splices.push(splice);\n          splice = void 0;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n\n      case EDIT_UPDATE:\n        if (splice === void 0) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n\n      case EDIT_ADD:\n        if (splice === void 0) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n        break;\n\n      case EDIT_DELETE:\n        if (splice === void 0) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n      // no default\n    }\n  }\n\n  if (splice !== void 0) {\n    splices.push(splice);\n  }\n\n  return splices;\n}\nconst $push = Array.prototype.push;\n\nfunction mergeSplice(splices, index, removed, addedCount) {\n  const splice = newSplice(index, removed, addedCount);\n  let inserted = false;\n  let insertionOffset = 0;\n\n  for (let i = 0; i < splices.length; i++) {\n    const current = splices[i];\n    current.index += insertionOffset;\n\n    if (inserted) {\n      continue;\n    }\n\n    const intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);\n\n    if (intersectCount >= 0) {\n      // Merge the two splices\n      splices.splice(i, 1);\n      i--;\n      insertionOffset -= current.addedCount - current.removed.length;\n      splice.addedCount += current.addedCount - intersectCount;\n      const deleteCount = splice.removed.length + current.removed.length - intersectCount;\n\n      if (!splice.addedCount && !deleteCount) {\n        // merged splice is a noop. discard.\n        inserted = true;\n      } else {\n        let currentRemoved = current.removed;\n\n        if (splice.index < current.index) {\n          // some prefix of splice.removed is prepended to current.removed.\n          const prepend = splice.removed.slice(0, current.index - splice.index);\n          $push.apply(prepend, currentRemoved);\n          currentRemoved = prepend;\n        }\n\n        if (splice.index + splice.removed.length > current.index + current.addedCount) {\n          // some suffix of splice.removed is appended to current.removed.\n          const append = splice.removed.slice(current.index + current.addedCount - splice.index);\n          $push.apply(currentRemoved, append);\n        }\n\n        splice.removed = currentRemoved;\n\n        if (current.index < splice.index) {\n          splice.index = current.index;\n        }\n      }\n    } else if (splice.index < current.index) {\n      // Insert splice here.\n      inserted = true;\n      splices.splice(i, 0, splice);\n      i++;\n      const offset = splice.addedCount - splice.removed.length;\n      current.index += offset;\n      insertionOffset += offset;\n    }\n  }\n\n  if (!inserted) {\n    splices.push(splice);\n  }\n}\n\nfunction createInitialSplices(changeRecords) {\n  const splices = [];\n\n  for (let i = 0, ii = changeRecords.length; i < ii; i++) {\n    const record = changeRecords[i];\n    mergeSplice(splices, record.index, record.removed, record.addedCount);\n  }\n\n  return splices;\n}\n/** @internal */\n\n\nexport function projectArraySplices(array, changeRecords) {\n  let splices = [];\n  const initialSplices = createInitialSplices(changeRecords);\n\n  for (let i = 0, ii = initialSplices.length; i < ii; ++i) {\n    const splice = initialSplices[i];\n\n    if (splice.addedCount === 1 && splice.removed.length === 1) {\n      if (splice.removed[0] !== array[splice.index]) {\n        splices.push(splice);\n      }\n\n      continue;\n    }\n\n    splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));\n  }\n\n  return splices;\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js"],"names":["emptyArray","newSplice","index","removed","addedCount","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","calcEditDistances","current","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","Array","north","west","i","j","spliceOperationsFromEditDistances","length","edits","push","northWest","min","reverse","sharedPrefix","searchLength","sharedSuffix","index1","index2","count","intersect","start1","end1","start2","end2","calcSplices","prefixCount","suffixCount","minLength","Math","splice","ops","splices","oldIndex","$push","prototype","mergeSplice","inserted","insertionOffset","intersectCount","deleteCount","currentRemoved","prepend","slice","apply","append","offset","createInitialSplices","changeRecords","ii","record","projectArraySplices","array","initialSplices","concat"],"mappings":"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","sourcesContent":["import { emptyArray } from \"../platform\";\n/** @internal */\nexport function newSplice(index, removed, addedCount) {\n    return {\n        index: index,\n        removed: removed,\n        addedCount: addedCount,\n    };\n}\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3;\n// Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n    // \"Deletion\" columns\n    const rowCount = oldEnd - oldStart + 1;\n    const columnCount = currentEnd - currentStart + 1;\n    const distances = new Array(rowCount);\n    let north;\n    let west;\n    // \"Addition\" rows. Initialize null column.\n    for (let i = 0; i < rowCount; ++i) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n    }\n    // Initialize null row\n    for (let j = 0; j < columnCount; ++j) {\n        distances[0][j] = j;\n    }\n    for (let i = 1; i < rowCount; ++i) {\n        for (let j = 1; j < columnCount; ++j) {\n            if (current[currentStart + j - 1] === old[oldStart + i - 1]) {\n                distances[i][j] = distances[i - 1][j - 1];\n            }\n            else {\n                north = distances[i - 1][j] + 1;\n                west = distances[i][j - 1] + 1;\n                distances[i][j] = north < west ? north : west;\n            }\n        }\n    }\n    return distances;\n}\n// This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\nfunction spliceOperationsFromEditDistances(distances) {\n    let i = distances.length - 1;\n    let j = distances[0].length - 1;\n    let current = distances[i][j];\n    const edits = [];\n    while (i > 0 || j > 0) {\n        if (i === 0) {\n            edits.push(EDIT_ADD);\n            j--;\n            continue;\n        }\n        if (j === 0) {\n            edits.push(EDIT_DELETE);\n            i--;\n            continue;\n        }\n        const northWest = distances[i - 1][j - 1];\n        const west = distances[i - 1][j];\n        const north = distances[i][j - 1];\n        let min;\n        if (west < north) {\n            min = west < northWest ? west : northWest;\n        }\n        else {\n            min = north < northWest ? north : northWest;\n        }\n        if (min === northWest) {\n            if (northWest === current) {\n                edits.push(EDIT_LEAVE);\n            }\n            else {\n                edits.push(EDIT_UPDATE);\n                current = northWest;\n            }\n            i--;\n            j--;\n        }\n        else if (min === west) {\n            edits.push(EDIT_DELETE);\n            i--;\n            current = west;\n        }\n        else {\n            edits.push(EDIT_ADD);\n            j--;\n            current = north;\n        }\n    }\n    edits.reverse();\n    return edits;\n}\nfunction sharedPrefix(current, old, searchLength) {\n    for (let i = 0; i < searchLength; ++i) {\n        if (current[i] !== old[i]) {\n            return i;\n        }\n    }\n    return searchLength;\n}\nfunction sharedSuffix(current, old, searchLength) {\n    let index1 = current.length;\n    let index2 = old.length;\n    let count = 0;\n    while (count < searchLength && current[--index1] === old[--index2]) {\n        count++;\n    }\n    return count;\n}\nfunction intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1) {\n        return -1;\n    }\n    // Adjacent\n    if (end1 === start2 || end2 === start1) {\n        return 0;\n    }\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n        if (end1 < end2) {\n            return end1 - start2; // Overlap\n        }\n        return end2 - start2; // Contained\n    }\n    // Non-zero intersect, span2 first\n    if (end2 < end1) {\n        return end2 - start1; // Overlap\n    }\n    return end1 - start1; // Contained\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n/**\n * @internal\n * @remarks\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\nexport function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n    let prefixCount = 0;\n    let suffixCount = 0;\n    const minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n    if (currentStart === 0 && oldStart === 0) {\n        prefixCount = sharedPrefix(current, old, minLength);\n    }\n    if (currentEnd === current.length && oldEnd === old.length) {\n        suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n    }\n    currentStart += prefixCount;\n    oldStart += prefixCount;\n    currentEnd -= suffixCount;\n    oldEnd -= suffixCount;\n    if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {\n        return emptyArray;\n    }\n    if (currentStart === currentEnd) {\n        const splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd) {\n            splice.removed.push(old[oldStart++]);\n        }\n        return [splice];\n    }\n    else if (oldStart === oldEnd) {\n        return [newSplice(currentStart, [], currentEnd - currentStart)];\n    }\n    const ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n    const splices = [];\n    let splice = void 0;\n    let index = currentStart;\n    let oldIndex = oldStart;\n    for (let i = 0; i < ops.length; ++i) {\n        switch (ops[i]) {\n            case EDIT_LEAVE:\n                if (splice !== void 0) {\n                    splices.push(splice);\n                    splice = void 0;\n                }\n                index++;\n                oldIndex++;\n                break;\n            case EDIT_UPDATE:\n                if (splice === void 0) {\n                    splice = newSplice(index, [], 0);\n                }\n                splice.addedCount++;\n                index++;\n                splice.removed.push(old[oldIndex]);\n                oldIndex++;\n                break;\n            case EDIT_ADD:\n                if (splice === void 0) {\n                    splice = newSplice(index, [], 0);\n                }\n                splice.addedCount++;\n                index++;\n                break;\n            case EDIT_DELETE:\n                if (splice === void 0) {\n                    splice = newSplice(index, [], 0);\n                }\n                splice.removed.push(old[oldIndex]);\n                oldIndex++;\n                break;\n            // no default\n        }\n    }\n    if (splice !== void 0) {\n        splices.push(splice);\n    }\n    return splices;\n}\nconst $push = Array.prototype.push;\nfunction mergeSplice(splices, index, removed, addedCount) {\n    const splice = newSplice(index, removed, addedCount);\n    let inserted = false;\n    let insertionOffset = 0;\n    for (let i = 0; i < splices.length; i++) {\n        const current = splices[i];\n        current.index += insertionOffset;\n        if (inserted) {\n            continue;\n        }\n        const intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);\n        if (intersectCount >= 0) {\n            // Merge the two splices\n            splices.splice(i, 1);\n            i--;\n            insertionOffset -= current.addedCount - current.removed.length;\n            splice.addedCount += current.addedCount - intersectCount;\n            const deleteCount = splice.removed.length + current.removed.length - intersectCount;\n            if (!splice.addedCount && !deleteCount) {\n                // merged splice is a noop. discard.\n                inserted = true;\n            }\n            else {\n                let currentRemoved = current.removed;\n                if (splice.index < current.index) {\n                    // some prefix of splice.removed is prepended to current.removed.\n                    const prepend = splice.removed.slice(0, current.index - splice.index);\n                    $push.apply(prepend, currentRemoved);\n                    currentRemoved = prepend;\n                }\n                if (splice.index + splice.removed.length >\n                    current.index + current.addedCount) {\n                    // some suffix of splice.removed is appended to current.removed.\n                    const append = splice.removed.slice(current.index + current.addedCount - splice.index);\n                    $push.apply(currentRemoved, append);\n                }\n                splice.removed = currentRemoved;\n                if (current.index < splice.index) {\n                    splice.index = current.index;\n                }\n            }\n        }\n        else if (splice.index < current.index) {\n            // Insert splice here.\n            inserted = true;\n            splices.splice(i, 0, splice);\n            i++;\n            const offset = splice.addedCount - splice.removed.length;\n            current.index += offset;\n            insertionOffset += offset;\n        }\n    }\n    if (!inserted) {\n        splices.push(splice);\n    }\n}\nfunction createInitialSplices(changeRecords) {\n    const splices = [];\n    for (let i = 0, ii = changeRecords.length; i < ii; i++) {\n        const record = changeRecords[i];\n        mergeSplice(splices, record.index, record.removed, record.addedCount);\n    }\n    return splices;\n}\n/** @internal */\nexport function projectArraySplices(array, changeRecords) {\n    let splices = [];\n    const initialSplices = createInitialSplices(changeRecords);\n    for (let i = 0, ii = initialSplices.length; i < ii; ++i) {\n        const splice = initialSplices[i];\n        if (splice.addedCount === 1 && splice.removed.length === 1) {\n            if (splice.removed[0] !== array[splice.index]) {\n                splices.push(splice);\n            }\n            continue;\n        }\n        splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));\n    }\n    return splices;\n}\n"]},"metadata":{},"sourceType":"module"}