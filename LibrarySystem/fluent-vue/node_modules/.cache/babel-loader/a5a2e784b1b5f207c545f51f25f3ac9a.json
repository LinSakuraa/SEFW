{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n  constructor() {\n    super();\n    this.message = 'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n  }\n\n}\n\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n  return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\n\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n  const visitedKeys = new Set();\n  uncheckedKeys.forEach(uncheckedKey => {\n    const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n\n    if (uncheckedTreeNode !== undefined) {\n      let nodeCursor = uncheckedTreeNode.parent;\n\n      while (nodeCursor !== null) {\n        if (nodeCursor.disabled) break;\n        if (visitedKeys.has(nodeCursor.key)) break;else {\n          visitedKeys.add(nodeCursor.key);\n        }\n        nodeCursor = nodeCursor.parent;\n      }\n    }\n  });\n  return visitedKeys;\n}\n\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n  const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n  const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n  const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n  const keysToRemove = [];\n  extendedCheckedKeySet.forEach(key => {\n    if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n      keysToRemove.push(key);\n    }\n  });\n  keysToRemove.forEach(key => extendedCheckedKeySet.delete(key));\n  return extendedCheckedKeySet;\n}\n\nexport function getCheckedKeys(options, treeMate) {\n  const {\n    checkedKeys,\n    keysToCheck,\n    keysToUncheck,\n    indeterminateKeys,\n    cascade,\n    leafOnly,\n    checkStrategy,\n    allowNotLoaded\n  } = options;\n\n  if (!cascade) {\n    if (keysToCheck !== undefined) {\n      return {\n        checkedKeys: merge(checkedKeys, keysToCheck),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    } else if (keysToUncheck !== undefined) {\n      return {\n        checkedKeys: minus(checkedKeys, keysToUncheck),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    } else {\n      return {\n        checkedKeys: Array.from(checkedKeys),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    }\n  }\n\n  const {\n    levelTreeNodeMap\n  } = treeMate;\n  let extendedCheckedKeySet;\n\n  if (keysToUncheck !== undefined) {\n    extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n  } else if (keysToCheck !== undefined) {\n    extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n  } else {\n    extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n  }\n\n  const checkStrategyIsParent = checkStrategy === 'parent';\n  const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n  const syntheticCheckedKeySet = extendedCheckedKeySet;\n  const syntheticIndeterminateKeySet = new Set();\n  const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys())); // cascade check\n  // 1. if tree is fully loaded, it just works\n  // 2. if the tree is not fully loaded, we assume that keys which is in not\n  //    loaded tree are not in checked keys\n  //    for example:\n  //    a -- b(fully-loaded)   -- c(fully-loaded)\n  //      |- d(partial-loaded) -- ?e(not-loaded)\n  //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n  //    and `a`'s status\n\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const levelIsZero = level === 0; // it should exists, nor it is a bug\n\n    const levelTreeNodes = levelTreeNodeMap.get(level);\n\n    for (const levelTreeNode of levelTreeNodes) {\n      if (levelTreeNode.isLeaf) continue;\n      const {\n        key: levelTreeNodeKey,\n        shallowLoaded\n      } = levelTreeNode;\n\n      if (checkStrategyIsChild && shallowLoaded) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        levelTreeNode.children.forEach(v => {\n          if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {\n            syntheticCheckedKeySet.delete(v.key);\n          }\n        });\n      }\n\n      if (levelTreeNode.disabled || !shallowLoaded) {\n        continue;\n      }\n\n      let fullyChecked = true;\n      let partialChecked = false;\n      let allDisabled = true; // it is shallow loaded, so `children` must exist\n\n      for (const childNode of levelTreeNode.children) {\n        const childKey = childNode.key;\n        if (childNode.disabled) continue;\n        if (allDisabled) allDisabled = false;\n\n        if (syntheticCheckedKeySet.has(childKey)) {\n          partialChecked = true;\n        } else if (syntheticIndeterminateKeySet.has(childKey)) {\n          partialChecked = true;\n          fullyChecked = false;\n          break;\n        } else {\n          fullyChecked = false;\n\n          if (partialChecked) {\n            break;\n          }\n        }\n      }\n\n      if (fullyChecked && !allDisabled) {\n        if (checkStrategyIsParent) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          levelTreeNode.children.forEach(v => {\n            if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n              syntheticCheckedKeySet.delete(v.key);\n            }\n          });\n        }\n\n        syntheticCheckedKeySet.add(levelTreeNodeKey);\n      } else if (partialChecked) {\n        syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n      }\n\n      if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n        syntheticCheckedKeySet.delete(levelTreeNodeKey);\n      }\n    }\n  }\n\n  return {\n    checkedKeys: Array.from(syntheticCheckedKeySet),\n    indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n  };\n} // unchecking is safe when doing cascade uncheck in async mode\n\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n  const {\n    treeNodeMap,\n    getChildren\n  } = treeMate;\n  const visitedKeySet = new Set();\n  const extendedKeySet = new Set(checkedKeys);\n  checkedKeys.forEach(checkedKey => {\n    const checkedTreeNode = treeNodeMap.get(checkedKey);\n\n    if (checkedTreeNode !== undefined) {\n      traverseWithCb(checkedTreeNode, treeNode => {\n        if (treeNode.disabled) {\n          return TRAVERSE_COMMAND.STOP;\n        }\n\n        const {\n          key\n        } = treeNode;\n        if (visitedKeySet.has(key)) return;\n        visitedKeySet.add(key); // Adding keys before loaded check is okay, since if not valid error\n        // would be thrown\n\n        extendedKeySet.add(key);\n\n        if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n          if (isUnchecking) {\n            return TRAVERSE_COMMAND.STOP;\n          } else if (!allowNotLoaded) {\n            throw new SubtreeNotLoadedError();\n          }\n        }\n      });\n    }\n  });\n  return extendedKeySet;\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/treemate/es/check.js"],"names":["isExpilicitlyNotLoaded","merge","minus","traverseWithCb","TRAVERSE_COMMAND","SubtreeNotLoadedError","Error","constructor","message","getExtendedCheckedKeySetAfterCheck","checkKeys","currentCheckedKeys","treeMate","allowNotLoaded","getExtendedCheckedKeySet","concat","getAvailableAscendantNodeSet","uncheckedKeys","visitedKeys","Set","forEach","uncheckedKey","uncheckedTreeNode","treeNodeMap","get","undefined","nodeCursor","parent","disabled","has","key","add","getExtendedCheckedKeySetAfterUncheck","extendedCheckedKeySet","extendedKeySetToUncheck","ascendantKeySet","keysToRemove","push","delete","getCheckedKeys","options","checkedKeys","keysToCheck","keysToUncheck","indeterminateKeys","cascade","leafOnly","checkStrategy","Array","from","levelTreeNodeMap","checkStrategyIsParent","checkStrategyIsChild","syntheticCheckedKeySet","syntheticIndeterminateKeySet","maxLevel","Math","max","apply","keys","level","levelIsZero","levelTreeNodes","levelTreeNode","isLeaf","levelTreeNodeKey","shallowLoaded","children","v","fullyChecked","partialChecked","allDisabled","childNode","childKey","isUnchecking","getChildren","visitedKeySet","extendedKeySet","checkedKey","checkedTreeNode","treeNode","STOP","rawNode"],"mappings":"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","sourcesContent":["import { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n    constructor() {\n        super();\n        this.message =\n            'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n    }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n    const visitedKeys = new Set();\n    uncheckedKeys.forEach((uncheckedKey) => {\n        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n        if (uncheckedTreeNode !== undefined) {\n            let nodeCursor = uncheckedTreeNode.parent;\n            while (nodeCursor !== null) {\n                if (nodeCursor.disabled)\n                    break;\n                if (visitedKeys.has(nodeCursor.key))\n                    break;\n                else {\n                    visitedKeys.add(nodeCursor.key);\n                }\n                nodeCursor = nodeCursor.parent;\n            }\n        }\n    });\n    return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n    const keysToRemove = [];\n    extendedCheckedKeySet.forEach((key) => {\n        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n            keysToRemove.push(key);\n        }\n    });\n    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));\n    return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;\n    if (!cascade) {\n        if (keysToCheck !== undefined) {\n            return {\n                checkedKeys: merge(checkedKeys, keysToCheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else if (keysToUncheck !== undefined) {\n            return {\n                checkedKeys: minus(checkedKeys, keysToUncheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else {\n            return {\n                checkedKeys: Array.from(checkedKeys),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n    }\n    const { levelTreeNodeMap } = treeMate;\n    let extendedCheckedKeySet;\n    if (keysToUncheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else if (keysToCheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else {\n        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n    }\n    const checkStrategyIsParent = checkStrategy === 'parent';\n    const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n    const syntheticCheckedKeySet = extendedCheckedKeySet;\n    const syntheticIndeterminateKeySet = new Set();\n    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n    // cascade check\n    // 1. if tree is fully loaded, it just works\n    // 2. if the tree is not fully loaded, we assume that keys which is in not\n    //    loaded tree are not in checked keys\n    //    for example:\n    //    a -- b(fully-loaded)   -- c(fully-loaded)\n    //      |- d(partial-loaded) -- ?e(not-loaded)\n    //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n    //    and `a`'s status\n    for (let level = maxLevel; level >= 0; level -= 1) {\n        const levelIsZero = level === 0;\n        // it should exists, nor it is a bug\n        const levelTreeNodes = levelTreeNodeMap.get(level);\n        for (const levelTreeNode of levelTreeNodes) {\n            if (levelTreeNode.isLeaf)\n                continue;\n            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;\n            if (checkStrategyIsChild && shallowLoaded) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                levelTreeNode.children.forEach((v) => {\n                    if (!v.disabled &&\n                        !v.isLeaf &&\n                        v.shallowLoaded &&\n                        syntheticCheckedKeySet.has(v.key)) {\n                        syntheticCheckedKeySet.delete(v.key);\n                    }\n                });\n            }\n            if (levelTreeNode.disabled || !shallowLoaded) {\n                continue;\n            }\n            let fullyChecked = true;\n            let partialChecked = false;\n            let allDisabled = true;\n            // it is shallow loaded, so `children` must exist\n            for (const childNode of levelTreeNode.children) {\n                const childKey = childNode.key;\n                if (childNode.disabled)\n                    continue;\n                if (allDisabled)\n                    allDisabled = false;\n                if (syntheticCheckedKeySet.has(childKey)) {\n                    partialChecked = true;\n                }\n                else if (syntheticIndeterminateKeySet.has(childKey)) {\n                    partialChecked = true;\n                    fullyChecked = false;\n                    break;\n                }\n                else {\n                    fullyChecked = false;\n                    if (partialChecked) {\n                        break;\n                    }\n                }\n            }\n            if (fullyChecked && !allDisabled) {\n                if (checkStrategyIsParent) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    levelTreeNode.children.forEach((v) => {\n                        if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n                            syntheticCheckedKeySet.delete(v.key);\n                        }\n                    });\n                }\n                syntheticCheckedKeySet.add(levelTreeNodeKey);\n            }\n            else if (partialChecked) {\n                syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n            }\n            if (levelIsZero &&\n                checkStrategyIsChild &&\n                syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n                syntheticCheckedKeySet.delete(levelTreeNodeKey);\n            }\n        }\n    }\n    return {\n        checkedKeys: Array.from(syntheticCheckedKeySet),\n        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n    };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n    const { treeNodeMap, getChildren } = treeMate;\n    const visitedKeySet = new Set();\n    const extendedKeySet = new Set(checkedKeys);\n    checkedKeys.forEach((checkedKey) => {\n        const checkedTreeNode = treeNodeMap.get(checkedKey);\n        if (checkedTreeNode !== undefined) {\n            traverseWithCb(checkedTreeNode, (treeNode) => {\n                if (treeNode.disabled) {\n                    return TRAVERSE_COMMAND.STOP;\n                }\n                const { key } = treeNode;\n                if (visitedKeySet.has(key))\n                    return;\n                visitedKeySet.add(key);\n                // Adding keys before loaded check is okay, since if not valid error\n                // would be thrown\n                extendedKeySet.add(key);\n                if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n                    if (isUnchecking) {\n                        return TRAVERSE_COMMAND.STOP;\n                    }\n                    else if (!allowNotLoaded) {\n                        throw new SubtreeNotLoadedError();\n                    }\n                }\n            });\n        }\n    });\n    return extendedKeySet;\n}\n"]},"metadata":{},"sourceType":"module"}