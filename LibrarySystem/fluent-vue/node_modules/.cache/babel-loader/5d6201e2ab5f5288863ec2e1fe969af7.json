{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { DOM } from \"../dom\";\nimport { PropertyChangeNotifier, SubscriberSet } from \"./notifier\";\nimport { FAST } from \"../platform\";\n/**\n * Common Observable APIs.\n * @public\n */\n\nexport const Observable = FAST.getById(2\n/* observable */\n, () => {\n  const volatileRegex = /(:|&&|\\|\\||if)/;\n  const notifierLookup = new WeakMap();\n  const accessorLookup = new WeakMap();\n  const queueUpdate = DOM.queueUpdate;\n  let watcher = void 0;\n\n  let createArrayObserver = array => {\n    throw new Error(\"Must call enableArrayObservation before observing arrays.\");\n  };\n\n  function getNotifier(source) {\n    let found = source.$fastController || notifierLookup.get(source);\n\n    if (found === void 0) {\n      if (Array.isArray(source)) {\n        found = createArrayObserver(source);\n      } else {\n        notifierLookup.set(source, found = new PropertyChangeNotifier(source));\n      }\n    }\n\n    return found;\n  }\n\n  function getAccessors(target) {\n    let accessors = accessorLookup.get(target);\n\n    if (accessors === void 0) {\n      let currentTarget = Reflect.getPrototypeOf(target);\n\n      while (accessors === void 0 && currentTarget !== null) {\n        accessors = accessorLookup.get(currentTarget);\n        currentTarget = Reflect.getPrototypeOf(currentTarget);\n      }\n\n      if (accessors === void 0) {\n        accessors = [];\n      } else {\n        accessors = accessors.slice(0);\n      }\n\n      accessorLookup.set(target, accessors);\n    }\n\n    return accessors;\n  }\n\n  class DefaultObservableAccessor {\n    constructor(name) {\n      this.name = name;\n      this.field = `_${name}`;\n      this.callback = `${name}Changed`;\n    }\n\n    getValue(source) {\n      if (watcher !== void 0) {\n        watcher.watch(source, this.name);\n      }\n\n      return source[this.field];\n    }\n\n    setValue(source, newValue) {\n      const field = this.field;\n      const oldValue = source[field];\n\n      if (oldValue !== newValue) {\n        source[field] = newValue;\n        const callback = source[this.callback];\n\n        if (typeof callback === \"function\") {\n          callback.call(source, oldValue, newValue);\n        }\n\n        getNotifier(source).notify(this.name);\n      }\n    }\n\n  }\n\n  class BindingObserverImplementation extends SubscriberSet {\n    constructor(binding, initialSubscriber, isVolatileBinding = false) {\n      super(binding, initialSubscriber);\n      this.binding = binding;\n      this.isVolatileBinding = isVolatileBinding;\n      this.needsRefresh = true;\n      this.needsQueue = true;\n      this.first = this;\n      this.last = null;\n      this.propertySource = void 0;\n      this.propertyName = void 0;\n      this.notifier = void 0;\n      this.next = void 0;\n    }\n\n    observe(source, context) {\n      if (this.needsRefresh && this.last !== null) {\n        this.disconnect();\n      }\n\n      const previousWatcher = watcher;\n      watcher = this.needsRefresh ? this : void 0;\n      this.needsRefresh = this.isVolatileBinding;\n      const result = this.binding(source, context);\n      watcher = previousWatcher;\n      return result;\n    }\n\n    disconnect() {\n      if (this.last !== null) {\n        let current = this.first;\n\n        while (current !== void 0) {\n          current.notifier.unsubscribe(this, current.propertyName);\n          current = current.next;\n        }\n\n        this.last = null;\n        this.needsRefresh = this.needsQueue = true;\n      }\n    }\n\n    watch(propertySource, propertyName) {\n      const prev = this.last;\n      const notifier = getNotifier(propertySource);\n      const current = prev === null ? this.first : {};\n      current.propertySource = propertySource;\n      current.propertyName = propertyName;\n      current.notifier = notifier;\n      notifier.subscribe(this, propertyName);\n\n      if (prev !== null) {\n        if (!this.needsRefresh) {\n          // Declaring the variable prior to assignment below circumvents\n          // a bug in Angular's optimization process causing infinite recursion\n          // of this watch() method. Details https://github.com/microsoft/fast/issues/4969\n          let prevValue;\n          watcher = void 0;\n          /* eslint-disable-next-line */\n\n          prevValue = prev.propertySource[prev.propertyName];\n          watcher = this;\n\n          if (propertySource === prevValue) {\n            this.needsRefresh = true;\n          }\n        }\n\n        prev.next = current;\n      }\n\n      this.last = current;\n    }\n\n    handleChange() {\n      if (this.needsQueue) {\n        this.needsQueue = false;\n        queueUpdate(this);\n      }\n    }\n\n    call() {\n      if (this.last !== null) {\n        this.needsQueue = true;\n        this.notify(this);\n      }\n    }\n\n    records() {\n      let next = this.first;\n      return {\n        next: () => {\n          const current = next;\n\n          if (current === undefined) {\n            return {\n              value: void 0,\n              done: true\n            };\n          } else {\n            next = next.next;\n            return {\n              value: current,\n              done: false\n            };\n          }\n        },\n        [Symbol.iterator]: function () {\n          return this;\n        }\n      };\n    }\n\n  }\n\n  return Object.freeze({\n    /**\n     * @internal\n     * @param factory - The factory used to create array observers.\n     */\n    setArrayObserverFactory(factory) {\n      createArrayObserver = factory;\n    },\n\n    /**\n     * Gets a notifier for an object or Array.\n     * @param source - The object or Array to get the notifier for.\n     */\n    getNotifier,\n\n    /**\n     * Records a property change for a source object.\n     * @param source - The object to record the change against.\n     * @param propertyName - The property to track as changed.\n     */\n    track(source, propertyName) {\n      if (watcher !== void 0) {\n        watcher.watch(source, propertyName);\n      }\n    },\n\n    /**\n     * Notifies watchers that the currently executing property getter or function is volatile\n     * with respect to its observable dependencies.\n     */\n    trackVolatile() {\n      if (watcher !== void 0) {\n        watcher.needsRefresh = true;\n      }\n    },\n\n    /**\n     * Notifies subscribers of a source object of changes.\n     * @param source - the object to notify of changes.\n     * @param args - The change args to pass to subscribers.\n     */\n    notify(source, args) {\n      getNotifier(source).notify(args);\n    },\n\n    /**\n     * Defines an observable property on an object or prototype.\n     * @param target - The target object to define the observable on.\n     * @param nameOrAccessor - The name of the property to define as observable;\n     * or a custom accessor that specifies the property name and accessor implementation.\n     */\n    defineProperty(target, nameOrAccessor) {\n      if (typeof nameOrAccessor === \"string\") {\n        nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);\n      }\n\n      getAccessors(target).push(nameOrAccessor);\n      Reflect.defineProperty(target, nameOrAccessor.name, {\n        enumerable: true,\n        get: function () {\n          return nameOrAccessor.getValue(this);\n        },\n        set: function (newValue) {\n          nameOrAccessor.setValue(this, newValue);\n        }\n      });\n    },\n\n    /**\n     * Finds all the observable accessors defined on the target,\n     * including its prototype chain.\n     * @param target - The target object to search for accessor on.\n     */\n    getAccessors,\n\n    /**\n     * Creates a {@link BindingObserver} that can watch the\n     * provided {@link Binding} for changes.\n     * @param binding - The binding to observe.\n     * @param initialSubscriber - An initial subscriber to changes in the binding value.\n     * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.\n     */\n    binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {\n      return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);\n    },\n\n    /**\n     * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated\n     * on every evaluation of the value.\n     * @param binding - The binding to inspect.\n     */\n    isVolatileBinding(binding) {\n      return volatileRegex.test(binding.toString());\n    }\n\n  });\n});\n/**\n * Decorator: Defines an observable property on the target.\n * @param target - The target to define the observable on.\n * @param nameOrAccessor - The property name or accessor to define the observable as.\n * @public\n */\n\nexport function observable(target, nameOrAccessor) {\n  Observable.defineProperty(target, nameOrAccessor);\n}\n/**\n * Decorator: Marks a property getter as having volatile observable dependencies.\n * @param target - The target that the property is defined on.\n * @param name - The property name.\n * @param name - The existing descriptor.\n * @public\n */\n\nexport function volatile(target, name, descriptor) {\n  return Object.assign({}, descriptor, {\n    get: function () {\n      Observable.trackVolatile();\n      return descriptor.get.apply(this);\n    }\n  });\n}\nconst contextEvent = FAST.getById(3\n/* contextEvent */\n, () => {\n  let current = null;\n  return {\n    get() {\n      return current;\n    },\n\n    set(event) {\n      current = event;\n    }\n\n  };\n});\n/**\n * Provides additional contextual information available to behaviors and expressions.\n * @public\n */\n\nexport class ExecutionContext {\n  constructor() {\n    /**\n     * The index of the current item within a repeat context.\n     */\n    this.index = 0;\n    /**\n     * The length of the current collection within a repeat context.\n     */\n\n    this.length = 0;\n    /**\n     * The parent data object within a repeat context.\n     */\n\n    this.parent = null;\n    /**\n     * The parent execution context when in nested context scenarios.\n     */\n\n    this.parentContext = null;\n  }\n  /**\n   * The current event within an event handler.\n   */\n\n\n  get event() {\n    return contextEvent.get();\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * has an even index.\n   */\n\n\n  get isEven() {\n    return this.index % 2 === 0;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * has an odd index.\n   */\n\n\n  get isOdd() {\n    return this.index % 2 !== 0;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * is the first item in the collection.\n   */\n\n\n  get isFirst() {\n    return this.index === 0;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * is somewhere in the middle of the collection.\n   */\n\n\n  get isInMiddle() {\n    return !this.isFirst && !this.isLast;\n  }\n  /**\n   * Indicates whether the current item within a repeat context\n   * is the last item in the collection.\n   */\n\n\n  get isLast() {\n    return this.index === this.length - 1;\n  }\n  /**\n   * Sets the event for the current execution context.\n   * @param event - The event to set.\n   * @internal\n   */\n\n\n  static setEvent(event) {\n    contextEvent.set(event);\n  }\n\n}\nObservable.defineProperty(ExecutionContext.prototype, \"index\");\nObservable.defineProperty(ExecutionContext.prototype, \"length\");\n/**\n * The default execution context used in binding expressions.\n * @public\n */\n\nexport const defaultExecutionContext = Object.seal(new ExecutionContext());","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-element/dist/esm/observation/observable.js"],"names":["DOM","PropertyChangeNotifier","SubscriberSet","FAST","Observable","getById","volatileRegex","notifierLookup","WeakMap","accessorLookup","queueUpdate","watcher","createArrayObserver","array","Error","getNotifier","source","found","$fastController","get","Array","isArray","set","getAccessors","target","accessors","currentTarget","Reflect","getPrototypeOf","slice","DefaultObservableAccessor","constructor","name","field","callback","getValue","watch","setValue","newValue","oldValue","call","notify","BindingObserverImplementation","binding","initialSubscriber","isVolatileBinding","needsRefresh","needsQueue","first","last","propertySource","propertyName","notifier","next","observe","context","disconnect","previousWatcher","result","current","unsubscribe","prev","subscribe","prevValue","handleChange","records","undefined","value","done","Symbol","iterator","Object","freeze","setArrayObserverFactory","factory","track","trackVolatile","args","defineProperty","nameOrAccessor","push","enumerable","test","toString","observable","volatile","descriptor","assign","apply","contextEvent","event","ExecutionContext","index","length","parent","parentContext","isEven","isOdd","isFirst","isInMiddle","isLast","setEvent","prototype","defaultExecutionContext","seal"],"mappings":"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","sourcesContent":["import { DOM } from \"../dom\";\nimport { PropertyChangeNotifier, SubscriberSet } from \"./notifier\";\nimport { FAST } from \"../platform\";\n/**\n * Common Observable APIs.\n * @public\n */\nexport const Observable = FAST.getById(2 /* observable */, () => {\n    const volatileRegex = /(:|&&|\\|\\||if)/;\n    const notifierLookup = new WeakMap();\n    const accessorLookup = new WeakMap();\n    const queueUpdate = DOM.queueUpdate;\n    let watcher = void 0;\n    let createArrayObserver = (array) => {\n        throw new Error(\"Must call enableArrayObservation before observing arrays.\");\n    };\n    function getNotifier(source) {\n        let found = source.$fastController || notifierLookup.get(source);\n        if (found === void 0) {\n            if (Array.isArray(source)) {\n                found = createArrayObserver(source);\n            }\n            else {\n                notifierLookup.set(source, (found = new PropertyChangeNotifier(source)));\n            }\n        }\n        return found;\n    }\n    function getAccessors(target) {\n        let accessors = accessorLookup.get(target);\n        if (accessors === void 0) {\n            let currentTarget = Reflect.getPrototypeOf(target);\n            while (accessors === void 0 && currentTarget !== null) {\n                accessors = accessorLookup.get(currentTarget);\n                currentTarget = Reflect.getPrototypeOf(currentTarget);\n            }\n            if (accessors === void 0) {\n                accessors = [];\n            }\n            else {\n                accessors = accessors.slice(0);\n            }\n            accessorLookup.set(target, accessors);\n        }\n        return accessors;\n    }\n    class DefaultObservableAccessor {\n        constructor(name) {\n            this.name = name;\n            this.field = `_${name}`;\n            this.callback = `${name}Changed`;\n        }\n        getValue(source) {\n            if (watcher !== void 0) {\n                watcher.watch(source, this.name);\n            }\n            return source[this.field];\n        }\n        setValue(source, newValue) {\n            const field = this.field;\n            const oldValue = source[field];\n            if (oldValue !== newValue) {\n                source[field] = newValue;\n                const callback = source[this.callback];\n                if (typeof callback === \"function\") {\n                    callback.call(source, oldValue, newValue);\n                }\n                getNotifier(source).notify(this.name);\n            }\n        }\n    }\n    class BindingObserverImplementation extends SubscriberSet {\n        constructor(binding, initialSubscriber, isVolatileBinding = false) {\n            super(binding, initialSubscriber);\n            this.binding = binding;\n            this.isVolatileBinding = isVolatileBinding;\n            this.needsRefresh = true;\n            this.needsQueue = true;\n            this.first = this;\n            this.last = null;\n            this.propertySource = void 0;\n            this.propertyName = void 0;\n            this.notifier = void 0;\n            this.next = void 0;\n        }\n        observe(source, context) {\n            if (this.needsRefresh && this.last !== null) {\n                this.disconnect();\n            }\n            const previousWatcher = watcher;\n            watcher = this.needsRefresh ? this : void 0;\n            this.needsRefresh = this.isVolatileBinding;\n            const result = this.binding(source, context);\n            watcher = previousWatcher;\n            return result;\n        }\n        disconnect() {\n            if (this.last !== null) {\n                let current = this.first;\n                while (current !== void 0) {\n                    current.notifier.unsubscribe(this, current.propertyName);\n                    current = current.next;\n                }\n                this.last = null;\n                this.needsRefresh = this.needsQueue = true;\n            }\n        }\n        watch(propertySource, propertyName) {\n            const prev = this.last;\n            const notifier = getNotifier(propertySource);\n            const current = prev === null ? this.first : {};\n            current.propertySource = propertySource;\n            current.propertyName = propertyName;\n            current.notifier = notifier;\n            notifier.subscribe(this, propertyName);\n            if (prev !== null) {\n                if (!this.needsRefresh) {\n                    // Declaring the variable prior to assignment below circumvents\n                    // a bug in Angular's optimization process causing infinite recursion\n                    // of this watch() method. Details https://github.com/microsoft/fast/issues/4969\n                    let prevValue;\n                    watcher = void 0;\n                    /* eslint-disable-next-line */\n                    prevValue = prev.propertySource[prev.propertyName];\n                    watcher = this;\n                    if (propertySource === prevValue) {\n                        this.needsRefresh = true;\n                    }\n                }\n                prev.next = current;\n            }\n            this.last = current;\n        }\n        handleChange() {\n            if (this.needsQueue) {\n                this.needsQueue = false;\n                queueUpdate(this);\n            }\n        }\n        call() {\n            if (this.last !== null) {\n                this.needsQueue = true;\n                this.notify(this);\n            }\n        }\n        records() {\n            let next = this.first;\n            return {\n                next: () => {\n                    const current = next;\n                    if (current === undefined) {\n                        return { value: void 0, done: true };\n                    }\n                    else {\n                        next = next.next;\n                        return {\n                            value: current,\n                            done: false,\n                        };\n                    }\n                },\n                [Symbol.iterator]: function () {\n                    return this;\n                },\n            };\n        }\n    }\n    return Object.freeze({\n        /**\n         * @internal\n         * @param factory - The factory used to create array observers.\n         */\n        setArrayObserverFactory(factory) {\n            createArrayObserver = factory;\n        },\n        /**\n         * Gets a notifier for an object or Array.\n         * @param source - The object or Array to get the notifier for.\n         */\n        getNotifier,\n        /**\n         * Records a property change for a source object.\n         * @param source - The object to record the change against.\n         * @param propertyName - The property to track as changed.\n         */\n        track(source, propertyName) {\n            if (watcher !== void 0) {\n                watcher.watch(source, propertyName);\n            }\n        },\n        /**\n         * Notifies watchers that the currently executing property getter or function is volatile\n         * with respect to its observable dependencies.\n         */\n        trackVolatile() {\n            if (watcher !== void 0) {\n                watcher.needsRefresh = true;\n            }\n        },\n        /**\n         * Notifies subscribers of a source object of changes.\n         * @param source - the object to notify of changes.\n         * @param args - The change args to pass to subscribers.\n         */\n        notify(source, args) {\n            getNotifier(source).notify(args);\n        },\n        /**\n         * Defines an observable property on an object or prototype.\n         * @param target - The target object to define the observable on.\n         * @param nameOrAccessor - The name of the property to define as observable;\n         * or a custom accessor that specifies the property name and accessor implementation.\n         */\n        defineProperty(target, nameOrAccessor) {\n            if (typeof nameOrAccessor === \"string\") {\n                nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);\n            }\n            getAccessors(target).push(nameOrAccessor);\n            Reflect.defineProperty(target, nameOrAccessor.name, {\n                enumerable: true,\n                get: function () {\n                    return nameOrAccessor.getValue(this);\n                },\n                set: function (newValue) {\n                    nameOrAccessor.setValue(this, newValue);\n                },\n            });\n        },\n        /**\n         * Finds all the observable accessors defined on the target,\n         * including its prototype chain.\n         * @param target - The target object to search for accessor on.\n         */\n        getAccessors,\n        /**\n         * Creates a {@link BindingObserver} that can watch the\n         * provided {@link Binding} for changes.\n         * @param binding - The binding to observe.\n         * @param initialSubscriber - An initial subscriber to changes in the binding value.\n         * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.\n         */\n        binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {\n            return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);\n        },\n        /**\n         * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated\n         * on every evaluation of the value.\n         * @param binding - The binding to inspect.\n         */\n        isVolatileBinding(binding) {\n            return volatileRegex.test(binding.toString());\n        },\n    });\n});\n/**\n * Decorator: Defines an observable property on the target.\n * @param target - The target to define the observable on.\n * @param nameOrAccessor - The property name or accessor to define the observable as.\n * @public\n */\nexport function observable(target, nameOrAccessor) {\n    Observable.defineProperty(target, nameOrAccessor);\n}\n/**\n * Decorator: Marks a property getter as having volatile observable dependencies.\n * @param target - The target that the property is defined on.\n * @param name - The property name.\n * @param name - The existing descriptor.\n * @public\n */\nexport function volatile(target, name, descriptor) {\n    return Object.assign({}, descriptor, {\n        get: function () {\n            Observable.trackVolatile();\n            return descriptor.get.apply(this);\n        },\n    });\n}\nconst contextEvent = FAST.getById(3 /* contextEvent */, () => {\n    let current = null;\n    return {\n        get() {\n            return current;\n        },\n        set(event) {\n            current = event;\n        },\n    };\n});\n/**\n * Provides additional contextual information available to behaviors and expressions.\n * @public\n */\nexport class ExecutionContext {\n    constructor() {\n        /**\n         * The index of the current item within a repeat context.\n         */\n        this.index = 0;\n        /**\n         * The length of the current collection within a repeat context.\n         */\n        this.length = 0;\n        /**\n         * The parent data object within a repeat context.\n         */\n        this.parent = null;\n        /**\n         * The parent execution context when in nested context scenarios.\n         */\n        this.parentContext = null;\n    }\n    /**\n     * The current event within an event handler.\n     */\n    get event() {\n        return contextEvent.get();\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an even index.\n     */\n    get isEven() {\n        return this.index % 2 === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * has an odd index.\n     */\n    get isOdd() {\n        return this.index % 2 !== 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the first item in the collection.\n     */\n    get isFirst() {\n        return this.index === 0;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is somewhere in the middle of the collection.\n     */\n    get isInMiddle() {\n        return !this.isFirst && !this.isLast;\n    }\n    /**\n     * Indicates whether the current item within a repeat context\n     * is the last item in the collection.\n     */\n    get isLast() {\n        return this.index === this.length - 1;\n    }\n    /**\n     * Sets the event for the current execution context.\n     * @param event - The event to set.\n     * @internal\n     */\n    static setEvent(event) {\n        contextEvent.set(event);\n    }\n}\nObservable.defineProperty(ExecutionContext.prototype, \"index\");\nObservable.defineProperty(ExecutionContext.prototype, \"length\");\n/**\n * The default execution context used in binding expressions.\n * @public\n */\nexport const defaultExecutionContext = Object.seal(new ExecutionContext());\n"]},"metadata":{},"sourceType":"module"}