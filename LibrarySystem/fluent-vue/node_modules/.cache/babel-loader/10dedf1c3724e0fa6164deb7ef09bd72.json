{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { __decorate } from \"tslib\";\nimport { CSSDirective, defaultExecutionContext, FASTElement, observable, Observable } from \"@microsoft/fast-element\";\nimport { composedParent } from \"../utilities\";\nimport { composedContains } from \"../utilities/composed-contains\";\nimport { PropertyTargetManager, RootStyleSheetTarget } from \"./custom-property-manager\";\nimport { defaultElement } from \"./custom-property-manager\";\n/**\n * Implementation of {@link (DesignToken:interface)}\n */\n\nclass DesignTokenImpl extends CSSDirective {\n  constructor(configuration) {\n    super();\n    this.subscribers = new WeakMap();\n    this._appliedTo = new Set();\n    this.name = configuration.name;\n\n    if (configuration.cssCustomPropertyName !== null) {\n      this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;\n      this.cssVar = `var(${this.cssCustomProperty})`;\n    }\n\n    this.id = DesignTokenImpl.uniqueId();\n    DesignTokenImpl.tokensById.set(this.id, this);\n  }\n\n  get appliedTo() {\n    return [...this._appliedTo];\n  }\n\n  static from(nameOrConfig) {\n    return new DesignTokenImpl({\n      name: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.name,\n      cssCustomPropertyName: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.cssCustomPropertyName === void 0 ? nameOrConfig.name : nameOrConfig.cssCustomPropertyName\n    });\n  }\n\n  static isCSSDesignToken(token) {\n    return typeof token.cssCustomProperty === \"string\";\n  }\n\n  static isDerivedDesignTokenValue(value) {\n    return typeof value === \"function\";\n  }\n  /**\n   * Gets a token by ID. Returns undefined if the token was not found.\n   * @param id - The ID of the token\n   * @returns\n   */\n\n\n  static getTokenById(id) {\n    return DesignTokenImpl.tokensById.get(id);\n  }\n\n  getOrCreateSubscriberSet(target = this) {\n    return this.subscribers.get(target) || this.subscribers.set(target, new Set()) && this.subscribers.get(target);\n  }\n\n  createCSS() {\n    return this.cssVar || \"\";\n  }\n\n  getValueFor(element) {\n    const value = DesignTokenNode.getOrCreate(element).get(this);\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    throw new Error(`Value could not be retrieved for token named \"${this.name}\". Ensure the value is set for ${element} or an ancestor of ${element}.`);\n  }\n\n  setValueFor(element, value) {\n    this._appliedTo.add(element);\n\n    if (value instanceof DesignTokenImpl) {\n      value = this.alias(value);\n    }\n\n    DesignTokenNode.getOrCreate(element).set(this, value);\n    return this;\n  }\n\n  deleteValueFor(element) {\n    this._appliedTo.delete(element);\n\n    if (DesignTokenNode.existsFor(element)) {\n      DesignTokenNode.getOrCreate(element).delete(this);\n    }\n\n    return this;\n  }\n\n  withDefault(value) {\n    this.setValueFor(defaultElement, value);\n    return this;\n  }\n\n  subscribe(subscriber, target) {\n    const subscriberSet = this.getOrCreateSubscriberSet(target);\n\n    if (target && !DesignTokenNode.existsFor(target)) {\n      DesignTokenNode.getOrCreate(target);\n    }\n\n    if (!subscriberSet.has(subscriber)) {\n      subscriberSet.add(subscriber);\n    }\n  }\n\n  unsubscribe(subscriber, target) {\n    const list = this.subscribers.get(target || this);\n\n    if (list && list.has(subscriber)) {\n      list.delete(subscriber);\n    }\n  }\n  /**\n   * Notifies subscribers that the value for an element has changed.\n   * @param element - The element to emit a notification for\n   */\n\n\n  notify(element) {\n    const record = Object.freeze({\n      token: this,\n      target: element\n    });\n\n    if (this.subscribers.has(this)) {\n      this.subscribers.get(this).forEach(sub => sub.handleChange(record));\n    }\n\n    if (this.subscribers.has(element)) {\n      this.subscribers.get(element).forEach(sub => sub.handleChange(record));\n    }\n  }\n  /**\n   * Alias the token to the provided token.\n   * @param token - the token to alias to\n   */\n\n\n  alias(token) {\n    return target => token.getValueFor(target);\n  }\n\n}\n\nDesignTokenImpl.uniqueId = (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(16);\n  };\n})();\n/**\n * Token storage by token ID\n */\n\n\nDesignTokenImpl.tokensById = new Map();\n\nclass CustomPropertyReflector {\n  startReflection(token, target) {\n    token.subscribe(this, target);\n    this.handleChange({\n      token,\n      target\n    });\n  }\n\n  stopReflection(token, target) {\n    token.unsubscribe(this, target);\n    this.remove(token, target);\n  }\n\n  handleChange(record) {\n    const {\n      token,\n      target\n    } = record;\n    this.add(token, target);\n  }\n\n  add(token, target) {\n    PropertyTargetManager.getOrCreate(target).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target).get(token)));\n  }\n\n  remove(token, target) {\n    PropertyTargetManager.getOrCreate(target).removeProperty(token.cssCustomProperty);\n  }\n\n  resolveCSSValue(value) {\n    return value && typeof value.createCSS === \"function\" ? value.createCSS() : value;\n  }\n\n}\n/**\n * A light wrapper around BindingObserver to handle value caching and\n * token notification\n */\n\n\nclass DesignTokenBindingObserver {\n  constructor(source, token, node) {\n    this.source = source;\n    this.token = token;\n    this.node = node;\n    this.dependencies = new Set();\n    this.observer = Observable.binding(source, this, false); // This is a little bit hacky because it's using internal APIs of BindingObserverImpl.\n    // BindingObserverImpl queues updates to batch it's notifications which doesn't work for this\n    // scenario because the DesignToken.getValueFor API is not async. Without this, using DesignToken.getValueFor()\n    // after DesignToken.setValueFor() when setting a dependency of the value being retrieved can return a stale\n    // value. Assigning .handleChange to .call forces immediate invocation of this classes handleChange() method,\n    // allowing resolution of values synchronously.\n    // TODO: https://github.com/microsoft/fast/issues/5110\n\n    this.observer.handleChange = this.observer.call;\n    this.handleChange();\n  }\n\n  disconnect() {\n    this.observer.disconnect();\n  }\n  /**\n   * @internal\n   */\n\n\n  handleChange() {\n    this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));\n  }\n\n}\n/**\n * Stores resolved token/value pairs and notifies on changes\n */\n\n\nclass Store {\n  constructor() {\n    this.values = new Map();\n  }\n\n  set(token, value) {\n    if (this.values.get(token) !== value) {\n      this.values.set(token, value);\n      Observable.getNotifier(this).notify(token.id);\n    }\n  }\n\n  get(token) {\n    Observable.track(this, token.id);\n    return this.values.get(token);\n  }\n\n  delete(token) {\n    this.values.delete(token);\n  }\n\n  all() {\n    return this.values.entries();\n  }\n\n}\n\nconst nodeCache = new WeakMap();\nconst childToParent = new WeakMap();\n/**\n * A node responsible for setting and getting token values,\n * emitting values to CSS custom properties, and maintaining\n * inheritance structures.\n */\n\nclass DesignTokenNode {\n  constructor(target) {\n    this.target = target;\n    /**\n     * Stores all resolved token values for a node\n     */\n\n    this.store = new Store();\n    /**\n     * All children assigned to the node\n     */\n\n    this.children = [];\n    /**\n     * All values explicitly assigned to the node in their raw form\n     */\n\n    this.assignedValues = new Map();\n    /**\n     * Tokens currently being reflected to CSS custom properties\n     */\n\n    this.reflecting = new Set();\n    /**\n     * Binding observers for assigned and inherited derived values.\n     */\n\n    this.bindingObservers = new Map();\n    /**\n     * Emits notifications to token when token values\n     * change the DesignTokenNode\n     */\n\n    this.tokenValueChangeHandler = {\n      handleChange: (source, arg) => {\n        const token = DesignTokenImpl.getTokenById(arg);\n\n        if (token) {\n          // Notify any token subscribers\n          token.notify(this.target);\n\n          if (DesignTokenImpl.isCSSDesignToken(token)) {\n            const parent = this.parent;\n            const reflecting = this.isReflecting(token);\n\n            if (parent) {\n              const parentValue = parent.get(token);\n              const sourceValue = source.get(token);\n\n              if (parentValue !== sourceValue && !reflecting) {\n                this.reflectToCSS(token);\n              } else if (parentValue === sourceValue && reflecting) {\n                this.stopReflectToCSS(token);\n              }\n            } else if (!reflecting) {\n              this.reflectToCSS(token);\n            }\n          }\n        }\n      }\n    };\n    nodeCache.set(target, this); // Map store change notifications to token change notifications\n\n    Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);\n\n    if (target instanceof FASTElement) {\n      target.$fastController.addBehaviors([this]);\n    } else if (target.isConnected) {\n      this.bind();\n    }\n  }\n  /**\n   * Returns a DesignTokenNode for an element.\n   * Creates a new instance if one does not already exist for a node,\n   * otherwise returns the cached instance\n   *\n   * @param target - The HTML element to retrieve a DesignTokenNode for\n   */\n\n\n  static getOrCreate(target) {\n    return nodeCache.get(target) || new DesignTokenNode(target);\n  }\n  /**\n   * Determines if a DesignTokenNode has been created for a target\n   * @param target - The element to test\n   */\n\n\n  static existsFor(target) {\n    return nodeCache.has(target);\n  }\n  /**\n   * Searches for and return the nearest parent DesignTokenNode.\n   * Null is returned if no node is found or the node provided is for a default element.\n   */\n\n\n  static findParent(node) {\n    if (!(defaultElement === node.target)) {\n      let parent = composedParent(node.target);\n\n      while (parent !== null) {\n        if (nodeCache.has(parent)) {\n          return nodeCache.get(parent);\n        }\n\n        parent = composedParent(parent);\n      }\n\n      return DesignTokenNode.getOrCreate(defaultElement);\n    }\n\n    return null;\n  }\n  /**\n   * Finds the closest node with a value explicitly assigned for a token, otherwise null.\n   * @param token - The token to look for\n   * @param start - The node to start looking for value assignment\n   * @returns\n   */\n\n\n  static findClosestAssignedNode(token, start) {\n    let current = start;\n\n    do {\n      if (current.has(token)) {\n        return current;\n      }\n\n      current = current.parent ? current.parent : current.target !== defaultElement ? DesignTokenNode.getOrCreate(defaultElement) : null;\n    } while (current !== null);\n\n    return null;\n  }\n  /**\n   * The parent DesignTokenNode, or null.\n   */\n\n\n  get parent() {\n    return childToParent.get(this) || null;\n  }\n  /**\n   * Checks if a token has been assigned an explicit value the node.\n   * @param token - the token to check.\n   */\n\n\n  has(token) {\n    return this.assignedValues.has(token);\n  }\n  /**\n   * Gets the value of a token for a node\n   * @param token - The token to retrieve the value for\n   * @returns\n   */\n\n\n  get(token) {\n    const value = this.store.get(token);\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    const raw = this.getRaw(token);\n\n    if (raw !== undefined) {\n      this.hydrate(token, raw);\n      return this.get(token);\n    }\n  }\n  /**\n   * Retrieves the raw assigned value of a token from the nearest assigned node.\n   * @param token - The token to retrieve a raw value for\n   * @returns\n   */\n\n\n  getRaw(token) {\n    var _a;\n\n    if (this.assignedValues.has(token)) {\n      return this.assignedValues.get(token);\n    }\n\n    return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);\n  }\n  /**\n   * Sets a token to a value for a node\n   * @param token - The token to set\n   * @param value - The value to set the token to\n   */\n\n\n  set(token, value) {\n    if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {\n      this.tearDownBindingObserver(token);\n    }\n\n    this.assignedValues.set(token, value);\n\n    if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n      this.setupBindingObserver(token, value);\n    } else {\n      this.store.set(token, value);\n    }\n  }\n  /**\n   * Deletes a token value for the node.\n   * @param token - The token to delete the value for\n   */\n\n\n  delete(token) {\n    this.assignedValues.delete(token);\n    this.tearDownBindingObserver(token);\n    const upstream = this.getRaw(token);\n\n    if (upstream) {\n      this.hydrate(token, upstream);\n    } else {\n      this.store.delete(token);\n    }\n  }\n  /**\n   * Invoked when the DesignTokenNode.target is attached to the document\n   */\n\n\n  bind() {\n    const parent = DesignTokenNode.findParent(this);\n\n    if (parent) {\n      parent.appendChild(this);\n    }\n\n    for (const key of this.assignedValues.keys()) {\n      key.notify(this.target);\n    }\n  }\n  /**\n   * Invoked when the DesignTokenNode.target is detached from the document\n   */\n\n\n  unbind() {\n    if (this.parent) {\n      const parent = childToParent.get(this);\n      parent.removeChild(this);\n    }\n  }\n  /**\n   * Appends a child to a parent DesignTokenNode.\n   * @param child - The child to append to the node\n   */\n\n\n  appendChild(child) {\n    if (child.parent) {\n      childToParent.get(child).removeChild(child);\n    }\n\n    const reParent = this.children.filter(x => child.contains(x));\n    childToParent.set(child, this);\n    this.children.push(child);\n    reParent.forEach(x => child.appendChild(x));\n    Observable.getNotifier(this.store).subscribe(child); // How can we not notify *every* subscriber?\n\n    for (const [token, value] of this.store.all()) {\n      child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);\n    }\n  }\n  /**\n   * Removes a child from a node.\n   * @param child - The child to remove.\n   */\n\n\n  removeChild(child) {\n    const childIndex = this.children.indexOf(child);\n\n    if (childIndex !== -1) {\n      this.children.splice(childIndex, 1);\n    }\n\n    Observable.getNotifier(this.store).unsubscribe(child);\n    return child.parent === this ? childToParent.delete(child) : false;\n  }\n  /**\n   * Tests whether a provided node is contained by\n   * the calling node.\n   * @param test - The node to test\n   */\n\n\n  contains(test) {\n    return composedContains(this.target, test.target);\n  }\n  /**\n   * Instructs the node to reflect a design token for the provided token.\n   * @param token - The design token to reflect\n   */\n\n\n  reflectToCSS(token) {\n    if (!this.isReflecting(token)) {\n      this.reflecting.add(token);\n      DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);\n    }\n  }\n  /**\n   * Stops reflecting a DesignToken to CSS\n   * @param token - The design token to stop reflecting\n   */\n\n\n  stopReflectToCSS(token) {\n    if (this.isReflecting(token)) {\n      this.reflecting.delete(token);\n      DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);\n    }\n  }\n  /**\n   * Determines if a token is being reflected to CSS for a node.\n   * @param token - The token to check for reflection\n   * @returns\n   */\n\n\n  isReflecting(token) {\n    return this.reflecting.has(token);\n  }\n  /**\n   * Handle changes to upstream tokens\n   * @param source - The parent DesignTokenNode\n   * @param property - The token ID that changed\n   */\n\n\n  handleChange(source, property) {\n    const token = DesignTokenImpl.getTokenById(property);\n\n    if (!token) {\n      return;\n    }\n\n    this.hydrate(token, this.getRaw(token));\n  }\n  /**\n   * Hydrates a token with a DesignTokenValue, making retrieval available.\n   * @param token - The token to hydrate\n   * @param value - The value to hydrate\n   */\n\n\n  hydrate(token, value) {\n    if (!this.has(token)) {\n      const observer = this.bindingObservers.get(token);\n\n      if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n        if (observer) {\n          // If the binding source doesn't match, we need\n          // to update the binding\n          if (observer.source !== value) {\n            this.tearDownBindingObserver(token);\n            this.setupBindingObserver(token, value);\n          }\n        } else {\n          this.setupBindingObserver(token, value);\n        }\n      } else {\n        if (observer) {\n          this.tearDownBindingObserver(token);\n        }\n\n        this.store.set(token, value);\n      }\n    }\n  }\n  /**\n   * Sets up a binding observer for a derived token value that notifies token\n   * subscribers on change.\n   *\n   * @param token - The token to notify when the binding updates\n   * @param source - The binding source\n   */\n\n\n  setupBindingObserver(token, source) {\n    const binding = new DesignTokenBindingObserver(source, token, this);\n    this.bindingObservers.set(token, binding);\n    return binding;\n  }\n  /**\n   * Tear down a binding observer for a token.\n   */\n\n\n  tearDownBindingObserver(token) {\n    if (this.bindingObservers.has(token)) {\n      this.bindingObservers.get(token).disconnect();\n      this.bindingObservers.delete(token);\n      return true;\n    }\n\n    return false;\n  }\n\n}\n/**\n * Responsible for reflecting tokens to CSS custom properties\n */\n\n\nDesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();\n\n__decorate([observable], DesignTokenNode.prototype, \"children\", void 0);\n\nfunction create(nameOrConfig) {\n  return DesignTokenImpl.from(nameOrConfig);\n}\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\n/**\n * Factory object for creating {@link (DesignToken:interface)} instances.\n * @public\n */\n\n\nexport const DesignToken = Object.freeze({\n  create,\n\n  /**\n   * Informs DesignToken that an HTMLElement for which tokens have\n   * been set has been connected to the document.\n   *\n   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n   * in all scenarios, so invoking this method manually is necessary when:\n   *\n   * 1. Token values are set for an HTMLElement.\n   * 2. The HTMLElement does not inherit from FASTElement.\n   * 3. The HTMLElement is not connected to the document when token values are set.\n   *\n   * @param element - The element to notify\n   * @returns - true if notification was successful, otherwise false.\n   */\n  notifyConnection(element) {\n    if (!element.isConnected || !DesignTokenNode.existsFor(element)) {\n      return false;\n    }\n\n    DesignTokenNode.getOrCreate(element).bind();\n    return true;\n  },\n\n  /**\n   * Informs DesignToken that an HTMLElement for which tokens have\n   * been set has been disconnected to the document.\n   *\n   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n   * in all scenarios, so invoking this method manually is necessary when:\n   *\n   * 1. Token values are set for an HTMLElement.\n   * 2. The HTMLElement does not inherit from FASTElement.\n   *\n   * @param element - The element to notify\n   * @returns - true if notification was successful, otherwise false.\n   */\n  notifyDisconnection(element) {\n    if (element.isConnected || !DesignTokenNode.existsFor(element)) {\n      return false;\n    }\n\n    DesignTokenNode.getOrCreate(element).unbind();\n    return true;\n  },\n\n  /**\n   * Registers and element or document as a DesignToken root.\n   * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via\n   * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all\n   * registered roots.\n   * @param target - The root to register\n   */\n  registerRoot(target = defaultElement) {\n    RootStyleSheetTarget.registerRoot(target);\n  },\n\n  /**\n   * Unregister an element or document as a DesignToken root.\n   * @param target - The root to deregister\n   */\n  unregisterRoot(target = defaultElement) {\n    RootStyleSheetTarget.unregisterRoot(target);\n  }\n\n});\n/* eslint-enable @typescript-eslint/no-non-null-assertion */","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/design-token/design-token.js"],"names":["__decorate","CSSDirective","defaultExecutionContext","FASTElement","observable","Observable","composedParent","composedContains","PropertyTargetManager","RootStyleSheetTarget","defaultElement","DesignTokenImpl","constructor","configuration","subscribers","WeakMap","_appliedTo","Set","name","cssCustomPropertyName","cssCustomProperty","cssVar","id","uniqueId","tokensById","set","appliedTo","from","nameOrConfig","isCSSDesignToken","token","isDerivedDesignTokenValue","value","getTokenById","get","getOrCreateSubscriberSet","target","createCSS","getValueFor","element","DesignTokenNode","getOrCreate","undefined","Error","setValueFor","add","alias","deleteValueFor","delete","existsFor","withDefault","subscribe","subscriber","subscriberSet","has","unsubscribe","list","notify","record","Object","freeze","forEach","sub","handleChange","toString","Map","CustomPropertyReflector","startReflection","stopReflection","remove","setProperty","resolveCSSValue","removeProperty","DesignTokenBindingObserver","source","node","dependencies","observer","binding","call","disconnect","store","observe","Store","values","getNotifier","track","all","entries","nodeCache","childToParent","children","assignedValues","reflecting","bindingObservers","tokenValueChangeHandler","arg","parent","isReflecting","parentValue","sourceValue","reflectToCSS","stopReflectToCSS","$fastController","addBehaviors","isConnected","bind","findParent","findClosestAssignedNode","start","current","raw","getRaw","hydrate","_a","tearDownBindingObserver","setupBindingObserver","upstream","appendChild","key","keys","unbind","removeChild","child","reParent","filter","x","contains","push","childIndex","indexOf","splice","test","cssCustomPropertyReflector","property","prototype","create","DesignToken","notifyConnection","notifyDisconnection","registerRoot","unregisterRoot"],"mappings":";AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,YAAT,EAAuBC,uBAAvB,EAAgDC,WAAhD,EAA6DC,UAA7D,EAAyEC,UAAzE,QAA4F,yBAA5F;AACA,SAASC,cAAT,QAA+B,cAA/B;AACA,SAASC,gBAAT,QAAiC,gCAAjC;AACA,SAASC,qBAAT,EAAgCC,oBAAhC,QAA4D,2BAA5D;AACA,SAASC,cAAT,QAA+B,2BAA/B;AACA;AACA;AACA;;AACA,MAAMC,eAAN,SAA8BV,YAA9B,CAA2C;AACvCW,EAAAA,WAAW,CAACC,aAAD,EAAgB;AACvB;AACA,SAAKC,WAAL,GAAmB,IAAIC,OAAJ,EAAnB;AACA,SAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AACA,SAAKC,IAAL,GAAYL,aAAa,CAACK,IAA1B;;AACA,QAAIL,aAAa,CAACM,qBAAd,KAAwC,IAA5C,EAAkD;AAC9C,WAAKC,iBAAL,GAA0B,KAAIP,aAAa,CAACM,qBAAsB,EAAlE;AACA,WAAKE,MAAL,GAAe,OAAM,KAAKD,iBAAkB,GAA5C;AACH;;AACD,SAAKE,EAAL,GAAUX,eAAe,CAACY,QAAhB,EAAV;AACAZ,IAAAA,eAAe,CAACa,UAAhB,CAA2BC,GAA3B,CAA+B,KAAKH,EAApC,EAAwC,IAAxC;AACH;;AACY,MAATI,SAAS,GAAG;AACZ,WAAO,CAAC,GAAG,KAAKV,UAAT,CAAP;AACH;;AACU,SAAJW,IAAI,CAACC,YAAD,EAAe;AACtB,WAAO,IAAIjB,eAAJ,CAAoB;AACvBO,MAAAA,IAAI,EAAE,OAAOU,YAAP,KAAwB,QAAxB,GAAmCA,YAAnC,GAAkDA,YAAY,CAACV,IAD9C;AAEvBC,MAAAA,qBAAqB,EAAE,OAAOS,YAAP,KAAwB,QAAxB,GACjBA,YADiB,GAEjBA,YAAY,CAACT,qBAAb,KAAuC,KAAK,CAA5C,GACIS,YAAY,CAACV,IADjB,GAEIU,YAAY,CAACT;AANA,KAApB,CAAP;AAQH;;AACsB,SAAhBU,gBAAgB,CAACC,KAAD,EAAQ;AAC3B,WAAO,OAAOA,KAAK,CAACV,iBAAb,KAAmC,QAA1C;AACH;;AAC+B,SAAzBW,yBAAyB,CAACC,KAAD,EAAQ;AACpC,WAAO,OAAOA,KAAP,KAAiB,UAAxB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACuB,SAAZC,YAAY,CAACX,EAAD,EAAK;AACpB,WAAOX,eAAe,CAACa,UAAhB,CAA2BU,GAA3B,CAA+BZ,EAA/B,CAAP;AACH;;AACDa,EAAAA,wBAAwB,CAACC,MAAM,GAAG,IAAV,EAAgB;AACpC,WAAQ,KAAKtB,WAAL,CAAiBoB,GAAjB,CAAqBE,MAArB,KACH,KAAKtB,WAAL,CAAiBW,GAAjB,CAAqBW,MAArB,EAA6B,IAAInB,GAAJ,EAA7B,KAA2C,KAAKH,WAAL,CAAiBoB,GAAjB,CAAqBE,MAArB,CADhD;AAEH;;AACDC,EAAAA,SAAS,GAAG;AACR,WAAO,KAAKhB,MAAL,IAAe,EAAtB;AACH;;AACDiB,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,UAAMP,KAAK,GAAGQ,eAAe,CAACC,WAAhB,CAA4BF,OAA5B,EAAqCL,GAArC,CAAyC,IAAzC,CAAd;;AACA,QAAIF,KAAK,KAAKU,SAAd,EAAyB;AACrB,aAAOV,KAAP;AACH;;AACD,UAAM,IAAIW,KAAJ,CAAW,iDAAgD,KAAKzB,IAAK,kCAAiCqB,OAAQ,sBAAqBA,OAAQ,GAA3I,CAAN;AACH;;AACDK,EAAAA,WAAW,CAACL,OAAD,EAAUP,KAAV,EAAiB;AACxB,SAAKhB,UAAL,CAAgB6B,GAAhB,CAAoBN,OAApB;;AACA,QAAIP,KAAK,YAAYrB,eAArB,EAAsC;AAClCqB,MAAAA,KAAK,GAAG,KAAKc,KAAL,CAAWd,KAAX,CAAR;AACH;;AACDQ,IAAAA,eAAe,CAACC,WAAhB,CAA4BF,OAA5B,EAAqCd,GAArC,CAAyC,IAAzC,EAA+CO,KAA/C;AACA,WAAO,IAAP;AACH;;AACDe,EAAAA,cAAc,CAACR,OAAD,EAAU;AACpB,SAAKvB,UAAL,CAAgBgC,MAAhB,CAAuBT,OAAvB;;AACA,QAAIC,eAAe,CAACS,SAAhB,CAA0BV,OAA1B,CAAJ,EAAwC;AACpCC,MAAAA,eAAe,CAACC,WAAhB,CAA4BF,OAA5B,EAAqCS,MAArC,CAA4C,IAA5C;AACH;;AACD,WAAO,IAAP;AACH;;AACDE,EAAAA,WAAW,CAAClB,KAAD,EAAQ;AACf,SAAKY,WAAL,CAAiBlC,cAAjB,EAAiCsB,KAAjC;AACA,WAAO,IAAP;AACH;;AACDmB,EAAAA,SAAS,CAACC,UAAD,EAAahB,MAAb,EAAqB;AAC1B,UAAMiB,aAAa,GAAG,KAAKlB,wBAAL,CAA8BC,MAA9B,CAAtB;;AACA,QAAIA,MAAM,IAAI,CAACI,eAAe,CAACS,SAAhB,CAA0Bb,MAA1B,CAAf,EAAkD;AAC9CI,MAAAA,eAAe,CAACC,WAAhB,CAA4BL,MAA5B;AACH;;AACD,QAAI,CAACiB,aAAa,CAACC,GAAd,CAAkBF,UAAlB,CAAL,EAAoC;AAChCC,MAAAA,aAAa,CAACR,GAAd,CAAkBO,UAAlB;AACH;AACJ;;AACDG,EAAAA,WAAW,CAACH,UAAD,EAAahB,MAAb,EAAqB;AAC5B,UAAMoB,IAAI,GAAG,KAAK1C,WAAL,CAAiBoB,GAAjB,CAAqBE,MAAM,IAAI,IAA/B,CAAb;;AACA,QAAIoB,IAAI,IAAIA,IAAI,CAACF,GAAL,CAASF,UAAT,CAAZ,EAAkC;AAC9BI,MAAAA,IAAI,CAACR,MAAL,CAAYI,UAAZ;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIK,EAAAA,MAAM,CAAClB,OAAD,EAAU;AACZ,UAAMmB,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAc;AAAE9B,MAAAA,KAAK,EAAE,IAAT;AAAeM,MAAAA,MAAM,EAAEG;AAAvB,KAAd,CAAf;;AACA,QAAI,KAAKzB,WAAL,CAAiBwC,GAAjB,CAAqB,IAArB,CAAJ,EAAgC;AAC5B,WAAKxC,WAAL,CAAiBoB,GAAjB,CAAqB,IAArB,EAA2B2B,OAA3B,CAAmCC,GAAG,IAAIA,GAAG,CAACC,YAAJ,CAAiBL,MAAjB,CAA1C;AACH;;AACD,QAAI,KAAK5C,WAAL,CAAiBwC,GAAjB,CAAqBf,OAArB,CAAJ,EAAmC;AAC/B,WAAKzB,WAAL,CAAiBoB,GAAjB,CAAqBK,OAArB,EAA8BsB,OAA9B,CAAsCC,GAAG,IAAIA,GAAG,CAACC,YAAJ,CAAiBL,MAAjB,CAA7C;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIZ,EAAAA,KAAK,CAAChB,KAAD,EAAQ;AACT,WAASM,MAAD,IAAYN,KAAK,CAACQ,WAAN,CAAkBF,MAAlB,CAApB;AACH;;AA3GsC;;AA6G3CzB,eAAe,CAACY,QAAhB,GAA2B,CAAC,MAAM;AAC9B,MAAID,EAAE,GAAG,CAAT;AACA,SAAO,MAAM;AACTA,IAAAA,EAAE;AACF,WAAOA,EAAE,CAAC0C,QAAH,CAAY,EAAZ,CAAP;AACH,GAHD;AAIH,CAN0B,GAA3B;AAOA;AACA;AACA;;;AACArD,eAAe,CAACa,UAAhB,GAA6B,IAAIyC,GAAJ,EAA7B;;AACA,MAAMC,uBAAN,CAA8B;AAC1BC,EAAAA,eAAe,CAACrC,KAAD,EAAQM,MAAR,EAAgB;AAC3BN,IAAAA,KAAK,CAACqB,SAAN,CAAgB,IAAhB,EAAsBf,MAAtB;AACA,SAAK2B,YAAL,CAAkB;AAAEjC,MAAAA,KAAF;AAASM,MAAAA;AAAT,KAAlB;AACH;;AACDgC,EAAAA,cAAc,CAACtC,KAAD,EAAQM,MAAR,EAAgB;AAC1BN,IAAAA,KAAK,CAACyB,WAAN,CAAkB,IAAlB,EAAwBnB,MAAxB;AACA,SAAKiC,MAAL,CAAYvC,KAAZ,EAAmBM,MAAnB;AACH;;AACD2B,EAAAA,YAAY,CAACL,MAAD,EAAS;AACjB,UAAM;AAAE5B,MAAAA,KAAF;AAASM,MAAAA;AAAT,QAAoBsB,MAA1B;AACA,SAAKb,GAAL,CAASf,KAAT,EAAgBM,MAAhB;AACH;;AACDS,EAAAA,GAAG,CAACf,KAAD,EAAQM,MAAR,EAAgB;AACf5B,IAAAA,qBAAqB,CAACiC,WAAtB,CAAkCL,MAAlC,EAA0CkC,WAA1C,CAAsDxC,KAAK,CAACV,iBAA5D,EAA+E,KAAKmD,eAAL,CAAqB/B,eAAe,CAACC,WAAhB,CAA4BL,MAA5B,EAAoCF,GAApC,CAAwCJ,KAAxC,CAArB,CAA/E;AACH;;AACDuC,EAAAA,MAAM,CAACvC,KAAD,EAAQM,MAAR,EAAgB;AAClB5B,IAAAA,qBAAqB,CAACiC,WAAtB,CAAkCL,MAAlC,EAA0CoC,cAA1C,CAAyD1C,KAAK,CAACV,iBAA/D;AACH;;AACDmD,EAAAA,eAAe,CAACvC,KAAD,EAAQ;AACnB,WAAOA,KAAK,IAAI,OAAOA,KAAK,CAACK,SAAb,KAA2B,UAApC,GAAiDL,KAAK,CAACK,SAAN,EAAjD,GAAqEL,KAA5E;AACH;;AArByB;AAuB9B;AACA;AACA;AACA;;;AACA,MAAMyC,0BAAN,CAAiC;AAC7B7D,EAAAA,WAAW,CAAC8D,MAAD,EAAS5C,KAAT,EAAgB6C,IAAhB,EAAsB;AAC7B,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAK5C,KAAL,GAAaA,KAAb;AACA,SAAK6C,IAAL,GAAYA,IAAZ;AACA,SAAKC,YAAL,GAAoB,IAAI3D,GAAJ,EAApB;AACA,SAAK4D,QAAL,GAAgBxE,UAAU,CAACyE,OAAX,CAAmBJ,MAAnB,EAA2B,IAA3B,EAAiC,KAAjC,CAAhB,CAL6B,CAM7B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAKG,QAAL,CAAcd,YAAd,GAA6B,KAAKc,QAAL,CAAcE,IAA3C;AACA,SAAKhB,YAAL;AACH;;AACDiB,EAAAA,UAAU,GAAG;AACT,SAAKH,QAAL,CAAcG,UAAd;AACH;AACD;AACJ;AACA;;;AACIjB,EAAAA,YAAY,GAAG;AACX,SAAKY,IAAL,CAAUM,KAAV,CAAgBxD,GAAhB,CAAoB,KAAKK,KAAzB,EAAgC,KAAK+C,QAAL,CAAcK,OAAd,CAAsB,KAAKP,IAAL,CAAUvC,MAAhC,EAAwClC,uBAAxC,CAAhC;AACH;;AAzB4B;AA2BjC;AACA;AACA;;;AACA,MAAMiF,KAAN,CAAY;AACRvE,EAAAA,WAAW,GAAG;AACV,SAAKwE,MAAL,GAAc,IAAInB,GAAJ,EAAd;AACH;;AACDxC,EAAAA,GAAG,CAACK,KAAD,EAAQE,KAAR,EAAe;AACd,QAAI,KAAKoD,MAAL,CAAYlD,GAAZ,CAAgBJ,KAAhB,MAA2BE,KAA/B,EAAsC;AAClC,WAAKoD,MAAL,CAAY3D,GAAZ,CAAgBK,KAAhB,EAAuBE,KAAvB;AACA3B,MAAAA,UAAU,CAACgF,WAAX,CAAuB,IAAvB,EAA6B5B,MAA7B,CAAoC3B,KAAK,CAACR,EAA1C;AACH;AACJ;;AACDY,EAAAA,GAAG,CAACJ,KAAD,EAAQ;AACPzB,IAAAA,UAAU,CAACiF,KAAX,CAAiB,IAAjB,EAAuBxD,KAAK,CAACR,EAA7B;AACA,WAAO,KAAK8D,MAAL,CAAYlD,GAAZ,CAAgBJ,KAAhB,CAAP;AACH;;AACDkB,EAAAA,MAAM,CAAClB,KAAD,EAAQ;AACV,SAAKsD,MAAL,CAAYpC,MAAZ,CAAmBlB,KAAnB;AACH;;AACDyD,EAAAA,GAAG,GAAG;AACF,WAAO,KAAKH,MAAL,CAAYI,OAAZ,EAAP;AACH;;AAnBO;;AAqBZ,MAAMC,SAAS,GAAG,IAAI1E,OAAJ,EAAlB;AACA,MAAM2E,aAAa,GAAG,IAAI3E,OAAJ,EAAtB;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMyB,eAAN,CAAsB;AAClB5B,EAAAA,WAAW,CAACwB,MAAD,EAAS;AAChB,SAAKA,MAAL,GAAcA,MAAd;AACA;AACR;AACA;;AACQ,SAAK6C,KAAL,GAAa,IAAIE,KAAJ,EAAb;AACA;AACR;AACA;;AACQ,SAAKQ,QAAL,GAAgB,EAAhB;AACA;AACR;AACA;;AACQ,SAAKC,cAAL,GAAsB,IAAI3B,GAAJ,EAAtB;AACA;AACR;AACA;;AACQ,SAAK4B,UAAL,GAAkB,IAAI5E,GAAJ,EAAlB;AACA;AACR;AACA;;AACQ,SAAK6E,gBAAL,GAAwB,IAAI7B,GAAJ,EAAxB;AACA;AACR;AACA;AACA;;AACQ,SAAK8B,uBAAL,GAA+B;AAC3BhC,MAAAA,YAAY,EAAE,CAACW,MAAD,EAASsB,GAAT,KAAiB;AAC3B,cAAMlE,KAAK,GAAGnB,eAAe,CAACsB,YAAhB,CAA6B+D,GAA7B,CAAd;;AACA,YAAIlE,KAAJ,EAAW;AACP;AACAA,UAAAA,KAAK,CAAC2B,MAAN,CAAa,KAAKrB,MAAlB;;AACA,cAAIzB,eAAe,CAACkB,gBAAhB,CAAiCC,KAAjC,CAAJ,EAA6C;AACzC,kBAAMmE,MAAM,GAAG,KAAKA,MAApB;AACA,kBAAMJ,UAAU,GAAG,KAAKK,YAAL,CAAkBpE,KAAlB,CAAnB;;AACA,gBAAImE,MAAJ,EAAY;AACR,oBAAME,WAAW,GAAGF,MAAM,CAAC/D,GAAP,CAAWJ,KAAX,CAApB;AACA,oBAAMsE,WAAW,GAAG1B,MAAM,CAACxC,GAAP,CAAWJ,KAAX,CAApB;;AACA,kBAAIqE,WAAW,KAAKC,WAAhB,IAA+B,CAACP,UAApC,EAAgD;AAC5C,qBAAKQ,YAAL,CAAkBvE,KAAlB;AACH,eAFD,MAGK,IAAIqE,WAAW,KAAKC,WAAhB,IAA+BP,UAAnC,EAA+C;AAChD,qBAAKS,gBAAL,CAAsBxE,KAAtB;AACH;AACJ,aATD,MAUK,IAAI,CAAC+D,UAAL,EAAiB;AAClB,mBAAKQ,YAAL,CAAkBvE,KAAlB;AACH;AACJ;AACJ;AACJ;AAxB0B,KAA/B;AA0BA2D,IAAAA,SAAS,CAAChE,GAAV,CAAcW,MAAd,EAAsB,IAAtB,EApDgB,CAqDhB;;AACA/B,IAAAA,UAAU,CAACgF,WAAX,CAAuB,KAAKJ,KAA5B,EAAmC9B,SAAnC,CAA6C,KAAK4C,uBAAlD;;AACA,QAAI3D,MAAM,YAAYjC,WAAtB,EAAmC;AAC/BiC,MAAAA,MAAM,CAACmE,eAAP,CAAuBC,YAAvB,CAAoC,CAAC,IAAD,CAApC;AACH,KAFD,MAGK,IAAIpE,MAAM,CAACqE,WAAX,EAAwB;AACzB,WAAKC,IAAL;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACsB,SAAXjE,WAAW,CAACL,MAAD,EAAS;AACvB,WAAOqD,SAAS,CAACvD,GAAV,CAAcE,MAAd,KAAyB,IAAII,eAAJ,CAAoBJ,MAApB,CAAhC;AACH;AACD;AACJ;AACA;AACA;;;AACoB,SAATa,SAAS,CAACb,MAAD,EAAS;AACrB,WAAOqD,SAAS,CAACnC,GAAV,CAAclB,MAAd,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACqB,SAAVuE,UAAU,CAAChC,IAAD,EAAO;AACpB,QAAI,EAAEjE,cAAc,KAAKiE,IAAI,CAACvC,MAA1B,CAAJ,EAAuC;AACnC,UAAI6D,MAAM,GAAG3F,cAAc,CAACqE,IAAI,CAACvC,MAAN,CAA3B;;AACA,aAAO6D,MAAM,KAAK,IAAlB,EAAwB;AACpB,YAAIR,SAAS,CAACnC,GAAV,CAAc2C,MAAd,CAAJ,EAA2B;AACvB,iBAAOR,SAAS,CAACvD,GAAV,CAAc+D,MAAd,CAAP;AACH;;AACDA,QAAAA,MAAM,GAAG3F,cAAc,CAAC2F,MAAD,CAAvB;AACH;;AACD,aAAOzD,eAAe,CAACC,WAAhB,CAA4B/B,cAA5B,CAAP;AACH;;AACD,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACkC,SAAvBkG,uBAAuB,CAAC9E,KAAD,EAAQ+E,KAAR,EAAe;AACzC,QAAIC,OAAO,GAAGD,KAAd;;AACA,OAAG;AACC,UAAIC,OAAO,CAACxD,GAAR,CAAYxB,KAAZ,CAAJ,EAAwB;AACpB,eAAOgF,OAAP;AACH;;AACDA,MAAAA,OAAO,GAAGA,OAAO,CAACb,MAAR,GACJa,OAAO,CAACb,MADJ,GAEJa,OAAO,CAAC1E,MAAR,KAAmB1B,cAAnB,GACI8B,eAAe,CAACC,WAAhB,CAA4B/B,cAA5B,CADJ,GAEI,IAJV;AAKH,KATD,QASSoG,OAAO,KAAK,IATrB;;AAUA,WAAO,IAAP;AACH;AACD;AACJ;AACA;;;AACc,MAANb,MAAM,GAAG;AACT,WAAOP,aAAa,CAACxD,GAAd,CAAkB,IAAlB,KAA2B,IAAlC;AACH;AACD;AACJ;AACA;AACA;;;AACIoB,EAAAA,GAAG,CAACxB,KAAD,EAAQ;AACP,WAAO,KAAK8D,cAAL,CAAoBtC,GAApB,CAAwBxB,KAAxB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACII,EAAAA,GAAG,CAACJ,KAAD,EAAQ;AACP,UAAME,KAAK,GAAG,KAAKiD,KAAL,CAAW/C,GAAX,CAAeJ,KAAf,CAAd;;AACA,QAAIE,KAAK,KAAKU,SAAd,EAAyB;AACrB,aAAOV,KAAP;AACH;;AACD,UAAM+E,GAAG,GAAG,KAAKC,MAAL,CAAYlF,KAAZ,CAAZ;;AACA,QAAIiF,GAAG,KAAKrE,SAAZ,EAAuB;AACnB,WAAKuE,OAAL,CAAanF,KAAb,EAAoBiF,GAApB;AACA,aAAO,KAAK7E,GAAL,CAASJ,KAAT,CAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIkF,EAAAA,MAAM,CAAClF,KAAD,EAAQ;AACV,QAAIoF,EAAJ;;AACA,QAAI,KAAKtB,cAAL,CAAoBtC,GAApB,CAAwBxB,KAAxB,CAAJ,EAAoC;AAChC,aAAO,KAAK8D,cAAL,CAAoB1D,GAApB,CAAwBJ,KAAxB,CAAP;AACH;;AACD,WAAO,CAACoF,EAAE,GAAG1E,eAAe,CAACoE,uBAAhB,CAAwC9E,KAAxC,EAA+C,IAA/C,CAAN,MAAgE,IAAhE,IAAwEoF,EAAE,KAAK,KAAK,CAApF,GAAwF,KAAK,CAA7F,GAAiGA,EAAE,CAACF,MAAH,CAAUlF,KAAV,CAAxG;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIL,EAAAA,GAAG,CAACK,KAAD,EAAQE,KAAR,EAAe;AACd,QAAIrB,eAAe,CAACoB,yBAAhB,CAA0C,KAAK6D,cAAL,CAAoB1D,GAApB,CAAwBJ,KAAxB,CAA1C,CAAJ,EAA+E;AAC3E,WAAKqF,uBAAL,CAA6BrF,KAA7B;AACH;;AACD,SAAK8D,cAAL,CAAoBnE,GAApB,CAAwBK,KAAxB,EAA+BE,KAA/B;;AACA,QAAIrB,eAAe,CAACoB,yBAAhB,CAA0CC,KAA1C,CAAJ,EAAsD;AAClD,WAAKoF,oBAAL,CAA0BtF,KAA1B,EAAiCE,KAAjC;AACH,KAFD,MAGK;AACD,WAAKiD,KAAL,CAAWxD,GAAX,CAAeK,KAAf,EAAsBE,KAAtB;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIgB,EAAAA,MAAM,CAAClB,KAAD,EAAQ;AACV,SAAK8D,cAAL,CAAoB5C,MAApB,CAA2BlB,KAA3B;AACA,SAAKqF,uBAAL,CAA6BrF,KAA7B;AACA,UAAMuF,QAAQ,GAAG,KAAKL,MAAL,CAAYlF,KAAZ,CAAjB;;AACA,QAAIuF,QAAJ,EAAc;AACV,WAAKJ,OAAL,CAAanF,KAAb,EAAoBuF,QAApB;AACH,KAFD,MAGK;AACD,WAAKpC,KAAL,CAAWjC,MAAX,CAAkBlB,KAAlB;AACH;AACJ;AACD;AACJ;AACA;;;AACI4E,EAAAA,IAAI,GAAG;AACH,UAAMT,MAAM,GAAGzD,eAAe,CAACmE,UAAhB,CAA2B,IAA3B,CAAf;;AACA,QAAIV,MAAJ,EAAY;AACRA,MAAAA,MAAM,CAACqB,WAAP,CAAmB,IAAnB;AACH;;AACD,SAAK,MAAMC,GAAX,IAAkB,KAAK3B,cAAL,CAAoB4B,IAApB,EAAlB,EAA8C;AAC1CD,MAAAA,GAAG,CAAC9D,MAAJ,CAAW,KAAKrB,MAAhB;AACH;AACJ;AACD;AACJ;AACA;;;AACIqF,EAAAA,MAAM,GAAG;AACL,QAAI,KAAKxB,MAAT,EAAiB;AACb,YAAMA,MAAM,GAAGP,aAAa,CAACxD,GAAd,CAAkB,IAAlB,CAAf;AACA+D,MAAAA,MAAM,CAACyB,WAAP,CAAmB,IAAnB;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIJ,EAAAA,WAAW,CAACK,KAAD,EAAQ;AACf,QAAIA,KAAK,CAAC1B,MAAV,EAAkB;AACdP,MAAAA,aAAa,CAACxD,GAAd,CAAkByF,KAAlB,EAAyBD,WAAzB,CAAqCC,KAArC;AACH;;AACD,UAAMC,QAAQ,GAAG,KAAKjC,QAAL,CAAckC,MAAd,CAAqBC,CAAC,IAAIH,KAAK,CAACI,QAAN,CAAeD,CAAf,CAA1B,CAAjB;AACApC,IAAAA,aAAa,CAACjE,GAAd,CAAkBkG,KAAlB,EAAyB,IAAzB;AACA,SAAKhC,QAAL,CAAcqC,IAAd,CAAmBL,KAAnB;AACAC,IAAAA,QAAQ,CAAC/D,OAAT,CAAiBiE,CAAC,IAAIH,KAAK,CAACL,WAAN,CAAkBQ,CAAlB,CAAtB;AACAzH,IAAAA,UAAU,CAACgF,WAAX,CAAuB,KAAKJ,KAA5B,EAAmC9B,SAAnC,CAA6CwE,KAA7C,EARe,CASf;;AACA,SAAK,MAAM,CAAC7F,KAAD,EAAQE,KAAR,CAAX,IAA6B,KAAKiD,KAAL,CAAWM,GAAX,EAA7B,EAA+C;AAC3CoC,MAAAA,KAAK,CAACV,OAAN,CAAcnF,KAAd,EAAqB,KAAKgE,gBAAL,CAAsBxC,GAAtB,CAA0BxB,KAA1B,IAAmC,KAAKkF,MAAL,CAAYlF,KAAZ,CAAnC,GAAwDE,KAA7E;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACI0F,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMM,UAAU,GAAG,KAAKtC,QAAL,CAAcuC,OAAd,CAAsBP,KAAtB,CAAnB;;AACA,QAAIM,UAAU,KAAK,CAAC,CAApB,EAAuB;AACnB,WAAKtC,QAAL,CAAcwC,MAAd,CAAqBF,UAArB,EAAiC,CAAjC;AACH;;AACD5H,IAAAA,UAAU,CAACgF,WAAX,CAAuB,KAAKJ,KAA5B,EAAmC1B,WAAnC,CAA+CoE,KAA/C;AACA,WAAOA,KAAK,CAAC1B,MAAN,KAAiB,IAAjB,GAAwBP,aAAa,CAAC1C,MAAd,CAAqB2E,KAArB,CAAxB,GAAsD,KAA7D;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACII,EAAAA,QAAQ,CAACK,IAAD,EAAO;AACX,WAAO7H,gBAAgB,CAAC,KAAK6B,MAAN,EAAcgG,IAAI,CAAChG,MAAnB,CAAvB;AACH;AACD;AACJ;AACA;AACA;;;AACIiE,EAAAA,YAAY,CAACvE,KAAD,EAAQ;AAChB,QAAI,CAAC,KAAKoE,YAAL,CAAkBpE,KAAlB,CAAL,EAA+B;AAC3B,WAAK+D,UAAL,CAAgBhD,GAAhB,CAAoBf,KAApB;AACAU,MAAAA,eAAe,CAAC6F,0BAAhB,CAA2ClE,eAA3C,CAA2DrC,KAA3D,EAAkE,KAAKM,MAAvE;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIkE,EAAAA,gBAAgB,CAACxE,KAAD,EAAQ;AACpB,QAAI,KAAKoE,YAAL,CAAkBpE,KAAlB,CAAJ,EAA8B;AAC1B,WAAK+D,UAAL,CAAgB7C,MAAhB,CAAuBlB,KAAvB;AACAU,MAAAA,eAAe,CAAC6F,0BAAhB,CAA2CjE,cAA3C,CAA0DtC,KAA1D,EAAiE,KAAKM,MAAtE;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACI8D,EAAAA,YAAY,CAACpE,KAAD,EAAQ;AAChB,WAAO,KAAK+D,UAAL,CAAgBvC,GAAhB,CAAoBxB,KAApB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIiC,EAAAA,YAAY,CAACW,MAAD,EAAS4D,QAAT,EAAmB;AAC3B,UAAMxG,KAAK,GAAGnB,eAAe,CAACsB,YAAhB,CAA6BqG,QAA7B,CAAd;;AACA,QAAI,CAACxG,KAAL,EAAY;AACR;AACH;;AACD,SAAKmF,OAAL,CAAanF,KAAb,EAAoB,KAAKkF,MAAL,CAAYlF,KAAZ,CAApB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACImF,EAAAA,OAAO,CAACnF,KAAD,EAAQE,KAAR,EAAe;AAClB,QAAI,CAAC,KAAKsB,GAAL,CAASxB,KAAT,CAAL,EAAsB;AAClB,YAAM+C,QAAQ,GAAG,KAAKiB,gBAAL,CAAsB5D,GAAtB,CAA0BJ,KAA1B,CAAjB;;AACA,UAAInB,eAAe,CAACoB,yBAAhB,CAA0CC,KAA1C,CAAJ,EAAsD;AAClD,YAAI6C,QAAJ,EAAc;AACV;AACA;AACA,cAAIA,QAAQ,CAACH,MAAT,KAAoB1C,KAAxB,EAA+B;AAC3B,iBAAKmF,uBAAL,CAA6BrF,KAA7B;AACA,iBAAKsF,oBAAL,CAA0BtF,KAA1B,EAAiCE,KAAjC;AACH;AACJ,SAPD,MAQK;AACD,eAAKoF,oBAAL,CAA0BtF,KAA1B,EAAiCE,KAAjC;AACH;AACJ,OAZD,MAaK;AACD,YAAI6C,QAAJ,EAAc;AACV,eAAKsC,uBAAL,CAA6BrF,KAA7B;AACH;;AACD,aAAKmD,KAAL,CAAWxD,GAAX,CAAeK,KAAf,EAAsBE,KAAtB;AACH;AACJ;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIoF,EAAAA,oBAAoB,CAACtF,KAAD,EAAQ4C,MAAR,EAAgB;AAChC,UAAMI,OAAO,GAAG,IAAIL,0BAAJ,CAA+BC,MAA/B,EAAuC5C,KAAvC,EAA8C,IAA9C,CAAhB;AACA,SAAKgE,gBAAL,CAAsBrE,GAAtB,CAA0BK,KAA1B,EAAiCgD,OAAjC;AACA,WAAOA,OAAP;AACH;AACD;AACJ;AACA;;;AACIqC,EAAAA,uBAAuB,CAACrF,KAAD,EAAQ;AAC3B,QAAI,KAAKgE,gBAAL,CAAsBxC,GAAtB,CAA0BxB,KAA1B,CAAJ,EAAsC;AAClC,WAAKgE,gBAAL,CAAsB5D,GAAtB,CAA0BJ,KAA1B,EAAiCkD,UAAjC;AACA,WAAKc,gBAAL,CAAsB9C,MAAtB,CAA6BlB,KAA7B;AACA,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH;;AApViB;AAsVtB;AACA;AACA;;;AACAU,eAAe,CAAC6F,0BAAhB,GAA6C,IAAInE,uBAAJ,EAA7C;;AACAlE,UAAU,CAAC,CACPI,UADO,CAAD,EAEPoC,eAAe,CAAC+F,SAFT,EAEoB,UAFpB,EAEgC,KAAK,CAFrC,CAAV;;AAGA,SAASC,MAAT,CAAgB5G,YAAhB,EAA8B;AAC1B,SAAOjB,eAAe,CAACgB,IAAhB,CAAqBC,YAArB,CAAP;AACH;AACD;;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAM6G,WAAW,GAAG9E,MAAM,CAACC,MAAP,CAAc;AACrC4E,EAAAA,MADqC;;AAErC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIE,EAAAA,gBAAgB,CAACnG,OAAD,EAAU;AACtB,QAAI,CAACA,OAAO,CAACkE,WAAT,IAAwB,CAACjE,eAAe,CAACS,SAAhB,CAA0BV,OAA1B,CAA7B,EAAiE;AAC7D,aAAO,KAAP;AACH;;AACDC,IAAAA,eAAe,CAACC,WAAhB,CAA4BF,OAA5B,EAAqCmE,IAArC;AACA,WAAO,IAAP;AACH,GAtBoC;;AAuBrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIiC,EAAAA,mBAAmB,CAACpG,OAAD,EAAU;AACzB,QAAIA,OAAO,CAACkE,WAAR,IAAuB,CAACjE,eAAe,CAACS,SAAhB,CAA0BV,OAA1B,CAA5B,EAAgE;AAC5D,aAAO,KAAP;AACH;;AACDC,IAAAA,eAAe,CAACC,WAAhB,CAA4BF,OAA5B,EAAqCkF,MAArC;AACA,WAAO,IAAP;AACH,GA1CoC;;AA2CrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACImB,EAAAA,YAAY,CAACxG,MAAM,GAAG1B,cAAV,EAA0B;AAClCD,IAAAA,oBAAoB,CAACmI,YAArB,CAAkCxG,MAAlC;AACH,GApDoC;;AAqDrC;AACJ;AACA;AACA;AACIyG,EAAAA,cAAc,CAACzG,MAAM,GAAG1B,cAAV,EAA0B;AACpCD,IAAAA,oBAAoB,CAACoI,cAArB,CAAoCzG,MAApC;AACH;;AA3DoC,CAAd,CAApB;AA6DP","sourcesContent":["import { __decorate } from \"tslib\";\nimport { CSSDirective, defaultExecutionContext, FASTElement, observable, Observable, } from \"@microsoft/fast-element\";\nimport { composedParent } from \"../utilities\";\nimport { composedContains } from \"../utilities/composed-contains\";\nimport { PropertyTargetManager, RootStyleSheetTarget } from \"./custom-property-manager\";\nimport { defaultElement } from \"./custom-property-manager\";\n/**\n * Implementation of {@link (DesignToken:interface)}\n */\nclass DesignTokenImpl extends CSSDirective {\n    constructor(configuration) {\n        super();\n        this.subscribers = new WeakMap();\n        this._appliedTo = new Set();\n        this.name = configuration.name;\n        if (configuration.cssCustomPropertyName !== null) {\n            this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;\n            this.cssVar = `var(${this.cssCustomProperty})`;\n        }\n        this.id = DesignTokenImpl.uniqueId();\n        DesignTokenImpl.tokensById.set(this.id, this);\n    }\n    get appliedTo() {\n        return [...this._appliedTo];\n    }\n    static from(nameOrConfig) {\n        return new DesignTokenImpl({\n            name: typeof nameOrConfig === \"string\" ? nameOrConfig : nameOrConfig.name,\n            cssCustomPropertyName: typeof nameOrConfig === \"string\"\n                ? nameOrConfig\n                : nameOrConfig.cssCustomPropertyName === void 0\n                    ? nameOrConfig.name\n                    : nameOrConfig.cssCustomPropertyName,\n        });\n    }\n    static isCSSDesignToken(token) {\n        return typeof token.cssCustomProperty === \"string\";\n    }\n    static isDerivedDesignTokenValue(value) {\n        return typeof value === \"function\";\n    }\n    /**\n     * Gets a token by ID. Returns undefined if the token was not found.\n     * @param id - The ID of the token\n     * @returns\n     */\n    static getTokenById(id) {\n        return DesignTokenImpl.tokensById.get(id);\n    }\n    getOrCreateSubscriberSet(target = this) {\n        return (this.subscribers.get(target) ||\n            (this.subscribers.set(target, new Set()) && this.subscribers.get(target)));\n    }\n    createCSS() {\n        return this.cssVar || \"\";\n    }\n    getValueFor(element) {\n        const value = DesignTokenNode.getOrCreate(element).get(this);\n        if (value !== undefined) {\n            return value;\n        }\n        throw new Error(`Value could not be retrieved for token named \"${this.name}\". Ensure the value is set for ${element} or an ancestor of ${element}.`);\n    }\n    setValueFor(element, value) {\n        this._appliedTo.add(element);\n        if (value instanceof DesignTokenImpl) {\n            value = this.alias(value);\n        }\n        DesignTokenNode.getOrCreate(element).set(this, value);\n        return this;\n    }\n    deleteValueFor(element) {\n        this._appliedTo.delete(element);\n        if (DesignTokenNode.existsFor(element)) {\n            DesignTokenNode.getOrCreate(element).delete(this);\n        }\n        return this;\n    }\n    withDefault(value) {\n        this.setValueFor(defaultElement, value);\n        return this;\n    }\n    subscribe(subscriber, target) {\n        const subscriberSet = this.getOrCreateSubscriberSet(target);\n        if (target && !DesignTokenNode.existsFor(target)) {\n            DesignTokenNode.getOrCreate(target);\n        }\n        if (!subscriberSet.has(subscriber)) {\n            subscriberSet.add(subscriber);\n        }\n    }\n    unsubscribe(subscriber, target) {\n        const list = this.subscribers.get(target || this);\n        if (list && list.has(subscriber)) {\n            list.delete(subscriber);\n        }\n    }\n    /**\n     * Notifies subscribers that the value for an element has changed.\n     * @param element - The element to emit a notification for\n     */\n    notify(element) {\n        const record = Object.freeze({ token: this, target: element });\n        if (this.subscribers.has(this)) {\n            this.subscribers.get(this).forEach(sub => sub.handleChange(record));\n        }\n        if (this.subscribers.has(element)) {\n            this.subscribers.get(element).forEach(sub => sub.handleChange(record));\n        }\n    }\n    /**\n     * Alias the token to the provided token.\n     * @param token - the token to alias to\n     */\n    alias(token) {\n        return ((target) => token.getValueFor(target));\n    }\n}\nDesignTokenImpl.uniqueId = (() => {\n    let id = 0;\n    return () => {\n        id++;\n        return id.toString(16);\n    };\n})();\n/**\n * Token storage by token ID\n */\nDesignTokenImpl.tokensById = new Map();\nclass CustomPropertyReflector {\n    startReflection(token, target) {\n        token.subscribe(this, target);\n        this.handleChange({ token, target });\n    }\n    stopReflection(token, target) {\n        token.unsubscribe(this, target);\n        this.remove(token, target);\n    }\n    handleChange(record) {\n        const { token, target } = record;\n        this.add(token, target);\n    }\n    add(token, target) {\n        PropertyTargetManager.getOrCreate(target).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target).get(token)));\n    }\n    remove(token, target) {\n        PropertyTargetManager.getOrCreate(target).removeProperty(token.cssCustomProperty);\n    }\n    resolveCSSValue(value) {\n        return value && typeof value.createCSS === \"function\" ? value.createCSS() : value;\n    }\n}\n/**\n * A light wrapper around BindingObserver to handle value caching and\n * token notification\n */\nclass DesignTokenBindingObserver {\n    constructor(source, token, node) {\n        this.source = source;\n        this.token = token;\n        this.node = node;\n        this.dependencies = new Set();\n        this.observer = Observable.binding(source, this, false);\n        // This is a little bit hacky because it's using internal APIs of BindingObserverImpl.\n        // BindingObserverImpl queues updates to batch it's notifications which doesn't work for this\n        // scenario because the DesignToken.getValueFor API is not async. Without this, using DesignToken.getValueFor()\n        // after DesignToken.setValueFor() when setting a dependency of the value being retrieved can return a stale\n        // value. Assigning .handleChange to .call forces immediate invocation of this classes handleChange() method,\n        // allowing resolution of values synchronously.\n        // TODO: https://github.com/microsoft/fast/issues/5110\n        this.observer.handleChange = this.observer.call;\n        this.handleChange();\n    }\n    disconnect() {\n        this.observer.disconnect();\n    }\n    /**\n     * @internal\n     */\n    handleChange() {\n        this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));\n    }\n}\n/**\n * Stores resolved token/value pairs and notifies on changes\n */\nclass Store {\n    constructor() {\n        this.values = new Map();\n    }\n    set(token, value) {\n        if (this.values.get(token) !== value) {\n            this.values.set(token, value);\n            Observable.getNotifier(this).notify(token.id);\n        }\n    }\n    get(token) {\n        Observable.track(this, token.id);\n        return this.values.get(token);\n    }\n    delete(token) {\n        this.values.delete(token);\n    }\n    all() {\n        return this.values.entries();\n    }\n}\nconst nodeCache = new WeakMap();\nconst childToParent = new WeakMap();\n/**\n * A node responsible for setting and getting token values,\n * emitting values to CSS custom properties, and maintaining\n * inheritance structures.\n */\nclass DesignTokenNode {\n    constructor(target) {\n        this.target = target;\n        /**\n         * Stores all resolved token values for a node\n         */\n        this.store = new Store();\n        /**\n         * All children assigned to the node\n         */\n        this.children = [];\n        /**\n         * All values explicitly assigned to the node in their raw form\n         */\n        this.assignedValues = new Map();\n        /**\n         * Tokens currently being reflected to CSS custom properties\n         */\n        this.reflecting = new Set();\n        /**\n         * Binding observers for assigned and inherited derived values.\n         */\n        this.bindingObservers = new Map();\n        /**\n         * Emits notifications to token when token values\n         * change the DesignTokenNode\n         */\n        this.tokenValueChangeHandler = {\n            handleChange: (source, arg) => {\n                const token = DesignTokenImpl.getTokenById(arg);\n                if (token) {\n                    // Notify any token subscribers\n                    token.notify(this.target);\n                    if (DesignTokenImpl.isCSSDesignToken(token)) {\n                        const parent = this.parent;\n                        const reflecting = this.isReflecting(token);\n                        if (parent) {\n                            const parentValue = parent.get(token);\n                            const sourceValue = source.get(token);\n                            if (parentValue !== sourceValue && !reflecting) {\n                                this.reflectToCSS(token);\n                            }\n                            else if (parentValue === sourceValue && reflecting) {\n                                this.stopReflectToCSS(token);\n                            }\n                        }\n                        else if (!reflecting) {\n                            this.reflectToCSS(token);\n                        }\n                    }\n                }\n            },\n        };\n        nodeCache.set(target, this);\n        // Map store change notifications to token change notifications\n        Observable.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);\n        if (target instanceof FASTElement) {\n            target.$fastController.addBehaviors([this]);\n        }\n        else if (target.isConnected) {\n            this.bind();\n        }\n    }\n    /**\n     * Returns a DesignTokenNode for an element.\n     * Creates a new instance if one does not already exist for a node,\n     * otherwise returns the cached instance\n     *\n     * @param target - The HTML element to retrieve a DesignTokenNode for\n     */\n    static getOrCreate(target) {\n        return nodeCache.get(target) || new DesignTokenNode(target);\n    }\n    /**\n     * Determines if a DesignTokenNode has been created for a target\n     * @param target - The element to test\n     */\n    static existsFor(target) {\n        return nodeCache.has(target);\n    }\n    /**\n     * Searches for and return the nearest parent DesignTokenNode.\n     * Null is returned if no node is found or the node provided is for a default element.\n     */\n    static findParent(node) {\n        if (!(defaultElement === node.target)) {\n            let parent = composedParent(node.target);\n            while (parent !== null) {\n                if (nodeCache.has(parent)) {\n                    return nodeCache.get(parent);\n                }\n                parent = composedParent(parent);\n            }\n            return DesignTokenNode.getOrCreate(defaultElement);\n        }\n        return null;\n    }\n    /**\n     * Finds the closest node with a value explicitly assigned for a token, otherwise null.\n     * @param token - The token to look for\n     * @param start - The node to start looking for value assignment\n     * @returns\n     */\n    static findClosestAssignedNode(token, start) {\n        let current = start;\n        do {\n            if (current.has(token)) {\n                return current;\n            }\n            current = current.parent\n                ? current.parent\n                : current.target !== defaultElement\n                    ? DesignTokenNode.getOrCreate(defaultElement)\n                    : null;\n        } while (current !== null);\n        return null;\n    }\n    /**\n     * The parent DesignTokenNode, or null.\n     */\n    get parent() {\n        return childToParent.get(this) || null;\n    }\n    /**\n     * Checks if a token has been assigned an explicit value the node.\n     * @param token - the token to check.\n     */\n    has(token) {\n        return this.assignedValues.has(token);\n    }\n    /**\n     * Gets the value of a token for a node\n     * @param token - The token to retrieve the value for\n     * @returns\n     */\n    get(token) {\n        const value = this.store.get(token);\n        if (value !== undefined) {\n            return value;\n        }\n        const raw = this.getRaw(token);\n        if (raw !== undefined) {\n            this.hydrate(token, raw);\n            return this.get(token);\n        }\n    }\n    /**\n     * Retrieves the raw assigned value of a token from the nearest assigned node.\n     * @param token - The token to retrieve a raw value for\n     * @returns\n     */\n    getRaw(token) {\n        var _a;\n        if (this.assignedValues.has(token)) {\n            return this.assignedValues.get(token);\n        }\n        return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);\n    }\n    /**\n     * Sets a token to a value for a node\n     * @param token - The token to set\n     * @param value - The value to set the token to\n     */\n    set(token, value) {\n        if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {\n            this.tearDownBindingObserver(token);\n        }\n        this.assignedValues.set(token, value);\n        if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n            this.setupBindingObserver(token, value);\n        }\n        else {\n            this.store.set(token, value);\n        }\n    }\n    /**\n     * Deletes a token value for the node.\n     * @param token - The token to delete the value for\n     */\n    delete(token) {\n        this.assignedValues.delete(token);\n        this.tearDownBindingObserver(token);\n        const upstream = this.getRaw(token);\n        if (upstream) {\n            this.hydrate(token, upstream);\n        }\n        else {\n            this.store.delete(token);\n        }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is attached to the document\n     */\n    bind() {\n        const parent = DesignTokenNode.findParent(this);\n        if (parent) {\n            parent.appendChild(this);\n        }\n        for (const key of this.assignedValues.keys()) {\n            key.notify(this.target);\n        }\n    }\n    /**\n     * Invoked when the DesignTokenNode.target is detached from the document\n     */\n    unbind() {\n        if (this.parent) {\n            const parent = childToParent.get(this);\n            parent.removeChild(this);\n        }\n    }\n    /**\n     * Appends a child to a parent DesignTokenNode.\n     * @param child - The child to append to the node\n     */\n    appendChild(child) {\n        if (child.parent) {\n            childToParent.get(child).removeChild(child);\n        }\n        const reParent = this.children.filter(x => child.contains(x));\n        childToParent.set(child, this);\n        this.children.push(child);\n        reParent.forEach(x => child.appendChild(x));\n        Observable.getNotifier(this.store).subscribe(child);\n        // How can we not notify *every* subscriber?\n        for (const [token, value] of this.store.all()) {\n            child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);\n        }\n    }\n    /**\n     * Removes a child from a node.\n     * @param child - The child to remove.\n     */\n    removeChild(child) {\n        const childIndex = this.children.indexOf(child);\n        if (childIndex !== -1) {\n            this.children.splice(childIndex, 1);\n        }\n        Observable.getNotifier(this.store).unsubscribe(child);\n        return child.parent === this ? childToParent.delete(child) : false;\n    }\n    /**\n     * Tests whether a provided node is contained by\n     * the calling node.\n     * @param test - The node to test\n     */\n    contains(test) {\n        return composedContains(this.target, test.target);\n    }\n    /**\n     * Instructs the node to reflect a design token for the provided token.\n     * @param token - The design token to reflect\n     */\n    reflectToCSS(token) {\n        if (!this.isReflecting(token)) {\n            this.reflecting.add(token);\n            DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);\n        }\n    }\n    /**\n     * Stops reflecting a DesignToken to CSS\n     * @param token - The design token to stop reflecting\n     */\n    stopReflectToCSS(token) {\n        if (this.isReflecting(token)) {\n            this.reflecting.delete(token);\n            DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);\n        }\n    }\n    /**\n     * Determines if a token is being reflected to CSS for a node.\n     * @param token - The token to check for reflection\n     * @returns\n     */\n    isReflecting(token) {\n        return this.reflecting.has(token);\n    }\n    /**\n     * Handle changes to upstream tokens\n     * @param source - The parent DesignTokenNode\n     * @param property - The token ID that changed\n     */\n    handleChange(source, property) {\n        const token = DesignTokenImpl.getTokenById(property);\n        if (!token) {\n            return;\n        }\n        this.hydrate(token, this.getRaw(token));\n    }\n    /**\n     * Hydrates a token with a DesignTokenValue, making retrieval available.\n     * @param token - The token to hydrate\n     * @param value - The value to hydrate\n     */\n    hydrate(token, value) {\n        if (!this.has(token)) {\n            const observer = this.bindingObservers.get(token);\n            if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {\n                if (observer) {\n                    // If the binding source doesn't match, we need\n                    // to update the binding\n                    if (observer.source !== value) {\n                        this.tearDownBindingObserver(token);\n                        this.setupBindingObserver(token, value);\n                    }\n                }\n                else {\n                    this.setupBindingObserver(token, value);\n                }\n            }\n            else {\n                if (observer) {\n                    this.tearDownBindingObserver(token);\n                }\n                this.store.set(token, value);\n            }\n        }\n    }\n    /**\n     * Sets up a binding observer for a derived token value that notifies token\n     * subscribers on change.\n     *\n     * @param token - The token to notify when the binding updates\n     * @param source - The binding source\n     */\n    setupBindingObserver(token, source) {\n        const binding = new DesignTokenBindingObserver(source, token, this);\n        this.bindingObservers.set(token, binding);\n        return binding;\n    }\n    /**\n     * Tear down a binding observer for a token.\n     */\n    tearDownBindingObserver(token) {\n        if (this.bindingObservers.has(token)) {\n            this.bindingObservers.get(token).disconnect();\n            this.bindingObservers.delete(token);\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * Responsible for reflecting tokens to CSS custom properties\n */\nDesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();\n__decorate([\n    observable\n], DesignTokenNode.prototype, \"children\", void 0);\nfunction create(nameOrConfig) {\n    return DesignTokenImpl.from(nameOrConfig);\n}\n/* eslint-enable @typescript-eslint/no-unused-vars */\n/**\n * Factory object for creating {@link (DesignToken:interface)} instances.\n * @public\n */\nexport const DesignToken = Object.freeze({\n    create,\n    /**\n     * Informs DesignToken that an HTMLElement for which tokens have\n     * been set has been connected to the document.\n     *\n     * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n     * in all scenarios, so invoking this method manually is necessary when:\n     *\n     * 1. Token values are set for an HTMLElement.\n     * 2. The HTMLElement does not inherit from FASTElement.\n     * 3. The HTMLElement is not connected to the document when token values are set.\n     *\n     * @param element - The element to notify\n     * @returns - true if notification was successful, otherwise false.\n     */\n    notifyConnection(element) {\n        if (!element.isConnected || !DesignTokenNode.existsFor(element)) {\n            return false;\n        }\n        DesignTokenNode.getOrCreate(element).bind();\n        return true;\n    },\n    /**\n     * Informs DesignToken that an HTMLElement for which tokens have\n     * been set has been disconnected to the document.\n     *\n     * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness\n     * in all scenarios, so invoking this method manually is necessary when:\n     *\n     * 1. Token values are set for an HTMLElement.\n     * 2. The HTMLElement does not inherit from FASTElement.\n     *\n     * @param element - The element to notify\n     * @returns - true if notification was successful, otherwise false.\n     */\n    notifyDisconnection(element) {\n        if (element.isConnected || !DesignTokenNode.existsFor(element)) {\n            return false;\n        }\n        DesignTokenNode.getOrCreate(element).unbind();\n        return true;\n    },\n    /**\n     * Registers and element or document as a DesignToken root.\n     * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via\n     * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all\n     * registered roots.\n     * @param target - The root to register\n     */\n    registerRoot(target = defaultElement) {\n        RootStyleSheetTarget.registerRoot(target);\n    },\n    /**\n     * Unregister an element or document as a DesignToken root.\n     * @param target - The root to deregister\n     */\n    unregisterRoot(target = defaultElement) {\n        RootStyleSheetTarget.unregisterRoot(target);\n    },\n});\n/* eslint-enable @typescript-eslint/no-non-null-assertion */\n"]},"metadata":{},"sourceType":"module"}