{"ast":null,"code":"let uniqueIdCounter = 0;\n/**\n * Generates a unique ID based on incrementing a counter.\n */\n\nexport function uniqueId(prefix = \"\") {\n  return `${prefix}${uniqueIdCounter++}`;\n}\n/**\n * Builds a string from a format specifier and replacement parameters.\n */\n\nexport function format(formatSpecifier, ...parameters) {\n  return formatSpecifier.replace(/{(\\d+)}/g, function (match, index) {\n    if (index >= parameters.length) {\n      return match;\n    }\n\n    const value = parameters[index];\n\n    if (typeof value !== \"number\" && !value) {\n      return \"\";\n    }\n\n    return value;\n  });\n}\n/**\n * Check to see if one string starts with another\n */\n\nexport function startsWith(stringToSearch, searchFor, position = 0) {\n  if (!stringToSearch || !searchFor) {\n    return false;\n  }\n\n  return stringToSearch.substr(position, searchFor.length) === searchFor;\n}\n/**\n * Matches all instances of the RegExp in the string. Operates similarly to the\n * native `String.matchAll`, which is not yet available on all supported\n * browsers. Note that the regex *must* be global.\n */\n\nfunction matchAll(re, str) {\n  const matches = [];\n  let match;\n\n  while (match = re.exec(str)) {\n    matches.push(match[1]);\n  }\n\n  re.lastIndex = 0;\n  return matches;\n}\n/**\n * Determines if the specified string is undefined, null, empty, or whitespace.\n * True if the value is undefined, null, empty, or whitespace, otherwise false.\n */\n\n\nexport function isNullOrWhiteSpace(value) {\n  return !value || !value.trim();\n}\nconst wordRe = /([A-Z]+[a-z0-9]*|[A-Z]*[a-z0-9]+)/g;\n/**\n * Converts a string to Pascal Case\n */\n\nexport function pascalCase(value) {\n  return matchAll(wordRe, value).map(word => `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`).join(\"\");\n}\n/**\n * converts a string from camelCase or pascalCase to spinal-case\n * which is an lowercase dash separated naming style.\n *\n * An example of spinal case: foo-bar-bat\n */\n\nexport function spinalCase(value) {\n  const valueWithLowerCaseFirstLetter = `${value.charAt(0).toLowerCase()}${value.slice(1)}`;\n  return valueWithLowerCaseFirstLetter.replace(/([A-Z])/g, function (match, group1) {\n    return `-${group1.toLowerCase()}`;\n  });\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-web-utilities/dist/strings.js"],"names":["uniqueIdCounter","uniqueId","prefix","format","formatSpecifier","parameters","replace","match","index","length","value","startsWith","stringToSearch","searchFor","position","substr","matchAll","re","str","matches","exec","push","lastIndex","isNullOrWhiteSpace","trim","wordRe","pascalCase","map","word","charAt","toUpperCase","slice","toLowerCase","join","spinalCase","valueWithLowerCaseFirstLetter","group1"],"mappings":"AAAA,IAAIA,eAAe,GAAG,CAAtB;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,MAAM,GAAG,EAA3B,EAA+B;AAClC,SAAQ,GAAEA,MAAO,GAAEF,eAAe,EAAG,EAArC;AACH;AACD;AACA;AACA;;AACA,OAAO,SAASG,MAAT,CAAgBC,eAAhB,EAAiC,GAAGC,UAApC,EAAgD;AACnD,SAAOD,eAAe,CAACE,OAAhB,CAAwB,UAAxB,EAAoC,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AAC/D,QAAIA,KAAK,IAAIH,UAAU,CAACI,MAAxB,EAAgC;AAC5B,aAAOF,KAAP;AACH;;AACD,UAAMG,KAAK,GAAGL,UAAU,CAACG,KAAD,CAAxB;;AACA,QAAI,OAAOE,KAAP,KAAiB,QAAjB,IAA6B,CAACA,KAAlC,EAAyC;AACrC,aAAO,EAAP;AACH;;AACD,WAAOA,KAAP;AACH,GATM,CAAP;AAUH;AACD;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBC,cAApB,EAAoCC,SAApC,EAA+CC,QAAQ,GAAG,CAA1D,EAA6D;AAChE,MAAI,CAACF,cAAD,IAAmB,CAACC,SAAxB,EAAmC;AAC/B,WAAO,KAAP;AACH;;AACD,SAAOD,cAAc,CAACG,MAAf,CAAsBD,QAAtB,EAAgCD,SAAS,CAACJ,MAA1C,MAAsDI,SAA7D;AACH;AACD;AACA;AACA;AACA;AACA;;AACA,SAASG,QAAT,CAAkBC,EAAlB,EAAsBC,GAAtB,EAA2B;AACvB,QAAMC,OAAO,GAAG,EAAhB;AACA,MAAIZ,KAAJ;;AACA,SAAQA,KAAK,GAAGU,EAAE,CAACG,IAAH,CAAQF,GAAR,CAAhB,EAA+B;AAC3BC,IAAAA,OAAO,CAACE,IAAR,CAAad,KAAK,CAAC,CAAD,CAAlB;AACH;;AACDU,EAAAA,EAAE,CAACK,SAAH,GAAe,CAAf;AACA,SAAOH,OAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,OAAO,SAASI,kBAAT,CAA4Bb,KAA5B,EAAmC;AACtC,SAAO,CAACA,KAAD,IAAU,CAACA,KAAK,CAACc,IAAN,EAAlB;AACH;AACD,MAAMC,MAAM,GAAG,oCAAf;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBhB,KAApB,EAA2B;AAC9B,SAAOM,QAAQ,CAACS,MAAD,EAASf,KAAT,CAAR,CACFiB,GADE,CACGC,IAAD,IAAW,GAAEA,IAAI,CAACC,MAAL,CAAY,CAAZ,EAAeC,WAAf,EAA6B,GAAEF,IAAI,CAACG,KAAL,CAAW,CAAX,EAAcC,WAAd,EAA4B,EAD1E,EAEFC,IAFE,CAEG,EAFH,CAAP;AAGH;AACD;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBxB,KAApB,EAA2B;AAC9B,QAAMyB,6BAA6B,GAAI,GAAEzB,KAAK,CACzCmB,MADoC,CAC7B,CAD6B,EAEpCG,WAFoC,EAEtB,GAAEtB,KAAK,CAACqB,KAAN,CAAY,CAAZ,CAAe,EAFpC;AAGA,SAAOI,6BAA6B,CAAC7B,OAA9B,CAAsC,UAAtC,EAAkD,UAAUC,KAAV,EAAiB6B,MAAjB,EAAyB;AAC9E,WAAQ,IAAGA,MAAM,CAACJ,WAAP,EAAqB,EAAhC;AACH,GAFM,CAAP;AAGH","sourcesContent":["let uniqueIdCounter = 0;\n/**\n * Generates a unique ID based on incrementing a counter.\n */\nexport function uniqueId(prefix = \"\") {\n    return `${prefix}${uniqueIdCounter++}`;\n}\n/**\n * Builds a string from a format specifier and replacement parameters.\n */\nexport function format(formatSpecifier, ...parameters) {\n    return formatSpecifier.replace(/{(\\d+)}/g, function (match, index) {\n        if (index >= parameters.length) {\n            return match;\n        }\n        const value = parameters[index];\n        if (typeof value !== \"number\" && !value) {\n            return \"\";\n        }\n        return value;\n    });\n}\n/**\n * Check to see if one string starts with another\n */\nexport function startsWith(stringToSearch, searchFor, position = 0) {\n    if (!stringToSearch || !searchFor) {\n        return false;\n    }\n    return stringToSearch.substr(position, searchFor.length) === searchFor;\n}\n/**\n * Matches all instances of the RegExp in the string. Operates similarly to the\n * native `String.matchAll`, which is not yet available on all supported\n * browsers. Note that the regex *must* be global.\n */\nfunction matchAll(re, str) {\n    const matches = [];\n    let match;\n    while ((match = re.exec(str))) {\n        matches.push(match[1]);\n    }\n    re.lastIndex = 0;\n    return matches;\n}\n/**\n * Determines if the specified string is undefined, null, empty, or whitespace.\n * True if the value is undefined, null, empty, or whitespace, otherwise false.\n */\nexport function isNullOrWhiteSpace(value) {\n    return !value || !value.trim();\n}\nconst wordRe = /([A-Z]+[a-z0-9]*|[A-Z]*[a-z0-9]+)/g;\n/**\n * Converts a string to Pascal Case\n */\nexport function pascalCase(value) {\n    return matchAll(wordRe, value)\n        .map((word) => `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`)\n        .join(\"\");\n}\n/**\n * converts a string from camelCase or pascalCase to spinal-case\n * which is an lowercase dash separated naming style.\n *\n * An example of spinal case: foo-bar-bat\n */\nexport function spinalCase(value) {\n    const valueWithLowerCaseFirstLetter = `${value\n        .charAt(0)\n        .toLowerCase()}${value.slice(1)}`;\n    return valueWithLowerCaseFirstLetter.replace(/([A-Z])/g, function (match, group1) {\n        return `-${group1.toLowerCase()}`;\n    });\n}\n"]},"metadata":{},"sourceType":"module"}