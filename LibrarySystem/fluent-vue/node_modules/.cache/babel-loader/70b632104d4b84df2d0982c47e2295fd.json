{"ast":null,"code":"import { FASTElementDefinition } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element/foundation-element\";\nimport { DI, Registration } from \"../di/di\";\nimport { DesignToken } from \"../design-token/design-token\";\nimport { ComponentPresentation } from \"./component-presentation\";\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n/**\n * Indicates what to do with an ambiguous (duplicate) element.\n * @public\n */\n\nexport const ElementDisambiguation = Object.freeze({\n  /**\n   * Skip defining the element but still call the provided callback passed\n   * to DesignSystemRegistrationContext.tryDefineElement\n   */\n  definitionCallbackOnly: null,\n\n  /**\n   * Ignore the duplicate element entirely.\n   */\n  ignoreDuplicate: Symbol()\n});\nconst elementTypesByTag = new Map();\nconst elementTagsByType = new Map();\nlet rootDesignSystem = null;\nconst designSystemKey = DI.createInterface(x => x.cachedCallback(handler => {\n  if (rootDesignSystem === null) {\n    rootDesignSystem = new DefaultDesignSystem(null, handler);\n  }\n\n  return rootDesignSystem;\n}));\n/**\n * An API gateway to design system features.\n * @public\n */\n\nexport const DesignSystem = Object.freeze({\n  /**\n   * Returns the HTML element name that the type is defined as.\n   * @param type - The type to lookup.\n   * @public\n   */\n  tagFor(type) {\n    return elementTagsByType.get(type);\n  },\n\n  /**\n   * Searches the DOM hierarchy for the design system that is responsible\n   * for the provided element.\n   * @param element - The element to locate the design system for.\n   * @returns The located design system.\n   * @public\n   */\n  responsibleFor(element) {\n    const owned = element.$$designSystem$$;\n\n    if (owned) {\n      return owned;\n    }\n\n    const container = DI.findResponsibleContainer(element);\n    return container.get(designSystemKey);\n  },\n\n  /**\n   * Gets the DesignSystem if one is explicitly defined on the provided element;\n   * otherwise creates a design system defined directly on the element.\n   * @param element - The element to get or create a design system for.\n   * @returns The design system.\n   * @public\n   */\n  getOrCreate(node) {\n    if (!node) {\n      if (rootDesignSystem === null) {\n        rootDesignSystem = DI.getOrCreateDOMContainer().get(designSystemKey);\n      }\n\n      return rootDesignSystem;\n    }\n\n    const owned = node.$$designSystem$$;\n\n    if (owned) {\n      return owned;\n    }\n\n    const container = DI.getOrCreateDOMContainer(node);\n\n    if (container.has(designSystemKey, false)) {\n      return container.get(designSystemKey);\n    } else {\n      const system = new DefaultDesignSystem(node, container);\n      container.register(Registration.instance(designSystemKey, system));\n      return system;\n    }\n  }\n\n});\n\nfunction extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback) {\n  if (typeof params === \"string\") {\n    return {\n      name: params,\n      type: elementDefinitionType,\n      callback: elementDefinitionCallback\n    };\n  } else {\n    return params;\n  }\n}\n\nclass DefaultDesignSystem {\n  constructor(owner, container) {\n    this.owner = owner;\n    this.container = container;\n    this.designTokensInitialized = false;\n    this.prefix = \"fast\";\n    this.shadowRootMode = undefined;\n\n    this.disambiguate = () => ElementDisambiguation.definitionCallbackOnly;\n\n    if (owner !== null) {\n      owner.$$designSystem$$ = this;\n    }\n  }\n\n  withPrefix(prefix) {\n    this.prefix = prefix;\n    return this;\n  }\n\n  withShadowRootMode(mode) {\n    this.shadowRootMode = mode;\n    return this;\n  }\n\n  withElementDisambiguation(callback) {\n    this.disambiguate = callback;\n    return this;\n  }\n\n  withDesignTokenRoot(root) {\n    this.designTokenRoot = root;\n    return this;\n  }\n\n  register(...registrations) {\n    const container = this.container;\n    const elementDefinitionEntries = [];\n    const disambiguate = this.disambiguate;\n    const shadowRootMode = this.shadowRootMode;\n    const context = {\n      elementPrefix: this.prefix,\n\n      tryDefineElement(params, elementDefinitionType, elementDefinitionCallback) {\n        const extractedParams = extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback);\n        const {\n          name,\n          callback,\n          baseClass\n        } = extractedParams;\n        let {\n          type\n        } = extractedParams;\n        let elementName = name;\n        let typeFoundByName = elementTypesByTag.get(elementName);\n        let needsDefine = true;\n\n        while (typeFoundByName) {\n          const result = disambiguate(elementName, type, typeFoundByName);\n\n          switch (result) {\n            case ElementDisambiguation.ignoreDuplicate:\n              return;\n\n            case ElementDisambiguation.definitionCallbackOnly:\n              needsDefine = false;\n              typeFoundByName = void 0;\n              break;\n\n            default:\n              elementName = result;\n              typeFoundByName = elementTypesByTag.get(elementName);\n              break;\n          }\n        }\n\n        if (needsDefine) {\n          if (elementTagsByType.has(type) || type === FoundationElement) {\n            type = class extends type {};\n          }\n\n          elementTypesByTag.set(elementName, type);\n          elementTagsByType.set(type, elementName);\n\n          if (baseClass) {\n            elementTagsByType.set(baseClass, elementName);\n          }\n        }\n\n        elementDefinitionEntries.push(new ElementDefinitionEntry(container, elementName, type, shadowRootMode, callback, needsDefine));\n      }\n\n    };\n\n    if (!this.designTokensInitialized) {\n      this.designTokensInitialized = true;\n\n      if (this.designTokenRoot !== null) {\n        DesignToken.registerRoot(this.designTokenRoot);\n      }\n    }\n\n    container.registerWithContext(context, ...registrations);\n\n    for (const entry of elementDefinitionEntries) {\n      entry.callback(entry);\n\n      if (entry.willDefine && entry.definition !== null) {\n        entry.definition.define();\n      }\n    }\n\n    return this;\n  }\n\n}\n\nclass ElementDefinitionEntry {\n  constructor(container, name, type, shadowRootMode, callback, willDefine) {\n    this.container = container;\n    this.name = name;\n    this.type = type;\n    this.shadowRootMode = shadowRootMode;\n    this.callback = callback;\n    this.willDefine = willDefine;\n    this.definition = null;\n  }\n\n  definePresentation(presentation) {\n    ComponentPresentation.define(this.name, presentation, this.container);\n  }\n\n  defineElement(definition) {\n    this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), {\n      name: this.name\n    }));\n  }\n\n  tagFor(type) {\n    return DesignSystem.tagFor(type);\n  }\n\n}\n/* eslint-enable @typescript-eslint/no-non-null-assertion */","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/design-system/design-system.js"],"names":["FASTElementDefinition","FoundationElement","DI","Registration","DesignToken","ComponentPresentation","ElementDisambiguation","Object","freeze","definitionCallbackOnly","ignoreDuplicate","Symbol","elementTypesByTag","Map","elementTagsByType","rootDesignSystem","designSystemKey","createInterface","x","cachedCallback","handler","DefaultDesignSystem","DesignSystem","tagFor","type","get","responsibleFor","element","owned","$$designSystem$$","container","findResponsibleContainer","getOrCreate","node","getOrCreateDOMContainer","has","system","register","instance","extractTryDefineElementParams","params","elementDefinitionType","elementDefinitionCallback","name","callback","constructor","owner","designTokensInitialized","prefix","shadowRootMode","undefined","disambiguate","withPrefix","withShadowRootMode","mode","withElementDisambiguation","withDesignTokenRoot","root","designTokenRoot","registrations","elementDefinitionEntries","context","elementPrefix","tryDefineElement","extractedParams","baseClass","elementName","typeFoundByName","needsDefine","result","set","push","ElementDefinitionEntry","registerRoot","registerWithContext","entry","willDefine","definition","define","definePresentation","presentation","defineElement","assign"],"mappings":"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","sourcesContent":["import { FASTElementDefinition } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element/foundation-element\";\nimport { DI, Registration } from \"../di/di\";\nimport { DesignToken } from \"../design-token/design-token\";\nimport { ComponentPresentation } from \"./component-presentation\";\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/**\n * Indicates what to do with an ambiguous (duplicate) element.\n * @public\n */\nexport const ElementDisambiguation = Object.freeze({\n    /**\n     * Skip defining the element but still call the provided callback passed\n     * to DesignSystemRegistrationContext.tryDefineElement\n     */\n    definitionCallbackOnly: null,\n    /**\n     * Ignore the duplicate element entirely.\n     */\n    ignoreDuplicate: Symbol(),\n});\nconst elementTypesByTag = new Map();\nconst elementTagsByType = new Map();\nlet rootDesignSystem = null;\nconst designSystemKey = DI.createInterface(x => x.cachedCallback(handler => {\n    if (rootDesignSystem === null) {\n        rootDesignSystem = new DefaultDesignSystem(null, handler);\n    }\n    return rootDesignSystem;\n}));\n/**\n * An API gateway to design system features.\n * @public\n */\nexport const DesignSystem = Object.freeze({\n    /**\n     * Returns the HTML element name that the type is defined as.\n     * @param type - The type to lookup.\n     * @public\n     */\n    tagFor(type) {\n        return elementTagsByType.get(type);\n    },\n    /**\n     * Searches the DOM hierarchy for the design system that is responsible\n     * for the provided element.\n     * @param element - The element to locate the design system for.\n     * @returns The located design system.\n     * @public\n     */\n    responsibleFor(element) {\n        const owned = element.$$designSystem$$;\n        if (owned) {\n            return owned;\n        }\n        const container = DI.findResponsibleContainer(element);\n        return container.get(designSystemKey);\n    },\n    /**\n     * Gets the DesignSystem if one is explicitly defined on the provided element;\n     * otherwise creates a design system defined directly on the element.\n     * @param element - The element to get or create a design system for.\n     * @returns The design system.\n     * @public\n     */\n    getOrCreate(node) {\n        if (!node) {\n            if (rootDesignSystem === null) {\n                rootDesignSystem = DI.getOrCreateDOMContainer().get(designSystemKey);\n            }\n            return rootDesignSystem;\n        }\n        const owned = node.$$designSystem$$;\n        if (owned) {\n            return owned;\n        }\n        const container = DI.getOrCreateDOMContainer(node);\n        if (container.has(designSystemKey, false)) {\n            return container.get(designSystemKey);\n        }\n        else {\n            const system = new DefaultDesignSystem(node, container);\n            container.register(Registration.instance(designSystemKey, system));\n            return system;\n        }\n    },\n});\nfunction extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback) {\n    if (typeof params === \"string\") {\n        return {\n            name: params,\n            type: elementDefinitionType,\n            callback: elementDefinitionCallback,\n        };\n    }\n    else {\n        return params;\n    }\n}\nclass DefaultDesignSystem {\n    constructor(owner, container) {\n        this.owner = owner;\n        this.container = container;\n        this.designTokensInitialized = false;\n        this.prefix = \"fast\";\n        this.shadowRootMode = undefined;\n        this.disambiguate = () => ElementDisambiguation.definitionCallbackOnly;\n        if (owner !== null) {\n            owner.$$designSystem$$ = this;\n        }\n    }\n    withPrefix(prefix) {\n        this.prefix = prefix;\n        return this;\n    }\n    withShadowRootMode(mode) {\n        this.shadowRootMode = mode;\n        return this;\n    }\n    withElementDisambiguation(callback) {\n        this.disambiguate = callback;\n        return this;\n    }\n    withDesignTokenRoot(root) {\n        this.designTokenRoot = root;\n        return this;\n    }\n    register(...registrations) {\n        const container = this.container;\n        const elementDefinitionEntries = [];\n        const disambiguate = this.disambiguate;\n        const shadowRootMode = this.shadowRootMode;\n        const context = {\n            elementPrefix: this.prefix,\n            tryDefineElement(params, elementDefinitionType, elementDefinitionCallback) {\n                const extractedParams = extractTryDefineElementParams(params, elementDefinitionType, elementDefinitionCallback);\n                const { name, callback, baseClass } = extractedParams;\n                let { type } = extractedParams;\n                let elementName = name;\n                let typeFoundByName = elementTypesByTag.get(elementName);\n                let needsDefine = true;\n                while (typeFoundByName) {\n                    const result = disambiguate(elementName, type, typeFoundByName);\n                    switch (result) {\n                        case ElementDisambiguation.ignoreDuplicate:\n                            return;\n                        case ElementDisambiguation.definitionCallbackOnly:\n                            needsDefine = false;\n                            typeFoundByName = void 0;\n                            break;\n                        default:\n                            elementName = result;\n                            typeFoundByName = elementTypesByTag.get(elementName);\n                            break;\n                    }\n                }\n                if (needsDefine) {\n                    if (elementTagsByType.has(type) || type === FoundationElement) {\n                        type = class extends type {\n                        };\n                    }\n                    elementTypesByTag.set(elementName, type);\n                    elementTagsByType.set(type, elementName);\n                    if (baseClass) {\n                        elementTagsByType.set(baseClass, elementName);\n                    }\n                }\n                elementDefinitionEntries.push(new ElementDefinitionEntry(container, elementName, type, shadowRootMode, callback, needsDefine));\n            },\n        };\n        if (!this.designTokensInitialized) {\n            this.designTokensInitialized = true;\n            if (this.designTokenRoot !== null) {\n                DesignToken.registerRoot(this.designTokenRoot);\n            }\n        }\n        container.registerWithContext(context, ...registrations);\n        for (const entry of elementDefinitionEntries) {\n            entry.callback(entry);\n            if (entry.willDefine && entry.definition !== null) {\n                entry.definition.define();\n            }\n        }\n        return this;\n    }\n}\nclass ElementDefinitionEntry {\n    constructor(container, name, type, shadowRootMode, callback, willDefine) {\n        this.container = container;\n        this.name = name;\n        this.type = type;\n        this.shadowRootMode = shadowRootMode;\n        this.callback = callback;\n        this.willDefine = willDefine;\n        this.definition = null;\n    }\n    definePresentation(presentation) {\n        ComponentPresentation.define(this.name, presentation, this.container);\n    }\n    defineElement(definition) {\n        this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), { name: this.name }));\n    }\n    tagFor(type) {\n        return DesignSystem.tagFor(type);\n    }\n}\n/* eslint-enable @typescript-eslint/no-non-null-assertion */\n"]},"metadata":{},"sourceType":"module"}