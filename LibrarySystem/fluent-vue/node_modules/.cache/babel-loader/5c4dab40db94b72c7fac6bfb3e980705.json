{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { contrastRatio } from \"./color-converters\";\nimport { ColorInterpolationSpace, interpolateByColorSpace } from \"./color-interpolation\";\n/**\n * A color scale created from linear stops\n * @public\n */\n\nexport class ColorScale {\n  constructor(stops) {\n    if (stops == null || stops.length === 0) {\n      throw new Error(\"The stops argument must be non-empty\");\n    } else {\n      this.stops = this.sortColorScaleStops(stops);\n    }\n  }\n\n  static createBalancedColorScale(colors) {\n    if (colors == null || colors.length === 0) {\n      throw new Error(\"The colors argument must be non-empty\");\n    }\n\n    const stops = new Array(colors.length);\n\n    for (let i = 0; i < colors.length; i++) {\n      // Special case first and last in order to avoid floating point jaggies\n      if (i === 0) {\n        stops[i] = {\n          color: colors[i],\n          position: 0\n        };\n      } else if (i === colors.length - 1) {\n        stops[i] = {\n          color: colors[i],\n          position: 1\n        };\n      } else {\n        stops[i] = {\n          color: colors[i],\n          position: i * (1 / (colors.length - 1))\n        };\n      }\n    }\n\n    return new ColorScale(stops);\n  }\n\n  getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {\n    if (this.stops.length === 1) {\n      return this.stops[0].color;\n    } else if (position <= 0) {\n      return this.stops[0].color;\n    } else if (position >= 1) {\n      return this.stops[this.stops.length - 1].color;\n    }\n\n    let lowerIndex = 0;\n\n    for (let i = 0; i < this.stops.length; i++) {\n      if (this.stops[i].position <= position) {\n        lowerIndex = i;\n      }\n    }\n\n    let upperIndex = lowerIndex + 1;\n\n    if (upperIndex >= this.stops.length) {\n      upperIndex = this.stops.length - 1;\n    }\n\n    const scalePosition = (position - this.stops[lowerIndex].position) * (1.0 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));\n    return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);\n  }\n\n  trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {\n    if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {\n      throw new Error(\"Invalid bounds\");\n    }\n\n    if (lowerBound === upperBound) {\n      return new ColorScale([{\n        color: this.getColor(lowerBound, interpolationMode),\n        position: 0\n      }]);\n    }\n\n    const containedStops = [];\n\n    for (let i = 0; i < this.stops.length; i++) {\n      if (this.stops[i].position >= lowerBound && this.stops[i].position <= upperBound) {\n        containedStops.push(this.stops[i]);\n      }\n    }\n\n    if (containedStops.length === 0) {\n      return new ColorScale([{\n        color: this.getColor(lowerBound),\n        position: lowerBound\n      }, {\n        color: this.getColor(upperBound),\n        position: upperBound\n      }]);\n    }\n\n    if (containedStops[0].position !== lowerBound) {\n      containedStops.unshift({\n        color: this.getColor(lowerBound),\n        position: lowerBound\n      });\n    }\n\n    if (containedStops[containedStops.length - 1].position !== upperBound) {\n      containedStops.push({\n        color: this.getColor(upperBound),\n        position: upperBound\n      });\n    }\n\n    const range = upperBound - lowerBound;\n    const finalStops = new Array(containedStops.length);\n\n    for (let i = 0; i < containedStops.length; i++) {\n      finalStops[i] = {\n        color: containedStops[i].color,\n        position: (containedStops[i].position - lowerBound) / range\n      };\n    }\n\n    return new ColorScale(finalStops);\n  }\n\n  findNextColor(position, contrast, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 0.005, maxSearchIterations = 32) {\n    if (isNaN(position) || position <= 0) {\n      position = 0;\n    } else if (position >= 1) {\n      position = 1;\n    }\n\n    const startingColor = this.getColor(position, interpolationMode);\n    const finalPosition = searchDown ? 0 : 1;\n    const finalColor = this.getColor(finalPosition, interpolationMode);\n    const finalContrast = contrastRatio(startingColor, finalColor);\n\n    if (finalContrast <= contrast) {\n      return finalPosition;\n    }\n\n    let testRangeMin = searchDown ? 0 : position;\n    let testRangeMax = searchDown ? position : 0;\n    let mid = finalPosition;\n    let iterations = 0;\n\n    while (iterations <= maxSearchIterations) {\n      mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;\n      const midColor = this.getColor(mid, interpolationMode);\n      const midContrast = contrastRatio(startingColor, midColor);\n\n      if (Math.abs(midContrast - contrast) <= contrastErrorMargin) {\n        return mid;\n      } else if (midContrast > contrast) {\n        if (searchDown) {\n          testRangeMin = mid;\n        } else {\n          testRangeMax = mid;\n        }\n      } else {\n        if (searchDown) {\n          testRangeMax = mid;\n        } else {\n          testRangeMin = mid;\n        }\n      }\n\n      iterations++;\n    }\n\n    return mid;\n  }\n\n  clone() {\n    const newStops = new Array(this.stops.length);\n\n    for (let i = 0; i < newStops.length; i++) {\n      newStops[i] = {\n        color: this.stops[i].color,\n        position: this.stops[i].position\n      };\n    }\n\n    return new ColorScale(newStops);\n  }\n\n  sortColorScaleStops(stops) {\n    return stops.sort((a, b) => {\n      const A = a.position;\n      const B = b.position;\n\n      if (A < B) {\n        return -1;\n      } else if (A > B) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-colors/dist/color-scale.js"],"names":["contrastRatio","ColorInterpolationSpace","interpolateByColorSpace","ColorScale","constructor","stops","length","Error","sortColorScaleStops","createBalancedColorScale","colors","Array","i","color","position","getColor","interpolationMode","RGB","lowerIndex","upperIndex","scalePosition","trim","lowerBound","upperBound","containedStops","push","unshift","range","finalStops","findNextColor","contrast","searchDown","contrastErrorMargin","maxSearchIterations","isNaN","startingColor","finalPosition","finalColor","finalContrast","testRangeMin","testRangeMax","mid","iterations","Math","abs","midColor","midContrast","clone","newStops","sort","a","b","A","B"],"mappings":"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","sourcesContent":["import { contrastRatio } from \"./color-converters\";\nimport { ColorInterpolationSpace, interpolateByColorSpace } from \"./color-interpolation\";\n/**\n * A color scale created from linear stops\n * @public\n */\nexport class ColorScale {\n    constructor(stops) {\n        if (stops == null || stops.length === 0) {\n            throw new Error(\"The stops argument must be non-empty\");\n        }\n        else {\n            this.stops = this.sortColorScaleStops(stops);\n        }\n    }\n    static createBalancedColorScale(colors) {\n        if (colors == null || colors.length === 0) {\n            throw new Error(\"The colors argument must be non-empty\");\n        }\n        const stops = new Array(colors.length);\n        for (let i = 0; i < colors.length; i++) {\n            // Special case first and last in order to avoid floating point jaggies\n            if (i === 0) {\n                stops[i] = { color: colors[i], position: 0 };\n            }\n            else if (i === colors.length - 1) {\n                stops[i] = { color: colors[i], position: 1 };\n            }\n            else {\n                stops[i] = {\n                    color: colors[i],\n                    position: i * (1 / (colors.length - 1)),\n                };\n            }\n        }\n        return new ColorScale(stops);\n    }\n    getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {\n        if (this.stops.length === 1) {\n            return this.stops[0].color;\n        }\n        else if (position <= 0) {\n            return this.stops[0].color;\n        }\n        else if (position >= 1) {\n            return this.stops[this.stops.length - 1].color;\n        }\n        let lowerIndex = 0;\n        for (let i = 0; i < this.stops.length; i++) {\n            if (this.stops[i].position <= position) {\n                lowerIndex = i;\n            }\n        }\n        let upperIndex = lowerIndex + 1;\n        if (upperIndex >= this.stops.length) {\n            upperIndex = this.stops.length - 1;\n        }\n        const scalePosition = (position - this.stops[lowerIndex].position) *\n            (1.0 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));\n        return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);\n    }\n    trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {\n        if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {\n            throw new Error(\"Invalid bounds\");\n        }\n        if (lowerBound === upperBound) {\n            return new ColorScale([\n                { color: this.getColor(lowerBound, interpolationMode), position: 0 },\n            ]);\n        }\n        const containedStops = [];\n        for (let i = 0; i < this.stops.length; i++) {\n            if (this.stops[i].position >= lowerBound &&\n                this.stops[i].position <= upperBound) {\n                containedStops.push(this.stops[i]);\n            }\n        }\n        if (containedStops.length === 0) {\n            return new ColorScale([\n                { color: this.getColor(lowerBound), position: lowerBound },\n                { color: this.getColor(upperBound), position: upperBound },\n            ]);\n        }\n        if (containedStops[0].position !== lowerBound) {\n            containedStops.unshift({\n                color: this.getColor(lowerBound),\n                position: lowerBound,\n            });\n        }\n        if (containedStops[containedStops.length - 1].position !== upperBound) {\n            containedStops.push({\n                color: this.getColor(upperBound),\n                position: upperBound,\n            });\n        }\n        const range = upperBound - lowerBound;\n        const finalStops = new Array(containedStops.length);\n        for (let i = 0; i < containedStops.length; i++) {\n            finalStops[i] = {\n                color: containedStops[i].color,\n                position: (containedStops[i].position - lowerBound) / range,\n            };\n        }\n        return new ColorScale(finalStops);\n    }\n    findNextColor(position, contrast, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 0.005, maxSearchIterations = 32) {\n        if (isNaN(position) || position <= 0) {\n            position = 0;\n        }\n        else if (position >= 1) {\n            position = 1;\n        }\n        const startingColor = this.getColor(position, interpolationMode);\n        const finalPosition = searchDown ? 0 : 1;\n        const finalColor = this.getColor(finalPosition, interpolationMode);\n        const finalContrast = contrastRatio(startingColor, finalColor);\n        if (finalContrast <= contrast) {\n            return finalPosition;\n        }\n        let testRangeMin = searchDown ? 0 : position;\n        let testRangeMax = searchDown ? position : 0;\n        let mid = finalPosition;\n        let iterations = 0;\n        while (iterations <= maxSearchIterations) {\n            mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;\n            const midColor = this.getColor(mid, interpolationMode);\n            const midContrast = contrastRatio(startingColor, midColor);\n            if (Math.abs(midContrast - contrast) <= contrastErrorMargin) {\n                return mid;\n            }\n            else if (midContrast > contrast) {\n                if (searchDown) {\n                    testRangeMin = mid;\n                }\n                else {\n                    testRangeMax = mid;\n                }\n            }\n            else {\n                if (searchDown) {\n                    testRangeMax = mid;\n                }\n                else {\n                    testRangeMin = mid;\n                }\n            }\n            iterations++;\n        }\n        return mid;\n    }\n    clone() {\n        const newStops = new Array(this.stops.length);\n        for (let i = 0; i < newStops.length; i++) {\n            newStops[i] = {\n                color: this.stops[i].color,\n                position: this.stops[i].position,\n            };\n        }\n        return new ColorScale(newStops);\n    }\n    sortColorScaleStops(stops) {\n        return stops.sort((a, b) => {\n            const A = a.position;\n            const B = b.position;\n            if (A < B) {\n                return -1;\n            }\n            else if (A > B) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}