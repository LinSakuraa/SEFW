{"ast":null,"code":"export function treeOption2SelectOption(tmNode, labelField) {\n  const {\n    rawNode\n  } = tmNode;\n  return Object.assign(Object.assign({}, rawNode), {\n    label: rawNode[labelField],\n    value: tmNode.key\n  });\n}\nexport function treeOption2SelectOptionWithPath(tmNode, path, separator, labelField) {\n  const {\n    rawNode\n  } = tmNode;\n  return Object.assign(Object.assign({}, rawNode), {\n    value: tmNode.key,\n    label: path.map(v => v.rawNode[labelField]).join(separator)\n  });\n}\nexport function filterTree(tree, filter, pattern, keyField) {\n  const visitedTailKeys = new Set();\n  const visitedNonTailKeys = new Set();\n  const highlightKeySet = new Set();\n  const expandedKeys = [];\n  const filteredTree = [];\n  const path = [];\n\n  function visit(t) {\n    t.forEach(n => {\n      path.push(n);\n\n      if (filter(pattern, n)) {\n        visitedTailKeys.add(n[keyField]);\n        highlightKeySet.add(n[keyField]);\n\n        for (let i = path.length - 2; i >= 0; --i) {\n          const key = path[i][keyField];\n\n          if (!visitedNonTailKeys.has(key)) {\n            visitedNonTailKeys.add(key);\n\n            if (visitedTailKeys.has(key)) {\n              visitedTailKeys.delete(key);\n            }\n          } else {\n            break;\n          }\n        }\n      }\n\n      if (n.children) {\n        visit(n.children);\n      }\n\n      path.pop();\n    });\n  }\n\n  visit(tree);\n\n  function build(t, sibs) {\n    t.forEach(n => {\n      const key = n[keyField];\n      const isVisitedTail = visitedTailKeys.has(key);\n      const isVisitedNonTail = visitedNonTailKeys.has(key);\n      if (!isVisitedTail && !isVisitedNonTail) return;\n      const {\n        children\n      } = n;\n\n      if (children) {\n        if (isVisitedTail) {\n          // If it is visited path tail, use origin node\n          sibs.push(n);\n        } else {\n          // It it is not visited path tail, use cloned node\n          expandedKeys.push(key);\n          const clonedNode = Object.assign(Object.assign({}, n), {\n            children: []\n          });\n          sibs.push(clonedNode);\n          build(children, clonedNode.children);\n        }\n      } else {\n        sibs.push(n);\n      }\n    });\n  }\n\n  build(tree, filteredTree);\n  return {\n    filteredTree,\n    highlightKeySet,\n    expandedKeys\n  };\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/tree-select/src/utils.js"],"names":["treeOption2SelectOption","tmNode","labelField","rawNode","Object","assign","label","value","key","treeOption2SelectOptionWithPath","path","separator","map","v","join","filterTree","tree","filter","pattern","keyField","visitedTailKeys","Set","visitedNonTailKeys","highlightKeySet","expandedKeys","filteredTree","visit","t","forEach","n","push","add","i","length","has","delete","children","pop","build","sibs","isVisitedTail","isVisitedNonTail","clonedNode"],"mappings":"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","sourcesContent":["export function treeOption2SelectOption(tmNode, labelField) {\n    const { rawNode } = tmNode;\n    return Object.assign(Object.assign({}, rawNode), { label: rawNode[labelField], value: tmNode.key });\n}\nexport function treeOption2SelectOptionWithPath(tmNode, path, separator, labelField) {\n    const { rawNode } = tmNode;\n    return Object.assign(Object.assign({}, rawNode), { value: tmNode.key, label: path.map((v) => v.rawNode[labelField]).join(separator) });\n}\nexport function filterTree(tree, filter, pattern, keyField) {\n    const visitedTailKeys = new Set();\n    const visitedNonTailKeys = new Set();\n    const highlightKeySet = new Set();\n    const expandedKeys = [];\n    const filteredTree = [];\n    const path = [];\n    function visit(t) {\n        t.forEach((n) => {\n            path.push(n);\n            if (filter(pattern, n)) {\n                visitedTailKeys.add(n[keyField]);\n                highlightKeySet.add(n[keyField]);\n                for (let i = path.length - 2; i >= 0; --i) {\n                    const key = path[i][keyField];\n                    if (!visitedNonTailKeys.has(key)) {\n                        visitedNonTailKeys.add(key);\n                        if (visitedTailKeys.has(key)) {\n                            visitedTailKeys.delete(key);\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            if (n.children) {\n                visit(n.children);\n            }\n            path.pop();\n        });\n    }\n    visit(tree);\n    function build(t, sibs) {\n        t.forEach((n) => {\n            const key = n[keyField];\n            const isVisitedTail = visitedTailKeys.has(key);\n            const isVisitedNonTail = visitedNonTailKeys.has(key);\n            if (!isVisitedTail && !isVisitedNonTail)\n                return;\n            const { children } = n;\n            if (children) {\n                if (isVisitedTail) {\n                    // If it is visited path tail, use origin node\n                    sibs.push(n);\n                }\n                else {\n                    // It it is not visited path tail, use cloned node\n                    expandedKeys.push(key);\n                    const clonedNode = Object.assign(Object.assign({}, n), { children: [] });\n                    sibs.push(clonedNode);\n                    build(children, clonedNode.children);\n                }\n            }\n            else {\n                sibs.push(n);\n            }\n        });\n    }\n    build(tree, filteredTree);\n    return {\n        filteredTree,\n        highlightKeySet,\n        expandedKeys\n    };\n}\n"]},"metadata":{},"sourceType":"module"}