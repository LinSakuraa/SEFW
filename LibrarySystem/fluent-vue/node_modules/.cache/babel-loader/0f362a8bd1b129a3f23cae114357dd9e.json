{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { DOM } from \"../dom\";\nimport { PropertyChangeNotifier } from \"../observation/notifier\";\nimport { defaultExecutionContext, Observable } from \"../observation/observable\";\nimport { FASTElementDefinition } from \"./fast-definitions\";\nconst shadowRoots = new WeakMap();\nconst defaultEventOptions = {\n  bubbles: true,\n  composed: true,\n  cancelable: true\n};\n\nfunction getShadowRoot(element) {\n  return element.shadowRoot || shadowRoots.get(element) || null;\n}\n/**\n * Controls the lifecycle and rendering of a `FASTElement`.\n * @public\n */\n\n\nexport class Controller extends PropertyChangeNotifier {\n  /**\n   * Creates a Controller to control the specified element.\n   * @param element - The element to be controlled by this controller.\n   * @param definition - The element definition metadata that instructs this\n   * controller in how to handle rendering and other platform integrations.\n   * @internal\n   */\n  constructor(element, definition) {\n    super(element);\n    this.boundObservables = null;\n    this.behaviors = null;\n    this.needsInitialization = true;\n    this._template = null;\n    this._styles = null;\n    this._isConnected = false;\n    /**\n     * This allows Observable.getNotifier(...) to return the Controller\n     * when the notifier for the Controller itself is being requested. The\n     * result is that the Observable system does not need to create a separate\n     * instance of Notifier for observables on the Controller. The component and\n     * the controller will now share the same notifier, removing one-object construct\n     * per web component instance.\n     */\n\n    this.$fastController = this;\n    /**\n     * The view associated with the custom element.\n     * @remarks\n     * If `null` then the element is managing its own rendering.\n     */\n\n    this.view = null;\n    this.element = element;\n    this.definition = definition;\n    const shadowOptions = definition.shadowOptions;\n\n    if (shadowOptions !== void 0) {\n      const shadowRoot = element.attachShadow(shadowOptions);\n\n      if (shadowOptions.mode === \"closed\") {\n        shadowRoots.set(element, shadowRoot);\n      }\n    } // Capture any observable values that were set by the binding engine before\n    // the browser upgraded the element. Then delete the property since it will\n    // shadow the getter/setter that is required to make the observable operate.\n    // Later, in the connect callback, we'll re-apply the values.\n\n\n    const accessors = Observable.getAccessors(element);\n\n    if (accessors.length > 0) {\n      const boundObservables = this.boundObservables = Object.create(null);\n\n      for (let i = 0, ii = accessors.length; i < ii; ++i) {\n        const propertyName = accessors[i].name;\n        const value = element[propertyName];\n\n        if (value !== void 0) {\n          delete element[propertyName];\n          boundObservables[propertyName] = value;\n        }\n      }\n    }\n  }\n  /**\n   * Indicates whether or not the custom element has been\n   * connected to the document.\n   */\n\n\n  get isConnected() {\n    Observable.track(this, \"isConnected\");\n    return this._isConnected;\n  }\n\n  setIsConnected(value) {\n    this._isConnected = value;\n    Observable.notify(this, \"isConnected\");\n  }\n  /**\n   * Gets/sets the template used to render the component.\n   * @remarks\n   * This value can only be accurately read after connect but can be set at any time.\n   */\n\n\n  get template() {\n    return this._template;\n  }\n\n  set template(value) {\n    if (this._template === value) {\n      return;\n    }\n\n    this._template = value;\n\n    if (!this.needsInitialization) {\n      this.renderTemplate(value);\n    }\n  }\n  /**\n   * Gets/sets the primary styles used for the component.\n   * @remarks\n   * This value can only be accurately read after connect but can be set at any time.\n   */\n\n\n  get styles() {\n    return this._styles;\n  }\n\n  set styles(value) {\n    if (this._styles === value) {\n      return;\n    }\n\n    if (this._styles !== null) {\n      this.removeStyles(this._styles);\n    }\n\n    this._styles = value;\n\n    if (!this.needsInitialization && value !== null) {\n      this.addStyles(value);\n    }\n  }\n  /**\n   * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.\n   * @param styles - The styles to add.\n   */\n\n\n  addStyles(styles) {\n    const target = getShadowRoot(this.element) || this.element.getRootNode();\n\n    if (styles instanceof HTMLStyleElement) {\n      target.append(styles);\n    } else if (!styles.isAttachedTo(target)) {\n      const sourceBehaviors = styles.behaviors;\n      styles.addStylesTo(target);\n\n      if (sourceBehaviors !== null) {\n        this.addBehaviors(sourceBehaviors);\n      }\n    }\n  }\n  /**\n   * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.\n   * @param styles - the styles to remove.\n   */\n\n\n  removeStyles(styles) {\n    const target = getShadowRoot(this.element) || this.element.getRootNode();\n\n    if (styles instanceof HTMLStyleElement) {\n      target.removeChild(styles);\n    } else if (styles.isAttachedTo(target)) {\n      const sourceBehaviors = styles.behaviors;\n      styles.removeStylesFrom(target);\n\n      if (sourceBehaviors !== null) {\n        this.removeBehaviors(sourceBehaviors);\n      }\n    }\n  }\n  /**\n   * Adds behaviors to this element.\n   * @param behaviors - The behaviors to add.\n   */\n\n\n  addBehaviors(behaviors) {\n    const targetBehaviors = this.behaviors || (this.behaviors = new Map());\n    const length = behaviors.length;\n    const behaviorsToBind = [];\n\n    for (let i = 0; i < length; ++i) {\n      const behavior = behaviors[i];\n\n      if (targetBehaviors.has(behavior)) {\n        targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);\n      } else {\n        targetBehaviors.set(behavior, 1);\n        behaviorsToBind.push(behavior);\n      }\n    }\n\n    if (this._isConnected) {\n      const element = this.element;\n\n      for (let i = 0; i < behaviorsToBind.length; ++i) {\n        behaviorsToBind[i].bind(element, defaultExecutionContext);\n      }\n    }\n  }\n  /**\n   * Removes behaviors from this element.\n   * @param behaviors - The behaviors to remove.\n   * @param force - Forces unbinding of behaviors.\n   */\n\n\n  removeBehaviors(behaviors, force = false) {\n    const targetBehaviors = this.behaviors;\n\n    if (targetBehaviors === null) {\n      return;\n    }\n\n    const length = behaviors.length;\n    const behaviorsToUnbind = [];\n\n    for (let i = 0; i < length; ++i) {\n      const behavior = behaviors[i];\n\n      if (targetBehaviors.has(behavior)) {\n        const count = targetBehaviors.get(behavior) - 1;\n        count === 0 || force ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior) : targetBehaviors.set(behavior, count);\n      }\n    }\n\n    if (this._isConnected) {\n      const element = this.element;\n\n      for (let i = 0; i < behaviorsToUnbind.length; ++i) {\n        behaviorsToUnbind[i].unbind(element);\n      }\n    }\n  }\n  /**\n   * Runs connected lifecycle behavior on the associated element.\n   */\n\n\n  onConnectedCallback() {\n    if (this._isConnected) {\n      return;\n    }\n\n    const element = this.element;\n\n    if (this.needsInitialization) {\n      this.finishInitialization();\n    } else if (this.view !== null) {\n      this.view.bind(element, defaultExecutionContext);\n    }\n\n    const behaviors = this.behaviors;\n\n    if (behaviors !== null) {\n      for (const [behavior] of behaviors) {\n        behavior.bind(element, defaultExecutionContext);\n      }\n    }\n\n    this.setIsConnected(true);\n  }\n  /**\n   * Runs disconnected lifecycle behavior on the associated element.\n   */\n\n\n  onDisconnectedCallback() {\n    if (!this._isConnected) {\n      return;\n    }\n\n    this.setIsConnected(false);\n    const view = this.view;\n\n    if (view !== null) {\n      view.unbind();\n    }\n\n    const behaviors = this.behaviors;\n\n    if (behaviors !== null) {\n      const element = this.element;\n\n      for (const [behavior] of behaviors) {\n        behavior.unbind(element);\n      }\n    }\n  }\n  /**\n   * Runs the attribute changed callback for the associated element.\n   * @param name - The name of the attribute that changed.\n   * @param oldValue - The previous value of the attribute.\n   * @param newValue - The new value of the attribute.\n   */\n\n\n  onAttributeChangedCallback(name, oldValue, newValue) {\n    const attrDef = this.definition.attributeLookup[name];\n\n    if (attrDef !== void 0) {\n      attrDef.onAttributeChangedCallback(this.element, newValue);\n    }\n  }\n  /**\n   * Emits a custom HTML event.\n   * @param type - The type name of the event.\n   * @param detail - The event detail object to send with the event.\n   * @param options - The event options. By default bubbles and composed.\n   * @remarks\n   * Only emits events if connected.\n   */\n\n\n  emit(type, detail, options) {\n    if (this._isConnected) {\n      return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({\n        detail\n      }, defaultEventOptions), options)));\n    }\n\n    return false;\n  }\n\n  finishInitialization() {\n    const element = this.element;\n    const boundObservables = this.boundObservables; // If we have any observables that were bound, re-apply their values.\n\n    if (boundObservables !== null) {\n      const propertyNames = Object.keys(boundObservables);\n\n      for (let i = 0, ii = propertyNames.length; i < ii; ++i) {\n        const propertyName = propertyNames[i];\n        element[propertyName] = boundObservables[propertyName];\n      }\n\n      this.boundObservables = null;\n    }\n\n    const definition = this.definition; // 1. Template overrides take top precedence.\n\n    if (this._template === null) {\n      if (this.element.resolveTemplate) {\n        // 2. Allow for element instance overrides next.\n        this._template = this.element.resolveTemplate();\n      } else if (definition.template) {\n        // 3. Default to the static definition.\n        this._template = definition.template || null;\n      }\n    } // If we have a template after the above process, render it.\n    // If there's no template, then the element author has opted into\n    // custom rendering and they will managed the shadow root's content themselves.\n\n\n    if (this._template !== null) {\n      this.renderTemplate(this._template);\n    } // 1. Styles overrides take top precedence.\n\n\n    if (this._styles === null) {\n      if (this.element.resolveStyles) {\n        // 2. Allow for element instance overrides next.\n        this._styles = this.element.resolveStyles();\n      } else if (definition.styles) {\n        // 3. Default to the static definition.\n        this._styles = definition.styles || null;\n      }\n    } // If we have styles after the above process, add them.\n\n\n    if (this._styles !== null) {\n      this.addStyles(this._styles);\n    }\n\n    this.needsInitialization = false;\n  }\n\n  renderTemplate(template) {\n    const element = this.element; // When getting the host to render to, we start by looking\n    // up the shadow root. If there isn't one, then that means\n    // we're doing a Light DOM render to the element's direct children.\n\n    const host = getShadowRoot(element) || element;\n\n    if (this.view !== null) {\n      // If there's already a view, we need to unbind and remove through dispose.\n      this.view.dispose();\n      this.view = null;\n    } else if (!this.needsInitialization) {\n      // If there was previous custom rendering, we need to clear out the host.\n      DOM.removeChildNodes(host);\n    }\n\n    if (template) {\n      // If a new template was provided, render it.\n      this.view = template.render(element, host, element);\n    }\n  }\n  /**\n   * Locates or creates a controller for the specified element.\n   * @param element - The element to return the controller for.\n   * @remarks\n   * The specified element must have a {@link FASTElementDefinition}\n   * registered either through the use of the {@link customElement}\n   * decorator or a call to `FASTElement.define`.\n   */\n\n\n  static forCustomElement(element) {\n    const controller = element.$fastController;\n\n    if (controller !== void 0) {\n      return controller;\n    }\n\n    const definition = FASTElementDefinition.forType(element.constructor);\n\n    if (definition === void 0) {\n      throw new Error(\"Missing FASTElement definition.\");\n    }\n\n    return element.$fastController = new Controller(element, definition);\n  }\n\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-element/dist/esm/components/controller.js"],"names":["DOM","PropertyChangeNotifier","defaultExecutionContext","Observable","FASTElementDefinition","shadowRoots","WeakMap","defaultEventOptions","bubbles","composed","cancelable","getShadowRoot","element","shadowRoot","get","Controller","constructor","definition","boundObservables","behaviors","needsInitialization","_template","_styles","_isConnected","$fastController","view","shadowOptions","attachShadow","mode","set","accessors","getAccessors","length","Object","create","i","ii","propertyName","name","value","isConnected","track","setIsConnected","notify","template","renderTemplate","styles","removeStyles","addStyles","target","getRootNode","HTMLStyleElement","append","isAttachedTo","sourceBehaviors","addStylesTo","addBehaviors","removeChild","removeStylesFrom","removeBehaviors","targetBehaviors","Map","behaviorsToBind","behavior","has","push","bind","force","behaviorsToUnbind","count","delete","unbind","onConnectedCallback","finishInitialization","onDisconnectedCallback","onAttributeChangedCallback","oldValue","newValue","attrDef","attributeLookup","emit","type","detail","options","dispatchEvent","CustomEvent","assign","propertyNames","keys","resolveTemplate","resolveStyles","host","dispose","removeChildNodes","render","forCustomElement","controller","forType","Error"],"mappings":"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","sourcesContent":["import { DOM } from \"../dom\";\nimport { PropertyChangeNotifier } from \"../observation/notifier\";\nimport { defaultExecutionContext, Observable } from \"../observation/observable\";\nimport { FASTElementDefinition } from \"./fast-definitions\";\nconst shadowRoots = new WeakMap();\nconst defaultEventOptions = {\n    bubbles: true,\n    composed: true,\n    cancelable: true,\n};\nfunction getShadowRoot(element) {\n    return element.shadowRoot || shadowRoots.get(element) || null;\n}\n/**\n * Controls the lifecycle and rendering of a `FASTElement`.\n * @public\n */\nexport class Controller extends PropertyChangeNotifier {\n    /**\n     * Creates a Controller to control the specified element.\n     * @param element - The element to be controlled by this controller.\n     * @param definition - The element definition metadata that instructs this\n     * controller in how to handle rendering and other platform integrations.\n     * @internal\n     */\n    constructor(element, definition) {\n        super(element);\n        this.boundObservables = null;\n        this.behaviors = null;\n        this.needsInitialization = true;\n        this._template = null;\n        this._styles = null;\n        this._isConnected = false;\n        /**\n         * This allows Observable.getNotifier(...) to return the Controller\n         * when the notifier for the Controller itself is being requested. The\n         * result is that the Observable system does not need to create a separate\n         * instance of Notifier for observables on the Controller. The component and\n         * the controller will now share the same notifier, removing one-object construct\n         * per web component instance.\n         */\n        this.$fastController = this;\n        /**\n         * The view associated with the custom element.\n         * @remarks\n         * If `null` then the element is managing its own rendering.\n         */\n        this.view = null;\n        this.element = element;\n        this.definition = definition;\n        const shadowOptions = definition.shadowOptions;\n        if (shadowOptions !== void 0) {\n            const shadowRoot = element.attachShadow(shadowOptions);\n            if (shadowOptions.mode === \"closed\") {\n                shadowRoots.set(element, shadowRoot);\n            }\n        }\n        // Capture any observable values that were set by the binding engine before\n        // the browser upgraded the element. Then delete the property since it will\n        // shadow the getter/setter that is required to make the observable operate.\n        // Later, in the connect callback, we'll re-apply the values.\n        const accessors = Observable.getAccessors(element);\n        if (accessors.length > 0) {\n            const boundObservables = (this.boundObservables = Object.create(null));\n            for (let i = 0, ii = accessors.length; i < ii; ++i) {\n                const propertyName = accessors[i].name;\n                const value = element[propertyName];\n                if (value !== void 0) {\n                    delete element[propertyName];\n                    boundObservables[propertyName] = value;\n                }\n            }\n        }\n    }\n    /**\n     * Indicates whether or not the custom element has been\n     * connected to the document.\n     */\n    get isConnected() {\n        Observable.track(this, \"isConnected\");\n        return this._isConnected;\n    }\n    setIsConnected(value) {\n        this._isConnected = value;\n        Observable.notify(this, \"isConnected\");\n    }\n    /**\n     * Gets/sets the template used to render the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n    get template() {\n        return this._template;\n    }\n    set template(value) {\n        if (this._template === value) {\n            return;\n        }\n        this._template = value;\n        if (!this.needsInitialization) {\n            this.renderTemplate(value);\n        }\n    }\n    /**\n     * Gets/sets the primary styles used for the component.\n     * @remarks\n     * This value can only be accurately read after connect but can be set at any time.\n     */\n    get styles() {\n        return this._styles;\n    }\n    set styles(value) {\n        if (this._styles === value) {\n            return;\n        }\n        if (this._styles !== null) {\n            this.removeStyles(this._styles);\n        }\n        this._styles = value;\n        if (!this.needsInitialization && value !== null) {\n            this.addStyles(value);\n        }\n    }\n    /**\n     * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.\n     * @param styles - The styles to add.\n     */\n    addStyles(styles) {\n        const target = getShadowRoot(this.element) ||\n            this.element.getRootNode();\n        if (styles instanceof HTMLStyleElement) {\n            target.append(styles);\n        }\n        else if (!styles.isAttachedTo(target)) {\n            const sourceBehaviors = styles.behaviors;\n            styles.addStylesTo(target);\n            if (sourceBehaviors !== null) {\n                this.addBehaviors(sourceBehaviors);\n            }\n        }\n    }\n    /**\n     * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.\n     * @param styles - the styles to remove.\n     */\n    removeStyles(styles) {\n        const target = getShadowRoot(this.element) ||\n            this.element.getRootNode();\n        if (styles instanceof HTMLStyleElement) {\n            target.removeChild(styles);\n        }\n        else if (styles.isAttachedTo(target)) {\n            const sourceBehaviors = styles.behaviors;\n            styles.removeStylesFrom(target);\n            if (sourceBehaviors !== null) {\n                this.removeBehaviors(sourceBehaviors);\n            }\n        }\n    }\n    /**\n     * Adds behaviors to this element.\n     * @param behaviors - The behaviors to add.\n     */\n    addBehaviors(behaviors) {\n        const targetBehaviors = this.behaviors || (this.behaviors = new Map());\n        const length = behaviors.length;\n        const behaviorsToBind = [];\n        for (let i = 0; i < length; ++i) {\n            const behavior = behaviors[i];\n            if (targetBehaviors.has(behavior)) {\n                targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);\n            }\n            else {\n                targetBehaviors.set(behavior, 1);\n                behaviorsToBind.push(behavior);\n            }\n        }\n        if (this._isConnected) {\n            const element = this.element;\n            for (let i = 0; i < behaviorsToBind.length; ++i) {\n                behaviorsToBind[i].bind(element, defaultExecutionContext);\n            }\n        }\n    }\n    /**\n     * Removes behaviors from this element.\n     * @param behaviors - The behaviors to remove.\n     * @param force - Forces unbinding of behaviors.\n     */\n    removeBehaviors(behaviors, force = false) {\n        const targetBehaviors = this.behaviors;\n        if (targetBehaviors === null) {\n            return;\n        }\n        const length = behaviors.length;\n        const behaviorsToUnbind = [];\n        for (let i = 0; i < length; ++i) {\n            const behavior = behaviors[i];\n            if (targetBehaviors.has(behavior)) {\n                const count = targetBehaviors.get(behavior) - 1;\n                count === 0 || force\n                    ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior)\n                    : targetBehaviors.set(behavior, count);\n            }\n        }\n        if (this._isConnected) {\n            const element = this.element;\n            for (let i = 0; i < behaviorsToUnbind.length; ++i) {\n                behaviorsToUnbind[i].unbind(element);\n            }\n        }\n    }\n    /**\n     * Runs connected lifecycle behavior on the associated element.\n     */\n    onConnectedCallback() {\n        if (this._isConnected) {\n            return;\n        }\n        const element = this.element;\n        if (this.needsInitialization) {\n            this.finishInitialization();\n        }\n        else if (this.view !== null) {\n            this.view.bind(element, defaultExecutionContext);\n        }\n        const behaviors = this.behaviors;\n        if (behaviors !== null) {\n            for (const [behavior] of behaviors) {\n                behavior.bind(element, defaultExecutionContext);\n            }\n        }\n        this.setIsConnected(true);\n    }\n    /**\n     * Runs disconnected lifecycle behavior on the associated element.\n     */\n    onDisconnectedCallback() {\n        if (!this._isConnected) {\n            return;\n        }\n        this.setIsConnected(false);\n        const view = this.view;\n        if (view !== null) {\n            view.unbind();\n        }\n        const behaviors = this.behaviors;\n        if (behaviors !== null) {\n            const element = this.element;\n            for (const [behavior] of behaviors) {\n                behavior.unbind(element);\n            }\n        }\n    }\n    /**\n     * Runs the attribute changed callback for the associated element.\n     * @param name - The name of the attribute that changed.\n     * @param oldValue - The previous value of the attribute.\n     * @param newValue - The new value of the attribute.\n     */\n    onAttributeChangedCallback(name, oldValue, newValue) {\n        const attrDef = this.definition.attributeLookup[name];\n        if (attrDef !== void 0) {\n            attrDef.onAttributeChangedCallback(this.element, newValue);\n        }\n    }\n    /**\n     * Emits a custom HTML event.\n     * @param type - The type name of the event.\n     * @param detail - The event detail object to send with the event.\n     * @param options - The event options. By default bubbles and composed.\n     * @remarks\n     * Only emits events if connected.\n     */\n    emit(type, detail, options) {\n        if (this._isConnected) {\n            return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));\n        }\n        return false;\n    }\n    finishInitialization() {\n        const element = this.element;\n        const boundObservables = this.boundObservables;\n        // If we have any observables that were bound, re-apply their values.\n        if (boundObservables !== null) {\n            const propertyNames = Object.keys(boundObservables);\n            for (let i = 0, ii = propertyNames.length; i < ii; ++i) {\n                const propertyName = propertyNames[i];\n                element[propertyName] = boundObservables[propertyName];\n            }\n            this.boundObservables = null;\n        }\n        const definition = this.definition;\n        // 1. Template overrides take top precedence.\n        if (this._template === null) {\n            if (this.element.resolveTemplate) {\n                // 2. Allow for element instance overrides next.\n                this._template = this.element.resolveTemplate();\n            }\n            else if (definition.template) {\n                // 3. Default to the static definition.\n                this._template = definition.template || null;\n            }\n        }\n        // If we have a template after the above process, render it.\n        // If there's no template, then the element author has opted into\n        // custom rendering and they will managed the shadow root's content themselves.\n        if (this._template !== null) {\n            this.renderTemplate(this._template);\n        }\n        // 1. Styles overrides take top precedence.\n        if (this._styles === null) {\n            if (this.element.resolveStyles) {\n                // 2. Allow for element instance overrides next.\n                this._styles = this.element.resolveStyles();\n            }\n            else if (definition.styles) {\n                // 3. Default to the static definition.\n                this._styles = definition.styles || null;\n            }\n        }\n        // If we have styles after the above process, add them.\n        if (this._styles !== null) {\n            this.addStyles(this._styles);\n        }\n        this.needsInitialization = false;\n    }\n    renderTemplate(template) {\n        const element = this.element;\n        // When getting the host to render to, we start by looking\n        // up the shadow root. If there isn't one, then that means\n        // we're doing a Light DOM render to the element's direct children.\n        const host = getShadowRoot(element) || element;\n        if (this.view !== null) {\n            // If there's already a view, we need to unbind and remove through dispose.\n            this.view.dispose();\n            this.view = null;\n        }\n        else if (!this.needsInitialization) {\n            // If there was previous custom rendering, we need to clear out the host.\n            DOM.removeChildNodes(host);\n        }\n        if (template) {\n            // If a new template was provided, render it.\n            this.view = template.render(element, host, element);\n        }\n    }\n    /**\n     * Locates or creates a controller for the specified element.\n     * @param element - The element to return the controller for.\n     * @remarks\n     * The specified element must have a {@link FASTElementDefinition}\n     * registered either through the use of the {@link customElement}\n     * decorator or a call to `FASTElement.define`.\n     */\n    static forCustomElement(element) {\n        const controller = element.$fastController;\n        if (controller !== void 0) {\n            return controller;\n        }\n        const definition = FASTElementDefinition.forType(element.constructor);\n        if (definition === void 0) {\n            throw new Error(\"Missing FASTElement definition.\");\n        }\n        return (element.$fastController = new Controller(element, definition));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}