{"ast":null,"code":"import { clamp, ColorHSL, ColorLAB, ColorRGBA64, hslToRGB, interpolateRGB, labToRGB, rgbToHSL, rgbToLAB, roundToPrecisionSmall } from '@microsoft/fast-colors';\nimport { isSwatchRGB, SwatchRGB } from './swatch';\nimport { binarySearch } from './utilities/binary-search';\nimport { directionByIsDark } from './utilities/direction-by-is-dark';\nimport { contrast } from './utilities/relative-luminance';\nconst defaultPaletteRGBOptions = {\n  stepContrast: 1.03,\n  stepContrastRamp: 0.03,\n  preserveSource: false\n};\n\nfunction create(rOrSource, g, b) {\n  if (typeof rOrSource === 'number') {\n    return PaletteRGB.from(SwatchRGB.create(rOrSource, g, b));\n  } else {\n    return PaletteRGB.from(rOrSource);\n  }\n}\n\nfunction from(source, options) {\n  return isSwatchRGB(source) ? PaletteRGBImpl.from(source, options) : PaletteRGBImpl.from(SwatchRGB.create(source.r, source.g, source.b), options);\n}\n/** @public */\n\n\nexport const PaletteRGB = Object.freeze({\n  create,\n  from\n});\n/**\n * A {@link Palette} representing RGB swatch values.\n * @public\n */\n\nclass PaletteRGBImpl {\n  /**\n   *\n   * @param source - The source color for the palette\n   * @param swatches - All swatches in the palette\n   */\n  constructor(source, swatches) {\n    this.closestIndexCache = new Map();\n    this.source = source;\n    this.swatches = swatches;\n    this.reversedSwatches = Object.freeze([...this.swatches].reverse());\n    this.lastIndex = this.swatches.length - 1;\n  }\n  /**\n   * {@inheritdoc Palette.colorContrast}\n   */\n\n\n  colorContrast(reference, contrastTarget, initialSearchIndex, direction) {\n    if (initialSearchIndex === undefined) {\n      initialSearchIndex = this.closestIndexOf(reference);\n    }\n\n    let source = this.swatches;\n    const endSearchIndex = this.lastIndex;\n    let startSearchIndex = initialSearchIndex;\n\n    if (direction === undefined) {\n      direction = directionByIsDark(reference);\n    }\n\n    const condition = value => contrast(reference, value) >= contrastTarget;\n\n    if (direction === -1) {\n      source = this.reversedSwatches;\n      startSearchIndex = endSearchIndex - startSearchIndex;\n    }\n\n    return binarySearch(source, condition, startSearchIndex, endSearchIndex);\n  }\n  /**\n   * {@inheritdoc Palette.get}\n   */\n\n\n  get(index) {\n    return this.swatches[index] || this.swatches[clamp(index, 0, this.lastIndex)];\n  }\n  /**\n   * {@inheritdoc Palette.closestIndexOf}\n   */\n\n\n  closestIndexOf(reference) {\n    if (this.closestIndexCache.has(reference.relativeLuminance)) {\n      return this.closestIndexCache.get(reference.relativeLuminance);\n    }\n\n    let index = this.swatches.indexOf(reference);\n\n    if (index !== -1) {\n      this.closestIndexCache.set(reference.relativeLuminance, index);\n      return index;\n    }\n\n    const closest = this.swatches.reduce((previous, next) => Math.abs(next.relativeLuminance - reference.relativeLuminance) < Math.abs(previous.relativeLuminance - reference.relativeLuminance) ? next : previous);\n    index = this.swatches.indexOf(closest);\n    this.closestIndexCache.set(reference.relativeLuminance, index);\n    return index;\n  }\n  /**\n   * Bump the saturation if it falls below the reference color saturation.\n   * @param reference Color with target saturation\n   * @param color Color to check and bump if below target saturation\n   * @returns Original or adjusted color\n   */\n\n\n  static saturationBump(reference, color) {\n    const hslReference = rgbToHSL(reference);\n    const saturationTarget = hslReference.s;\n    const hslColor = rgbToHSL(color);\n\n    if (hslColor.s < saturationTarget) {\n      const hslNew = new ColorHSL(hslColor.h, saturationTarget, hslColor.l);\n      return hslToRGB(hslNew);\n    }\n\n    return color;\n  }\n  /**\n   * Scales input from 0 to 100 to 0 to 0.5.\n   * @param l Input number, 0 to 100\n   * @returns Output number, 0 to 0.5\n   */\n\n\n  static ramp(l) {\n    const inputval = l / 100;\n    if (inputval > 0.5) return (inputval - 0.5) / 0.5; //from 0.500001in = 0.00000001out to 1.0in = 1.0out\n\n    return 2 * inputval; //from 0in = 0out to 0.5in = 1.0out\n  }\n  /**\n   * Create a palette following the desired curve and many steps to build a smaller palette from.\n   * @param source The source swatch to create a palette from\n   * @returns The palette\n   */\n\n\n  static createHighResolutionPalette(source) {\n    const swatches = [];\n    const labSource = rgbToLAB(ColorRGBA64.fromObject(source).roundToPrecision(4));\n    const lab0 = labToRGB(new ColorLAB(0, labSource.a, labSource.b)).clamp().roundToPrecision(4);\n    const lab50 = labToRGB(new ColorLAB(50, labSource.a, labSource.b)).clamp().roundToPrecision(4);\n    const lab100 = labToRGB(new ColorLAB(100, labSource.a, labSource.b)).clamp().roundToPrecision(4);\n    const rgbMin = new ColorRGBA64(0, 0, 0);\n    const rgbMax = new ColorRGBA64(1, 1, 1);\n    const lAbove = lab100.equalValue(rgbMax) ? 0 : 14;\n    const lBelow = lab0.equalValue(rgbMin) ? 0 : 14; // 257 levels max, depending on whether lab0 or lab100 are black or white respectively.\n\n    for (let l = 100 + lAbove; l >= 0 - lBelow; l -= 0.5) {\n      let rgb;\n\n      if (l < 0) {\n        // For L less than 0, scale from black to L=0\n        const percentFromRgbMinToLab0 = l / lBelow + 1;\n        rgb = interpolateRGB(percentFromRgbMinToLab0, rgbMin, lab0);\n      } else if (l <= 50) {\n        // For L less than 50, we scale from L=0 to the base color\n        rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab0, lab50);\n      } else if (l <= 100) {\n        // For L less than 100, scale from the base color to L=100\n        rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab50, lab100);\n      } else {\n        // For L greater than 100, scale from L=100 to white\n        const percentFromLab100ToRgbMax = (l - 100.0) / lAbove;\n        rgb = interpolateRGB(percentFromLab100ToRgbMax, lab100, rgbMax);\n      }\n\n      rgb = PaletteRGBImpl.saturationBump(lab50, rgb).roundToPrecision(4);\n      swatches.push(SwatchRGB.from(rgb));\n    }\n\n    return new PaletteRGBImpl(source, swatches);\n  }\n  /**\n   * Adjust one end of the contrast-based palette so it doesn't abruptly fall to black (or white).\n   * @param swatchContrast Function to get the target contrast for the next swatch\n   * @param referencePalette The high resolution palette\n   * @param targetPalette The contrast-based palette to adjust\n   * @param direction The end to adjust\n   */\n\n\n  static adjustEnd(swatchContrast, referencePalette, targetPalette, direction) {\n    // Careful with the use of referencePalette as only the refSwatches is reversed.\n    const refSwatches = direction === -1 ? referencePalette.swatches : referencePalette.reversedSwatches;\n\n    const refIndex = swatch => {\n      const index = referencePalette.closestIndexOf(swatch);\n      return direction === 1 ? referencePalette.lastIndex - index : index;\n    }; // Only operates on the 'end' end of the array, so flip if we're adjusting the 'beginning'\n\n\n    if (direction === 1) {\n      targetPalette.reverse();\n    }\n\n    const targetContrast = swatchContrast(targetPalette[targetPalette.length - 2]);\n    const actualContrast = roundToPrecisionSmall(contrast(targetPalette[targetPalette.length - 1], targetPalette[targetPalette.length - 2]), 2);\n\n    if (actualContrast < targetContrast) {\n      // Remove last swatch if not sufficient contrast\n      targetPalette.pop(); // Distribute to the last swatch\n\n      const safeSecondSwatch = referencePalette.colorContrast(refSwatches[referencePalette.lastIndex], targetContrast, undefined, direction);\n      const safeSecondRefIndex = refIndex(safeSecondSwatch);\n      const targetSwatchCurrentRefIndex = refIndex(targetPalette[targetPalette.length - 2]);\n      const swatchesToSpace = safeSecondRefIndex - targetSwatchCurrentRefIndex;\n      let space = 1;\n\n      for (let i = targetPalette.length - swatchesToSpace - 1; i < targetPalette.length; i++) {\n        const currentRefIndex = refIndex(targetPalette[i]);\n        const nextRefIndex = i === targetPalette.length - 1 ? referencePalette.lastIndex : currentRefIndex + space;\n        targetPalette[i] = refSwatches[nextRefIndex];\n        space++;\n      }\n    }\n\n    if (direction === 1) {\n      targetPalette.reverse();\n    }\n  }\n  /**\n   * Generate a palette with consistent minimum contrast between swatches.\n   * @param source The source color\n   * @param options Palette generation options\n   * @returns A palette meeting the requested contrast between swatches.\n   */\n\n\n  static createColorPaletteByContrast(source, options) {\n    const referencePalette = PaletteRGBImpl.createHighResolutionPalette(source); // Ramp function to increase contrast as the swatches get darker\n\n    const nextContrast = swatch => {\n      const c = options.stepContrast + options.stepContrast * (1 - swatch.relativeLuminance) * options.stepContrastRamp;\n      return roundToPrecisionSmall(c, 2);\n    };\n\n    const swatches = []; // Start with the source color or the light end color\n\n    let ref = options.preserveSource ? source : referencePalette.swatches[0];\n    swatches.push(ref); // Add swatches with contrast toward dark\n\n    do {\n      const targetContrast = nextContrast(ref);\n      ref = referencePalette.colorContrast(ref, targetContrast, undefined, 1);\n      swatches.push(ref);\n    } while (ref.relativeLuminance > 0); // Add swatches with contrast toward light\n\n\n    if (options.preserveSource) {\n      ref = source;\n\n      do {\n        // This is off from the dark direction because `ref` here is the darker swatch, probably subtle\n        const targetContrast = nextContrast(ref);\n        ref = referencePalette.colorContrast(ref, targetContrast, undefined, -1);\n        swatches.unshift(ref);\n      } while (ref.relativeLuminance < 1);\n    } // Validate dark end\n\n\n    this.adjustEnd(nextContrast, referencePalette, swatches, -1); // Validate light end\n\n    if (options.preserveSource) {\n      this.adjustEnd(nextContrast, referencePalette, swatches, 1);\n    }\n\n    return swatches;\n  }\n  /**\n   * Create a color palette from a provided swatch\n   * @param source - The source swatch to create a palette from\n   * @returns\n   */\n\n\n  static from(source, options) {\n    const opts = options === void 0 || null ? defaultPaletteRGBOptions : Object.assign(Object.assign({}, defaultPaletteRGBOptions), options);\n    return new PaletteRGBImpl(source, Object.freeze(PaletteRGBImpl.createColorPaletteByContrast(source, opts)));\n  }\n\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@fluentui/web-components/dist/esm/color/palette.js"],"names":["clamp","ColorHSL","ColorLAB","ColorRGBA64","hslToRGB","interpolateRGB","labToRGB","rgbToHSL","rgbToLAB","roundToPrecisionSmall","isSwatchRGB","SwatchRGB","binarySearch","directionByIsDark","contrast","defaultPaletteRGBOptions","stepContrast","stepContrastRamp","preserveSource","create","rOrSource","g","b","PaletteRGB","from","source","options","PaletteRGBImpl","r","Object","freeze","constructor","swatches","closestIndexCache","Map","reversedSwatches","reverse","lastIndex","length","colorContrast","reference","contrastTarget","initialSearchIndex","direction","undefined","closestIndexOf","endSearchIndex","startSearchIndex","condition","value","get","index","has","relativeLuminance","indexOf","set","closest","reduce","previous","next","Math","abs","saturationBump","color","hslReference","saturationTarget","s","hslColor","hslNew","h","l","ramp","inputval","createHighResolutionPalette","labSource","fromObject","roundToPrecision","lab0","a","lab50","lab100","rgbMin","rgbMax","lAbove","equalValue","lBelow","rgb","percentFromRgbMinToLab0","percentFromLab100ToRgbMax","push","adjustEnd","swatchContrast","referencePalette","targetPalette","refSwatches","refIndex","swatch","targetContrast","actualContrast","pop","safeSecondSwatch","safeSecondRefIndex","targetSwatchCurrentRefIndex","swatchesToSpace","space","i","currentRefIndex","nextRefIndex","createColorPaletteByContrast","nextContrast","c","ref","unshift","opts","assign"],"mappings":"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","sourcesContent":["import { clamp, ColorHSL, ColorLAB, ColorRGBA64, hslToRGB, interpolateRGB, labToRGB, rgbToHSL, rgbToLAB, roundToPrecisionSmall, } from '@microsoft/fast-colors';\nimport { isSwatchRGB, SwatchRGB } from './swatch';\nimport { binarySearch } from './utilities/binary-search';\nimport { directionByIsDark } from './utilities/direction-by-is-dark';\nimport { contrast } from './utilities/relative-luminance';\nconst defaultPaletteRGBOptions = {\n    stepContrast: 1.03,\n    stepContrastRamp: 0.03,\n    preserveSource: false,\n};\nfunction create(rOrSource, g, b) {\n    if (typeof rOrSource === 'number') {\n        return PaletteRGB.from(SwatchRGB.create(rOrSource, g, b));\n    }\n    else {\n        return PaletteRGB.from(rOrSource);\n    }\n}\nfunction from(source, options) {\n    return isSwatchRGB(source)\n        ? PaletteRGBImpl.from(source, options)\n        : PaletteRGBImpl.from(SwatchRGB.create(source.r, source.g, source.b), options);\n}\n/** @public */\nexport const PaletteRGB = Object.freeze({\n    create,\n    from,\n});\n/**\n * A {@link Palette} representing RGB swatch values.\n * @public\n */\nclass PaletteRGBImpl {\n    /**\n     *\n     * @param source - The source color for the palette\n     * @param swatches - All swatches in the palette\n     */\n    constructor(source, swatches) {\n        this.closestIndexCache = new Map();\n        this.source = source;\n        this.swatches = swatches;\n        this.reversedSwatches = Object.freeze([...this.swatches].reverse());\n        this.lastIndex = this.swatches.length - 1;\n    }\n    /**\n     * {@inheritdoc Palette.colorContrast}\n     */\n    colorContrast(reference, contrastTarget, initialSearchIndex, direction) {\n        if (initialSearchIndex === undefined) {\n            initialSearchIndex = this.closestIndexOf(reference);\n        }\n        let source = this.swatches;\n        const endSearchIndex = this.lastIndex;\n        let startSearchIndex = initialSearchIndex;\n        if (direction === undefined) {\n            direction = directionByIsDark(reference);\n        }\n        const condition = (value) => contrast(reference, value) >= contrastTarget;\n        if (direction === -1) {\n            source = this.reversedSwatches;\n            startSearchIndex = endSearchIndex - startSearchIndex;\n        }\n        return binarySearch(source, condition, startSearchIndex, endSearchIndex);\n    }\n    /**\n     * {@inheritdoc Palette.get}\n     */\n    get(index) {\n        return this.swatches[index] || this.swatches[clamp(index, 0, this.lastIndex)];\n    }\n    /**\n     * {@inheritdoc Palette.closestIndexOf}\n     */\n    closestIndexOf(reference) {\n        if (this.closestIndexCache.has(reference.relativeLuminance)) {\n            return this.closestIndexCache.get(reference.relativeLuminance);\n        }\n        let index = this.swatches.indexOf(reference);\n        if (index !== -1) {\n            this.closestIndexCache.set(reference.relativeLuminance, index);\n            return index;\n        }\n        const closest = this.swatches.reduce((previous, next) => Math.abs(next.relativeLuminance - reference.relativeLuminance) <\n            Math.abs(previous.relativeLuminance - reference.relativeLuminance)\n            ? next\n            : previous);\n        index = this.swatches.indexOf(closest);\n        this.closestIndexCache.set(reference.relativeLuminance, index);\n        return index;\n    }\n    /**\n     * Bump the saturation if it falls below the reference color saturation.\n     * @param reference Color with target saturation\n     * @param color Color to check and bump if below target saturation\n     * @returns Original or adjusted color\n     */\n    static saturationBump(reference, color) {\n        const hslReference = rgbToHSL(reference);\n        const saturationTarget = hslReference.s;\n        const hslColor = rgbToHSL(color);\n        if (hslColor.s < saturationTarget) {\n            const hslNew = new ColorHSL(hslColor.h, saturationTarget, hslColor.l);\n            return hslToRGB(hslNew);\n        }\n        return color;\n    }\n    /**\n     * Scales input from 0 to 100 to 0 to 0.5.\n     * @param l Input number, 0 to 100\n     * @returns Output number, 0 to 0.5\n     */\n    static ramp(l) {\n        const inputval = l / 100;\n        if (inputval > 0.5)\n            return (inputval - 0.5) / 0.5; //from 0.500001in = 0.00000001out to 1.0in = 1.0out\n        return 2 * inputval; //from 0in = 0out to 0.5in = 1.0out\n    }\n    /**\n     * Create a palette following the desired curve and many steps to build a smaller palette from.\n     * @param source The source swatch to create a palette from\n     * @returns The palette\n     */\n    static createHighResolutionPalette(source) {\n        const swatches = [];\n        const labSource = rgbToLAB(ColorRGBA64.fromObject(source).roundToPrecision(4));\n        const lab0 = labToRGB(new ColorLAB(0, labSource.a, labSource.b)).clamp().roundToPrecision(4);\n        const lab50 = labToRGB(new ColorLAB(50, labSource.a, labSource.b)).clamp().roundToPrecision(4);\n        const lab100 = labToRGB(new ColorLAB(100, labSource.a, labSource.b)).clamp().roundToPrecision(4);\n        const rgbMin = new ColorRGBA64(0, 0, 0);\n        const rgbMax = new ColorRGBA64(1, 1, 1);\n        const lAbove = lab100.equalValue(rgbMax) ? 0 : 14;\n        const lBelow = lab0.equalValue(rgbMin) ? 0 : 14;\n        // 257 levels max, depending on whether lab0 or lab100 are black or white respectively.\n        for (let l = 100 + lAbove; l >= 0 - lBelow; l -= 0.5) {\n            let rgb;\n            if (l < 0) {\n                // For L less than 0, scale from black to L=0\n                const percentFromRgbMinToLab0 = l / lBelow + 1;\n                rgb = interpolateRGB(percentFromRgbMinToLab0, rgbMin, lab0);\n            }\n            else if (l <= 50) {\n                // For L less than 50, we scale from L=0 to the base color\n                rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab0, lab50);\n            }\n            else if (l <= 100) {\n                // For L less than 100, scale from the base color to L=100\n                rgb = interpolateRGB(PaletteRGBImpl.ramp(l), lab50, lab100);\n            }\n            else {\n                // For L greater than 100, scale from L=100 to white\n                const percentFromLab100ToRgbMax = (l - 100.0) / lAbove;\n                rgb = interpolateRGB(percentFromLab100ToRgbMax, lab100, rgbMax);\n            }\n            rgb = PaletteRGBImpl.saturationBump(lab50, rgb).roundToPrecision(4);\n            swatches.push(SwatchRGB.from(rgb));\n        }\n        return new PaletteRGBImpl(source, swatches);\n    }\n    /**\n     * Adjust one end of the contrast-based palette so it doesn't abruptly fall to black (or white).\n     * @param swatchContrast Function to get the target contrast for the next swatch\n     * @param referencePalette The high resolution palette\n     * @param targetPalette The contrast-based palette to adjust\n     * @param direction The end to adjust\n     */\n    static adjustEnd(swatchContrast, referencePalette, targetPalette, direction) {\n        // Careful with the use of referencePalette as only the refSwatches is reversed.\n        const refSwatches = direction === -1 ? referencePalette.swatches : referencePalette.reversedSwatches;\n        const refIndex = (swatch) => {\n            const index = referencePalette.closestIndexOf(swatch);\n            return direction === 1 ? referencePalette.lastIndex - index : index;\n        };\n        // Only operates on the 'end' end of the array, so flip if we're adjusting the 'beginning'\n        if (direction === 1) {\n            targetPalette.reverse();\n        }\n        const targetContrast = swatchContrast(targetPalette[targetPalette.length - 2]);\n        const actualContrast = roundToPrecisionSmall(contrast(targetPalette[targetPalette.length - 1], targetPalette[targetPalette.length - 2]), 2);\n        if (actualContrast < targetContrast) {\n            // Remove last swatch if not sufficient contrast\n            targetPalette.pop();\n            // Distribute to the last swatch\n            const safeSecondSwatch = referencePalette.colorContrast(refSwatches[referencePalette.lastIndex], targetContrast, undefined, direction);\n            const safeSecondRefIndex = refIndex(safeSecondSwatch);\n            const targetSwatchCurrentRefIndex = refIndex(targetPalette[targetPalette.length - 2]);\n            const swatchesToSpace = safeSecondRefIndex - targetSwatchCurrentRefIndex;\n            let space = 1;\n            for (let i = targetPalette.length - swatchesToSpace - 1; i < targetPalette.length; i++) {\n                const currentRefIndex = refIndex(targetPalette[i]);\n                const nextRefIndex = i === targetPalette.length - 1 ? referencePalette.lastIndex : currentRefIndex + space;\n                targetPalette[i] = refSwatches[nextRefIndex];\n                space++;\n            }\n        }\n        if (direction === 1) {\n            targetPalette.reverse();\n        }\n    }\n    /**\n     * Generate a palette with consistent minimum contrast between swatches.\n     * @param source The source color\n     * @param options Palette generation options\n     * @returns A palette meeting the requested contrast between swatches.\n     */\n    static createColorPaletteByContrast(source, options) {\n        const referencePalette = PaletteRGBImpl.createHighResolutionPalette(source);\n        // Ramp function to increase contrast as the swatches get darker\n        const nextContrast = (swatch) => {\n            const c = options.stepContrast + options.stepContrast * (1 - swatch.relativeLuminance) * options.stepContrastRamp;\n            return roundToPrecisionSmall(c, 2);\n        };\n        const swatches = [];\n        // Start with the source color or the light end color\n        let ref = options.preserveSource ? source : referencePalette.swatches[0];\n        swatches.push(ref);\n        // Add swatches with contrast toward dark\n        do {\n            const targetContrast = nextContrast(ref);\n            ref = referencePalette.colorContrast(ref, targetContrast, undefined, 1);\n            swatches.push(ref);\n        } while (ref.relativeLuminance > 0);\n        // Add swatches with contrast toward light\n        if (options.preserveSource) {\n            ref = source;\n            do {\n                // This is off from the dark direction because `ref` here is the darker swatch, probably subtle\n                const targetContrast = nextContrast(ref);\n                ref = referencePalette.colorContrast(ref, targetContrast, undefined, -1);\n                swatches.unshift(ref);\n            } while (ref.relativeLuminance < 1);\n        }\n        // Validate dark end\n        this.adjustEnd(nextContrast, referencePalette, swatches, -1);\n        // Validate light end\n        if (options.preserveSource) {\n            this.adjustEnd(nextContrast, referencePalette, swatches, 1);\n        }\n        return swatches;\n    }\n    /**\n     * Create a color palette from a provided swatch\n     * @param source - The source swatch to create a palette from\n     * @returns\n     */\n    static from(source, options) {\n        const opts = options === void 0 || null ? defaultPaletteRGBOptions : Object.assign(Object.assign({}, defaultPaletteRGBOptions), options);\n        return new PaletteRGBImpl(source, Object.freeze(PaletteRGBImpl.createColorPaletteByContrast(source, opts)));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}