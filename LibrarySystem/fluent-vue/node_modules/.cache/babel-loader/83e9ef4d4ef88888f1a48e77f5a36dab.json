{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { $global } from \"./platform\";\nconst updateQueue = $global.FAST.getById(1\n/* updateQueue */\n, () => {\n  const tasks = [];\n  const pendingErrors = [];\n\n  function throwFirstError() {\n    if (pendingErrors.length) {\n      throw pendingErrors.shift();\n    }\n  }\n\n  function tryRunTask(task) {\n    try {\n      task.call();\n    } catch (error) {\n      pendingErrors.push(error);\n      setTimeout(throwFirstError, 0);\n    }\n  }\n\n  function process() {\n    const capacity = 1024;\n    let index = 0;\n\n    while (index < tasks.length) {\n      tryRunTask(tasks[index]);\n      index++; // Prevent leaking memory for long chains of recursive calls to `DOM.queueUpdate`.\n      // If we call `DOM.queueUpdate` within a task scheduled by `DOM.queueUpdate`, the queue will\n      // grow, but to avoid an O(n) walk for every task we execute, we don't\n      // shift tasks off the queue after they have been executed.\n      // Instead, we periodically shift 1024 tasks off the queue.\n\n      if (index > capacity) {\n        // Manually shift all values starting at the index back to the\n        // beginning of the queue.\n        for (let scan = 0, newLength = tasks.length - index; scan < newLength; scan++) {\n          tasks[scan] = tasks[scan + index];\n        }\n\n        tasks.length -= index;\n        index = 0;\n      }\n    }\n\n    tasks.length = 0;\n  }\n\n  function enqueue(callable) {\n    if (tasks.length < 1) {\n      $global.requestAnimationFrame(process);\n    }\n\n    tasks.push(callable);\n  }\n\n  return Object.freeze({\n    enqueue,\n    process\n  });\n});\n/* eslint-disable */\n\nconst fastHTMLPolicy = $global.trustedTypes.createPolicy(\"fast-html\", {\n  createHTML: html => html\n});\n/* eslint-enable */\n\nlet htmlPolicy = fastHTMLPolicy;\nconst marker = `fast-${Math.random().toString(36).substring(2, 8)}`;\n/** @internal */\n\nexport const _interpolationStart = `${marker}{`;\n/** @internal */\n\nexport const _interpolationEnd = `}${marker}`;\n/**\n * Common DOM APIs.\n * @public\n */\n\nexport const DOM = Object.freeze({\n  /**\n   * Indicates whether the DOM supports the adoptedStyleSheets feature.\n   */\n  supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) && \"replace\" in CSSStyleSheet.prototype,\n\n  /**\n   * Sets the HTML trusted types policy used by the templating engine.\n   * @param policy - The policy to set for HTML.\n   * @remarks\n   * This API can only be called once, for security reasons. It should be\n   * called by the application developer at the start of their program.\n   */\n  setHTMLPolicy(policy) {\n    if (htmlPolicy !== fastHTMLPolicy) {\n      throw new Error(\"The HTML policy can only be set once.\");\n    }\n\n    htmlPolicy = policy;\n  },\n\n  /**\n   * Turns a string into trusted HTML using the configured trusted types policy.\n   * @param html - The string to turn into trusted HTML.\n   * @remarks\n   * Used internally by the template engine when creating templates\n   * and setting innerHTML.\n   */\n  createHTML(html) {\n    return htmlPolicy.createHTML(html);\n  },\n\n  /**\n   * Determines if the provided node is a template marker used by the runtime.\n   * @param node - The node to test.\n   */\n  isMarker(node) {\n    return node && node.nodeType === 8 && node.data.startsWith(marker);\n  },\n\n  /**\n   * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.\n   * @param node - The marker node to extract the index from.\n   */\n  extractDirectiveIndexFromMarker(node) {\n    return parseInt(node.data.replace(`${marker}:`, \"\"));\n  },\n\n  /**\n   * Creates a placeholder string suitable for marking out a location *within*\n   * an attribute value or HTML content.\n   * @param index - The directive index to create the placeholder for.\n   * @remarks\n   * Used internally by binding directives.\n   */\n  createInterpolationPlaceholder(index) {\n    return `${_interpolationStart}${index}${_interpolationEnd}`;\n  },\n\n  /**\n   * Creates a placeholder that manifests itself as an attribute on an\n   * element.\n   * @param attributeName - The name of the custom attribute.\n   * @param index - The directive index to create the placeholder for.\n   * @remarks\n   * Used internally by attribute directives such as `ref`, `slotted`, and `children`.\n   */\n  createCustomAttributePlaceholder(attributeName, index) {\n    return `${attributeName}=\"${this.createInterpolationPlaceholder(index)}\"`;\n  },\n\n  /**\n   * Creates a placeholder that manifests itself as a marker within the DOM structure.\n   * @param index - The directive index to create the placeholder for.\n   * @remarks\n   * Used internally by structural directives such as `repeat`.\n   */\n  createBlockPlaceholder(index) {\n    return `<!--${marker}:${index}-->`;\n  },\n\n  /**\n   * Schedules DOM update work in the next async batch.\n   * @param callable - The callable function or object to queue.\n   */\n  queueUpdate: updateQueue.enqueue,\n\n  /**\n   * Immediately processes all work previously scheduled\n   * through queueUpdate.\n   * @remarks\n   * This also forces nextUpdate promises\n   * to resolve.\n   */\n  processUpdates: updateQueue.process,\n\n  /**\n   * Resolves with the next DOM update.\n   */\n  nextUpdate() {\n    return new Promise(updateQueue.enqueue);\n  },\n\n  /**\n   * Sets an attribute value on an element.\n   * @param element - The element to set the attribute value on.\n   * @param attributeName - The attribute name to set.\n   * @param value - The value of the attribute to set.\n   * @remarks\n   * If the value is `null` or `undefined`, the attribute is removed, otherwise\n   * it is set to the provided value using the standard `setAttribute` API.\n   */\n  setAttribute(element, attributeName, value) {\n    if (value === null || value === undefined) {\n      element.removeAttribute(attributeName);\n    } else {\n      element.setAttribute(attributeName, value);\n    }\n  },\n\n  /**\n   * Sets a boolean attribute value.\n   * @param element - The element to set the boolean attribute value on.\n   * @param attributeName - The attribute name to set.\n   * @param value - The value of the attribute to set.\n   * @remarks\n   * If the value is true, the attribute is added; otherwise it is removed.\n   */\n  setBooleanAttribute(element, attributeName, value) {\n    value ? element.setAttribute(attributeName, \"\") : element.removeAttribute(attributeName);\n  },\n\n  /**\n   * Removes all the child nodes of the provided parent node.\n   * @param parent - The node to remove the children from.\n   */\n  removeChildNodes(parent) {\n    for (let child = parent.firstChild; child !== null; child = parent.firstChild) {\n      parent.removeChild(child);\n    }\n  },\n\n  /**\n   * Creates a TreeWalker configured to walk a template fragment.\n   * @param fragment - The fragment to walk.\n   */\n  createTemplateWalker(fragment) {\n    return document.createTreeWalker(fragment, 133, // element, text, comment\n    null, false);\n  }\n\n});","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-element/dist/esm/dom.js"],"names":["$global","updateQueue","FAST","getById","tasks","pendingErrors","throwFirstError","length","shift","tryRunTask","task","call","error","push","setTimeout","process","capacity","index","scan","newLength","enqueue","callable","requestAnimationFrame","Object","freeze","fastHTMLPolicy","trustedTypes","createPolicy","createHTML","html","htmlPolicy","marker","Math","random","toString","substring","_interpolationStart","_interpolationEnd","DOM","supportsAdoptedStyleSheets","Array","isArray","document","adoptedStyleSheets","CSSStyleSheet","prototype","setHTMLPolicy","policy","Error","isMarker","node","nodeType","data","startsWith","extractDirectiveIndexFromMarker","parseInt","replace","createInterpolationPlaceholder","createCustomAttributePlaceholder","attributeName","createBlockPlaceholder","queueUpdate","processUpdates","nextUpdate","Promise","setAttribute","element","value","undefined","removeAttribute","setBooleanAttribute","removeChildNodes","parent","child","firstChild","removeChild","createTemplateWalker","fragment","createTreeWalker"],"mappings":";AAAA,SAASA,OAAT,QAAwB,YAAxB;AACA,MAAMC,WAAW,GAAGD,OAAO,CAACE,IAAR,CAAaC,OAAb,CAAqB;AAAE;AAAvB,EAA0C,MAAM;AAChE,QAAMC,KAAK,GAAG,EAAd;AACA,QAAMC,aAAa,GAAG,EAAtB;;AACA,WAASC,eAAT,GAA2B;AACvB,QAAID,aAAa,CAACE,MAAlB,EAA0B;AACtB,YAAMF,aAAa,CAACG,KAAd,EAAN;AACH;AACJ;;AACD,WAASC,UAAT,CAAoBC,IAApB,EAA0B;AACtB,QAAI;AACAA,MAAAA,IAAI,CAACC,IAAL;AACH,KAFD,CAGA,OAAOC,KAAP,EAAc;AACVP,MAAAA,aAAa,CAACQ,IAAd,CAAmBD,KAAnB;AACAE,MAAAA,UAAU,CAACR,eAAD,EAAkB,CAAlB,CAAV;AACH;AACJ;;AACD,WAASS,OAAT,GAAmB;AACf,UAAMC,QAAQ,GAAG,IAAjB;AACA,QAAIC,KAAK,GAAG,CAAZ;;AACA,WAAOA,KAAK,GAAGb,KAAK,CAACG,MAArB,EAA6B;AACzBE,MAAAA,UAAU,CAACL,KAAK,CAACa,KAAD,CAAN,CAAV;AACAA,MAAAA,KAAK,GAFoB,CAGzB;AACA;AACA;AACA;AACA;;AACA,UAAIA,KAAK,GAAGD,QAAZ,EAAsB;AAClB;AACA;AACA,aAAK,IAAIE,IAAI,GAAG,CAAX,EAAcC,SAAS,GAAGf,KAAK,CAACG,MAAN,GAAeU,KAA9C,EAAqDC,IAAI,GAAGC,SAA5D,EAAuED,IAAI,EAA3E,EAA+E;AAC3Ed,UAAAA,KAAK,CAACc,IAAD,CAAL,GAAcd,KAAK,CAACc,IAAI,GAAGD,KAAR,CAAnB;AACH;;AACDb,QAAAA,KAAK,CAACG,MAAN,IAAgBU,KAAhB;AACAA,QAAAA,KAAK,GAAG,CAAR;AACH;AACJ;;AACDb,IAAAA,KAAK,CAACG,MAAN,GAAe,CAAf;AACH;;AACD,WAASa,OAAT,CAAiBC,QAAjB,EAA2B;AACvB,QAAIjB,KAAK,CAACG,MAAN,GAAe,CAAnB,EAAsB;AAClBP,MAAAA,OAAO,CAACsB,qBAAR,CAA8BP,OAA9B;AACH;;AACDX,IAAAA,KAAK,CAACS,IAAN,CAAWQ,QAAX;AACH;;AACD,SAAOE,MAAM,CAACC,MAAP,CAAc;AACjBJ,IAAAA,OADiB;AAEjBL,IAAAA;AAFiB,GAAd,CAAP;AAIH,CAlDmB,CAApB;AAmDA;;AACA,MAAMU,cAAc,GAAGzB,OAAO,CAAC0B,YAAR,CAAqBC,YAArB,CAAkC,WAAlC,EAA+C;AAClEC,EAAAA,UAAU,EAAEC,IAAI,IAAIA;AAD8C,CAA/C,CAAvB;AAGA;;AACA,IAAIC,UAAU,GAAGL,cAAjB;AACA,MAAMM,MAAM,GAAI,QAAOC,IAAI,CAACC,MAAL,GAAcC,QAAd,CAAuB,EAAvB,EAA2BC,SAA3B,CAAqC,CAArC,EAAwC,CAAxC,CAA2C,EAAlE;AACA;;AACA,OAAO,MAAMC,mBAAmB,GAAI,GAAEL,MAAO,GAAtC;AACP;;AACA,OAAO,MAAMM,iBAAiB,GAAI,IAAGN,MAAO,EAArC;AACP;AACA;AACA;AACA;;AACA,OAAO,MAAMO,GAAG,GAAGf,MAAM,CAACC,MAAP,CAAc;AAC7B;AACJ;AACA;AACIe,EAAAA,0BAA0B,EAAEC,KAAK,CAACC,OAAN,CAAcC,QAAQ,CAACC,kBAAvB,KACxB,aAAaC,aAAa,CAACC,SALF;;AAM7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,aAAa,CAACC,MAAD,EAAS;AAClB,QAAIjB,UAAU,KAAKL,cAAnB,EAAmC;AAC/B,YAAM,IAAIuB,KAAJ,CAAU,uCAAV,CAAN;AACH;;AACDlB,IAAAA,UAAU,GAAGiB,MAAb;AACH,GAlB4B;;AAmB7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACInB,EAAAA,UAAU,CAACC,IAAD,EAAO;AACb,WAAOC,UAAU,CAACF,UAAX,CAAsBC,IAAtB,CAAP;AACH,GA5B4B;;AA6B7B;AACJ;AACA;AACA;AACIoB,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACX,WAAOA,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,CAA1B,IAA+BD,IAAI,CAACE,IAAL,CAAUC,UAAV,CAAqBtB,MAArB,CAAtC;AACH,GAnC4B;;AAoC7B;AACJ;AACA;AACA;AACIuB,EAAAA,+BAA+B,CAACJ,IAAD,EAAO;AAClC,WAAOK,QAAQ,CAACL,IAAI,CAACE,IAAL,CAAUI,OAAV,CAAmB,GAAEzB,MAAO,GAA5B,EAAgC,EAAhC,CAAD,CAAf;AACH,GA1C4B;;AA2C7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACI0B,EAAAA,8BAA8B,CAACxC,KAAD,EAAQ;AAClC,WAAQ,GAAEmB,mBAAoB,GAAEnB,KAAM,GAAEoB,iBAAkB,EAA1D;AACH,GApD4B;;AAqD7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIqB,EAAAA,gCAAgC,CAACC,aAAD,EAAgB1C,KAAhB,EAAuB;AACnD,WAAQ,GAAE0C,aAAc,KAAI,KAAKF,8BAAL,CAAoCxC,KAApC,CAA2C,GAAvE;AACH,GA/D4B;;AAgE7B;AACJ;AACA;AACA;AACA;AACA;AACI2C,EAAAA,sBAAsB,CAAC3C,KAAD,EAAQ;AAC1B,WAAQ,OAAMc,MAAO,IAAGd,KAAM,KAA9B;AACH,GAxE4B;;AAyE7B;AACJ;AACA;AACA;AACI4C,EAAAA,WAAW,EAAE5D,WAAW,CAACmB,OA7EI;;AA8E7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACI0C,EAAAA,cAAc,EAAE7D,WAAW,CAACc,OArFC;;AAsF7B;AACJ;AACA;AACIgD,EAAAA,UAAU,GAAG;AACT,WAAO,IAAIC,OAAJ,CAAY/D,WAAW,CAACmB,OAAxB,CAAP;AACH,GA3F4B;;AA4F7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI6C,EAAAA,YAAY,CAACC,OAAD,EAAUP,aAAV,EAAyBQ,KAAzB,EAAgC;AACxC,QAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKC,SAAhC,EAA2C;AACvCF,MAAAA,OAAO,CAACG,eAAR,CAAwBV,aAAxB;AACH,KAFD,MAGK;AACDO,MAAAA,OAAO,CAACD,YAAR,CAAqBN,aAArB,EAAoCQ,KAApC;AACH;AACJ,GA5G4B;;AA6G7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIG,EAAAA,mBAAmB,CAACJ,OAAD,EAAUP,aAAV,EAAyBQ,KAAzB,EAAgC;AAC/CA,IAAAA,KAAK,GACCD,OAAO,CAACD,YAAR,CAAqBN,aAArB,EAAoC,EAApC,CADD,GAECO,OAAO,CAACG,eAAR,CAAwBV,aAAxB,CAFN;AAGH,GAzH4B;;AA0H7B;AACJ;AACA;AACA;AACIY,EAAAA,gBAAgB,CAACC,MAAD,EAAS;AACrB,SAAK,IAAIC,KAAK,GAAGD,MAAM,CAACE,UAAxB,EAAoCD,KAAK,KAAK,IAA9C,EAAoDA,KAAK,GAAGD,MAAM,CAACE,UAAnE,EAA+E;AAC3EF,MAAAA,MAAM,CAACG,WAAP,CAAmBF,KAAnB;AACH;AACJ,GAlI4B;;AAmI7B;AACJ;AACA;AACA;AACIG,EAAAA,oBAAoB,CAACC,QAAD,EAAW;AAC3B,WAAOnC,QAAQ,CAACoC,gBAAT,CAA0BD,QAA1B,EAAoC,GAApC,EAAyC;AAChD,QADO,EACD,KADC,CAAP;AAEH;;AA1I4B,CAAd,CAAZ","sourcesContent":["import { $global } from \"./platform\";\nconst updateQueue = $global.FAST.getById(1 /* updateQueue */, () => {\n    const tasks = [];\n    const pendingErrors = [];\n    function throwFirstError() {\n        if (pendingErrors.length) {\n            throw pendingErrors.shift();\n        }\n    }\n    function tryRunTask(task) {\n        try {\n            task.call();\n        }\n        catch (error) {\n            pendingErrors.push(error);\n            setTimeout(throwFirstError, 0);\n        }\n    }\n    function process() {\n        const capacity = 1024;\n        let index = 0;\n        while (index < tasks.length) {\n            tryRunTask(tasks[index]);\n            index++;\n            // Prevent leaking memory for long chains of recursive calls to `DOM.queueUpdate`.\n            // If we call `DOM.queueUpdate` within a task scheduled by `DOM.queueUpdate`, the queue will\n            // grow, but to avoid an O(n) walk for every task we execute, we don't\n            // shift tasks off the queue after they have been executed.\n            // Instead, we periodically shift 1024 tasks off the queue.\n            if (index > capacity) {\n                // Manually shift all values starting at the index back to the\n                // beginning of the queue.\n                for (let scan = 0, newLength = tasks.length - index; scan < newLength; scan++) {\n                    tasks[scan] = tasks[scan + index];\n                }\n                tasks.length -= index;\n                index = 0;\n            }\n        }\n        tasks.length = 0;\n    }\n    function enqueue(callable) {\n        if (tasks.length < 1) {\n            $global.requestAnimationFrame(process);\n        }\n        tasks.push(callable);\n    }\n    return Object.freeze({\n        enqueue,\n        process,\n    });\n});\n/* eslint-disable */\nconst fastHTMLPolicy = $global.trustedTypes.createPolicy(\"fast-html\", {\n    createHTML: html => html,\n});\n/* eslint-enable */\nlet htmlPolicy = fastHTMLPolicy;\nconst marker = `fast-${Math.random().toString(36).substring(2, 8)}`;\n/** @internal */\nexport const _interpolationStart = `${marker}{`;\n/** @internal */\nexport const _interpolationEnd = `}${marker}`;\n/**\n * Common DOM APIs.\n * @public\n */\nexport const DOM = Object.freeze({\n    /**\n     * Indicates whether the DOM supports the adoptedStyleSheets feature.\n     */\n    supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) &&\n        \"replace\" in CSSStyleSheet.prototype,\n    /**\n     * Sets the HTML trusted types policy used by the templating engine.\n     * @param policy - The policy to set for HTML.\n     * @remarks\n     * This API can only be called once, for security reasons. It should be\n     * called by the application developer at the start of their program.\n     */\n    setHTMLPolicy(policy) {\n        if (htmlPolicy !== fastHTMLPolicy) {\n            throw new Error(\"The HTML policy can only be set once.\");\n        }\n        htmlPolicy = policy;\n    },\n    /**\n     * Turns a string into trusted HTML using the configured trusted types policy.\n     * @param html - The string to turn into trusted HTML.\n     * @remarks\n     * Used internally by the template engine when creating templates\n     * and setting innerHTML.\n     */\n    createHTML(html) {\n        return htmlPolicy.createHTML(html);\n    },\n    /**\n     * Determines if the provided node is a template marker used by the runtime.\n     * @param node - The node to test.\n     */\n    isMarker(node) {\n        return node && node.nodeType === 8 && node.data.startsWith(marker);\n    },\n    /**\n     * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.\n     * @param node - The marker node to extract the index from.\n     */\n    extractDirectiveIndexFromMarker(node) {\n        return parseInt(node.data.replace(`${marker}:`, \"\"));\n    },\n    /**\n     * Creates a placeholder string suitable for marking out a location *within*\n     * an attribute value or HTML content.\n     * @param index - The directive index to create the placeholder for.\n     * @remarks\n     * Used internally by binding directives.\n     */\n    createInterpolationPlaceholder(index) {\n        return `${_interpolationStart}${index}${_interpolationEnd}`;\n    },\n    /**\n     * Creates a placeholder that manifests itself as an attribute on an\n     * element.\n     * @param attributeName - The name of the custom attribute.\n     * @param index - The directive index to create the placeholder for.\n     * @remarks\n     * Used internally by attribute directives such as `ref`, `slotted`, and `children`.\n     */\n    createCustomAttributePlaceholder(attributeName, index) {\n        return `${attributeName}=\"${this.createInterpolationPlaceholder(index)}\"`;\n    },\n    /**\n     * Creates a placeholder that manifests itself as a marker within the DOM structure.\n     * @param index - The directive index to create the placeholder for.\n     * @remarks\n     * Used internally by structural directives such as `repeat`.\n     */\n    createBlockPlaceholder(index) {\n        return `<!--${marker}:${index}-->`;\n    },\n    /**\n     * Schedules DOM update work in the next async batch.\n     * @param callable - The callable function or object to queue.\n     */\n    queueUpdate: updateQueue.enqueue,\n    /**\n     * Immediately processes all work previously scheduled\n     * through queueUpdate.\n     * @remarks\n     * This also forces nextUpdate promises\n     * to resolve.\n     */\n    processUpdates: updateQueue.process,\n    /**\n     * Resolves with the next DOM update.\n     */\n    nextUpdate() {\n        return new Promise(updateQueue.enqueue);\n    },\n    /**\n     * Sets an attribute value on an element.\n     * @param element - The element to set the attribute value on.\n     * @param attributeName - The attribute name to set.\n     * @param value - The value of the attribute to set.\n     * @remarks\n     * If the value is `null` or `undefined`, the attribute is removed, otherwise\n     * it is set to the provided value using the standard `setAttribute` API.\n     */\n    setAttribute(element, attributeName, value) {\n        if (value === null || value === undefined) {\n            element.removeAttribute(attributeName);\n        }\n        else {\n            element.setAttribute(attributeName, value);\n        }\n    },\n    /**\n     * Sets a boolean attribute value.\n     * @param element - The element to set the boolean attribute value on.\n     * @param attributeName - The attribute name to set.\n     * @param value - The value of the attribute to set.\n     * @remarks\n     * If the value is true, the attribute is added; otherwise it is removed.\n     */\n    setBooleanAttribute(element, attributeName, value) {\n        value\n            ? element.setAttribute(attributeName, \"\")\n            : element.removeAttribute(attributeName);\n    },\n    /**\n     * Removes all the child nodes of the provided parent node.\n     * @param parent - The node to remove the children from.\n     */\n    removeChildNodes(parent) {\n        for (let child = parent.firstChild; child !== null; child = parent.firstChild) {\n            parent.removeChild(child);\n        }\n    },\n    /**\n     * Creates a TreeWalker configured to walk a template fragment.\n     * @param fragment - The fragment to walk.\n     */\n    createTemplateWalker(fragment) {\n        return document.createTreeWalker(fragment, 133, // element, text, comment\n        null, false);\n    },\n});\n"]},"metadata":{},"sourceType":"module"}