{"ast":null,"code":"import { createVNode as _createVNode } from \"vue\";\nimport { ref, watch, computed, nextTick, Teleport, onMounted, defineComponent } from \"vue\";\nimport { isDef, isHidden, truthProp, numericProp, getScrollTop, preventDefault, makeNumberProp, createNamespace, getRootScrollTop, setRootScrollTop } from \"../utils\";\nimport { useRect, useChildren, useScrollParent, useEventListener } from \"@vant/use\";\nimport { useTouch } from \"../composables/use-touch\";\nimport { useExpose } from \"../composables/use-expose\";\n\nfunction genAlphabet() {\n  const charCodeOfA = \"A\".charCodeAt(0);\n  const indexList = Array(26).fill(\"\").map((_, i) => String.fromCharCode(charCodeOfA + i));\n  return indexList;\n}\n\nconst [name, bem] = createNamespace(\"index-bar\");\nconst indexBarProps = {\n  sticky: truthProp,\n  zIndex: numericProp,\n  teleport: [String, Object],\n  highlightColor: String,\n  stickyOffsetTop: makeNumberProp(0),\n  indexList: {\n    type: Array,\n    default: genAlphabet\n  }\n};\nconst INDEX_BAR_KEY = Symbol(name);\nvar stdin_default = defineComponent({\n  name,\n  props: indexBarProps,\n  emits: [\"select\", \"change\"],\n\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const root = ref();\n    const activeAnchor = ref(\"\");\n    const touch = useTouch();\n    const scrollParent = useScrollParent(root);\n    const {\n      children,\n      linkChildren\n    } = useChildren(INDEX_BAR_KEY);\n    let selectActiveIndex;\n    linkChildren({\n      props\n    });\n    const sidebarStyle = computed(() => {\n      if (isDef(props.zIndex)) {\n        return {\n          zIndex: +props.zIndex + 1\n        };\n      }\n    });\n    const highlightStyle = computed(() => {\n      if (props.highlightColor) {\n        return {\n          color: props.highlightColor\n        };\n      }\n    });\n\n    const getActiveAnchor = (scrollTop, rects) => {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const prevHeight = i > 0 ? rects[i - 1].height : 0;\n        const reachTop = props.sticky ? prevHeight + props.stickyOffsetTop : 0;\n\n        if (scrollTop + reachTop >= rects[i].top) {\n          return i;\n        }\n      }\n\n      return -1;\n    };\n\n    const getMatchAnchor = index => children.find(item => String(item.index) === index);\n\n    const onScroll = () => {\n      if (isHidden(root)) {\n        return;\n      }\n\n      const {\n        sticky,\n        indexList\n      } = props;\n      const scrollTop = getScrollTop(scrollParent.value);\n      const scrollParentRect = useRect(scrollParent);\n      const rects = children.map(item => item.getRect(scrollParent.value, scrollParentRect));\n      let active = -1;\n\n      if (selectActiveIndex) {\n        const match = getMatchAnchor(selectActiveIndex);\n\n        if (match) {\n          const rect = match.getRect(scrollParent.value, scrollParentRect);\n          active = getActiveAnchor(rect.top, rects);\n        }\n      } else {\n        active = getActiveAnchor(scrollTop, rects);\n      }\n\n      activeAnchor.value = indexList[active];\n\n      if (sticky) {\n        children.forEach((item, index) => {\n          const {\n            state,\n            $el\n          } = item;\n\n          if (index === active || index === active - 1) {\n            const rect = $el.getBoundingClientRect();\n            state.left = rect.left;\n            state.width = rect.width;\n          } else {\n            state.left = null;\n            state.width = null;\n          }\n\n          if (index === active) {\n            state.active = true;\n            state.top = Math.max(props.stickyOffsetTop, rects[index].top - scrollTop) + scrollParentRect.top;\n          } else if (index === active - 1 && selectActiveIndex === \"\") {\n            const activeItemTop = rects[active].top - scrollTop;\n            state.active = activeItemTop > 0;\n            state.top = activeItemTop + scrollParentRect.top - rects[index].height;\n          } else {\n            state.active = false;\n          }\n        });\n      }\n\n      selectActiveIndex = \"\";\n    };\n\n    const init = () => {\n      nextTick(onScroll);\n    };\n\n    useEventListener(\"scroll\", onScroll, {\n      target: scrollParent\n    });\n    onMounted(init);\n    watch(() => props.indexList, init);\n    watch(activeAnchor, value => {\n      if (value) {\n        emit(\"change\", value);\n      }\n    });\n\n    const renderIndexes = () => props.indexList.map(index => {\n      const active = index === activeAnchor.value;\n      return _createVNode(\"span\", {\n        \"class\": bem(\"index\", {\n          active\n        }),\n        \"style\": active ? highlightStyle.value : void 0,\n        \"data-index\": index\n      }, [index]);\n    });\n\n    const scrollTo = index => {\n      selectActiveIndex = String(index);\n      const match = getMatchAnchor(selectActiveIndex);\n\n      if (match) {\n        const scrollTop = getScrollTop(scrollParent.value);\n        const scrollParentRect = useRect(scrollParent);\n        const {\n          offsetHeight\n        } = document.documentElement;\n\n        if (scrollTop === offsetHeight - scrollParentRect.height) {\n          onScroll();\n          return;\n        }\n\n        match.$el.scrollIntoView();\n\n        if (props.sticky && props.stickyOffsetTop) {\n          setRootScrollTop(getRootScrollTop() - props.stickyOffsetTop);\n        }\n\n        emit(\"select\", match.index);\n      }\n    };\n\n    const scrollToElement = element => {\n      const {\n        index\n      } = element.dataset;\n\n      if (index) {\n        scrollTo(index);\n      }\n    };\n\n    const onClickSidebar = event => {\n      scrollToElement(event.target);\n    };\n\n    let touchActiveIndex;\n\n    const onTouchMove = event => {\n      touch.move(event);\n\n      if (touch.isVertical()) {\n        preventDefault(event);\n        const {\n          clientX,\n          clientY\n        } = event.touches[0];\n        const target = document.elementFromPoint(clientX, clientY);\n\n        if (target) {\n          const {\n            index\n          } = target.dataset;\n\n          if (index && touchActiveIndex !== index) {\n            touchActiveIndex = index;\n            scrollToElement(target);\n          }\n        }\n      }\n    };\n\n    const renderSidebar = () => _createVNode(\"div\", {\n      \"class\": bem(\"sidebar\"),\n      \"style\": sidebarStyle.value,\n      \"onClick\": onClickSidebar,\n      \"onTouchstart\": touch.start,\n      \"onTouchmove\": onTouchMove\n    }, [renderIndexes()]);\n\n    useExpose({\n      scrollTo\n    });\n    return () => {\n      var _a;\n\n      return _createVNode(\"div\", {\n        \"ref\": root,\n        \"class\": bem()\n      }, [props.teleport ? _createVNode(Teleport, {\n        \"to\": props.teleport\n      }, {\n        default: () => [renderSidebar()]\n      }) : renderSidebar(), (_a = slots.default) == null ? void 0 : _a.call(slots)]);\n    };\n  }\n\n});\nexport { INDEX_BAR_KEY, stdin_default as default };","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/vant/es/index-bar/IndexBar.js"],"names":["createVNode","_createVNode","ref","watch","computed","nextTick","Teleport","onMounted","defineComponent","isDef","isHidden","truthProp","numericProp","getScrollTop","preventDefault","makeNumberProp","createNamespace","getRootScrollTop","setRootScrollTop","useRect","useChildren","useScrollParent","useEventListener","useTouch","useExpose","genAlphabet","charCodeOfA","charCodeAt","indexList","Array","fill","map","_","i","String","fromCharCode","name","bem","indexBarProps","sticky","zIndex","teleport","Object","highlightColor","stickyOffsetTop","type","default","INDEX_BAR_KEY","Symbol","stdin_default","props","emits","setup","emit","slots","root","activeAnchor","touch","scrollParent","children","linkChildren","selectActiveIndex","sidebarStyle","highlightStyle","color","getActiveAnchor","scrollTop","rects","length","prevHeight","height","reachTop","top","getMatchAnchor","index","find","item","onScroll","value","scrollParentRect","getRect","active","match","rect","forEach","state","$el","getBoundingClientRect","left","width","Math","max","activeItemTop","init","target","renderIndexes","scrollTo","offsetHeight","document","documentElement","scrollIntoView","scrollToElement","element","dataset","onClickSidebar","event","touchActiveIndex","onTouchMove","move","isVertical","clientX","clientY","touches","elementFromPoint","renderSidebar","start","_a","call"],"mappings":"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","sourcesContent":["import { createVNode as _createVNode } from \"vue\";\nimport { ref, watch, computed, nextTick, Teleport, onMounted, defineComponent } from \"vue\";\nimport { isDef, isHidden, truthProp, numericProp, getScrollTop, preventDefault, makeNumberProp, createNamespace, getRootScrollTop, setRootScrollTop } from \"../utils\";\nimport { useRect, useChildren, useScrollParent, useEventListener } from \"@vant/use\";\nimport { useTouch } from \"../composables/use-touch\";\nimport { useExpose } from \"../composables/use-expose\";\nfunction genAlphabet() {\n  const charCodeOfA = \"A\".charCodeAt(0);\n  const indexList = Array(26).fill(\"\").map((_, i) => String.fromCharCode(charCodeOfA + i));\n  return indexList;\n}\nconst [name, bem] = createNamespace(\"index-bar\");\nconst indexBarProps = {\n  sticky: truthProp,\n  zIndex: numericProp,\n  teleport: [String, Object],\n  highlightColor: String,\n  stickyOffsetTop: makeNumberProp(0),\n  indexList: {\n    type: Array,\n    default: genAlphabet\n  }\n};\nconst INDEX_BAR_KEY = Symbol(name);\nvar stdin_default = defineComponent({\n  name,\n  props: indexBarProps,\n  emits: [\"select\", \"change\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const root = ref();\n    const activeAnchor = ref(\"\");\n    const touch = useTouch();\n    const scrollParent = useScrollParent(root);\n    const {\n      children,\n      linkChildren\n    } = useChildren(INDEX_BAR_KEY);\n    let selectActiveIndex;\n    linkChildren({\n      props\n    });\n    const sidebarStyle = computed(() => {\n      if (isDef(props.zIndex)) {\n        return {\n          zIndex: +props.zIndex + 1\n        };\n      }\n    });\n    const highlightStyle = computed(() => {\n      if (props.highlightColor) {\n        return {\n          color: props.highlightColor\n        };\n      }\n    });\n    const getActiveAnchor = (scrollTop, rects) => {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const prevHeight = i > 0 ? rects[i - 1].height : 0;\n        const reachTop = props.sticky ? prevHeight + props.stickyOffsetTop : 0;\n        if (scrollTop + reachTop >= rects[i].top) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const getMatchAnchor = (index) => children.find((item) => String(item.index) === index);\n    const onScroll = () => {\n      if (isHidden(root)) {\n        return;\n      }\n      const {\n        sticky,\n        indexList\n      } = props;\n      const scrollTop = getScrollTop(scrollParent.value);\n      const scrollParentRect = useRect(scrollParent);\n      const rects = children.map((item) => item.getRect(scrollParent.value, scrollParentRect));\n      let active = -1;\n      if (selectActiveIndex) {\n        const match = getMatchAnchor(selectActiveIndex);\n        if (match) {\n          const rect = match.getRect(scrollParent.value, scrollParentRect);\n          active = getActiveAnchor(rect.top, rects);\n        }\n      } else {\n        active = getActiveAnchor(scrollTop, rects);\n      }\n      activeAnchor.value = indexList[active];\n      if (sticky) {\n        children.forEach((item, index) => {\n          const {\n            state,\n            $el\n          } = item;\n          if (index === active || index === active - 1) {\n            const rect = $el.getBoundingClientRect();\n            state.left = rect.left;\n            state.width = rect.width;\n          } else {\n            state.left = null;\n            state.width = null;\n          }\n          if (index === active) {\n            state.active = true;\n            state.top = Math.max(props.stickyOffsetTop, rects[index].top - scrollTop) + scrollParentRect.top;\n          } else if (index === active - 1 && selectActiveIndex === \"\") {\n            const activeItemTop = rects[active].top - scrollTop;\n            state.active = activeItemTop > 0;\n            state.top = activeItemTop + scrollParentRect.top - rects[index].height;\n          } else {\n            state.active = false;\n          }\n        });\n      }\n      selectActiveIndex = \"\";\n    };\n    const init = () => {\n      nextTick(onScroll);\n    };\n    useEventListener(\"scroll\", onScroll, {\n      target: scrollParent\n    });\n    onMounted(init);\n    watch(() => props.indexList, init);\n    watch(activeAnchor, (value) => {\n      if (value) {\n        emit(\"change\", value);\n      }\n    });\n    const renderIndexes = () => props.indexList.map((index) => {\n      const active = index === activeAnchor.value;\n      return _createVNode(\"span\", {\n        \"class\": bem(\"index\", {\n          active\n        }),\n        \"style\": active ? highlightStyle.value : void 0,\n        \"data-index\": index\n      }, [index]);\n    });\n    const scrollTo = (index) => {\n      selectActiveIndex = String(index);\n      const match = getMatchAnchor(selectActiveIndex);\n      if (match) {\n        const scrollTop = getScrollTop(scrollParent.value);\n        const scrollParentRect = useRect(scrollParent);\n        const {\n          offsetHeight\n        } = document.documentElement;\n        if (scrollTop === offsetHeight - scrollParentRect.height) {\n          onScroll();\n          return;\n        }\n        match.$el.scrollIntoView();\n        if (props.sticky && props.stickyOffsetTop) {\n          setRootScrollTop(getRootScrollTop() - props.stickyOffsetTop);\n        }\n        emit(\"select\", match.index);\n      }\n    };\n    const scrollToElement = (element) => {\n      const {\n        index\n      } = element.dataset;\n      if (index) {\n        scrollTo(index);\n      }\n    };\n    const onClickSidebar = (event) => {\n      scrollToElement(event.target);\n    };\n    let touchActiveIndex;\n    const onTouchMove = (event) => {\n      touch.move(event);\n      if (touch.isVertical()) {\n        preventDefault(event);\n        const {\n          clientX,\n          clientY\n        } = event.touches[0];\n        const target = document.elementFromPoint(clientX, clientY);\n        if (target) {\n          const {\n            index\n          } = target.dataset;\n          if (index && touchActiveIndex !== index) {\n            touchActiveIndex = index;\n            scrollToElement(target);\n          }\n        }\n      }\n    };\n    const renderSidebar = () => _createVNode(\"div\", {\n      \"class\": bem(\"sidebar\"),\n      \"style\": sidebarStyle.value,\n      \"onClick\": onClickSidebar,\n      \"onTouchstart\": touch.start,\n      \"onTouchmove\": onTouchMove\n    }, [renderIndexes()]);\n    useExpose({\n      scrollTo\n    });\n    return () => {\n      var _a;\n      return _createVNode(\"div\", {\n        \"ref\": root,\n        \"class\": bem()\n      }, [props.teleport ? _createVNode(Teleport, {\n        \"to\": props.teleport\n      }, {\n        default: () => [renderSidebar()]\n      }) : renderSidebar(), (_a = slots.default) == null ? void 0 : _a.call(slots)]);\n    };\n  }\n});\nexport {\n  INDEX_BAR_KEY,\n  stdin_default as default\n};\n"]},"metadata":{},"sourceType":"module"}