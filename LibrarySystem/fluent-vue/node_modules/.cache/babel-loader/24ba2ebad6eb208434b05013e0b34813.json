{"ast":null,"code":"import { h, defineComponent, ref, provide, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { on, off } from 'evtd';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { flatten, keep, resolveSlotWithProps } from '../../_utils';\nimport { carouselLight } from '../styles';\nimport { calculateSize, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, isTouchEvent, clampValue, resolveSpeed } from './utils';\nimport NCarouselDots from './CarouselDots';\nimport NCarouselArrow from './CarouselArrow';\nimport NCarouselItem from './CarouselItem';\nimport { carouselMethodsInjectionKey, tuple } from './interface';\nimport style from './styles/index.cssr';\nconst transitionProperties = tuple('transitionDuration', 'transitionTimingFunction');\nconst carouselProps = Object.assign(Object.assign({}, useTheme.props), {\n  defaultIndex: {\n    type: Number,\n    default: 0\n  },\n  currentIndex: Number,\n  showArrow: Boolean,\n  dotType: {\n    type: String,\n    default: 'dot'\n  },\n  dotPlacement: {\n    type: String,\n    default: 'bottom'\n  },\n  slidesPerView: {\n    type: [Number, String],\n    default: 1\n  },\n  spaceBetween: {\n    type: Number,\n    default: 0\n  },\n  centeredSlides: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  autoplay: Boolean,\n  interval: {\n    type: Number,\n    default: 5000\n  },\n  loop: {\n    type: Boolean,\n    default: true\n  },\n  effect: {\n    type: String,\n    default: 'slide'\n  },\n  showDots: {\n    type: Boolean,\n    default: true\n  },\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  transitionStyle: {\n    type: Object,\n    default: () => ({\n      transitionDuration: '300ms'\n    })\n  },\n  transitionProps: Object,\n  draggable: Boolean,\n  prevSlideStyle: [Object, String],\n  nextSlideStyle: [Object, String],\n  touchable: {\n    type: Boolean,\n    default: true\n  },\n  mousewheel: Boolean,\n  keyboard: Boolean,\n  'onUpdate:currentIndex': Function,\n  onUpdateCurrentIndex: Function\n}); // only one carousel is allowed to trigger touch globally\n\nlet globalDragging = false;\nexport default defineComponent({\n  name: 'Carousel',\n  props: carouselProps,\n\n  setup(props) {\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props); // Dom\n\n    const selfElRef = ref(null);\n    const slidesElsRef = ref([]);\n    const slideVNodesRef = {\n      value: []\n    }; // user wants to control the transition animation\n\n    const userWantsControlRef = computed(() => props.effect === 'custom');\n    const translateableRef = computed(() => !userWantsControlRef.value && props.effect === 'slide'); // TODO\n\n    const allowLoopRef = computed(() => props.loop && props.slidesPerView === 1); // Because of the nature of the loop slide work,\n    // we need to add duplicates to the left and right of the carousel\n    // slot    [ 0 1 2 ]\n    // display 2 0 1 2 0\n    // index   0 1 2 3 4\n\n    const duplicatedableRef = computed( // only duplicate the copy operation in `slide` mode,\n    // because other effects have special process\n    () => translateableRef.value && allowLoopRef.value); // used to calculate total views\n\n    const displaySlidesPerViewRef = computed(() => userWantsControlRef.value || props.centeredSlides || props.effect !== 'slide' ? 1 : props.slidesPerView); // used to calculate the size of each slide\n\n    const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView); // we automatically calculate total view for special slides per view\n\n    const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' || props.slidesPerView === 'auto' && props.centeredSlides);\n    const transitionStyleRef = computed(() => props.transitionStyle ? keep(props.transitionStyle, transitionProperties) : {});\n    const speedRef = computed(() => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration));\n    const verticalRef = computed(() => props.direction === 'vertical');\n    const sizeAxisRef = computed(() => verticalRef.value ? 'height' : 'width');\n    const perViewSizeRef = ref({\n      width: 0,\n      height: 0\n    });\n    const slideSizesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slidesElsRef;\n      const {\n        length\n      } = slidesEls;\n      if (!length) return [];\n\n      if (autoSlideSizeRef.value) {\n        return slidesEls.map(slide => calculateSize(slide));\n      }\n\n      const {\n        value: slidesPerView\n      } = realSlidesPerViewRef;\n      const {\n        value: perViewSize\n      } = perViewSizeRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      let slideSize = perViewSize[axis];\n\n      if (slidesPerView !== 'auto') {\n        const {\n          spaceBetween\n        } = props;\n        const remaining = slideSize - (slidesPerView - 1) * spaceBetween;\n        const percentage = 1 / Math.max(1, slidesPerView);\n        slideSize = remaining * percentage;\n      }\n\n      return slidesEls.map(() => Object.assign(Object.assign({}, perViewSize), {\n        [axis]: slideSize\n      }));\n    }); // The translate required to reach each slide\n\n    const slideTranlatesRef = computed(() => {\n      const {\n        value: slideSizes\n      } = slideSizesRef;\n      const {\n        length\n      } = slideSizes;\n      if (!length) return [];\n      const {\n        centeredSlides,\n        spaceBetween\n      } = props;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const {\n        [axis]: perViewSize\n      } = perViewSizeRef.value;\n      let previousTranslate = 0;\n      return slideSizes.map(({\n        [axis]: slideSize\n      }) => {\n        let translate = previousTranslate;\n\n        if (centeredSlides) {\n          translate += (slideSize - perViewSize) / 2;\n        }\n\n        previousTranslate += slideSize + spaceBetween;\n        return translate;\n      });\n    });\n    let isMounted = false;\n    const slideStylesRef = computed(() => {\n      const {\n        value: slideSizes\n      } = slideSizesRef;\n      const {\n        length\n      } = slideSizes;\n      if (!length) return [];\n      const {\n        value: axis\n      } = sizeAxisRef; // when user wants to control the transition animation, we center each slide\n\n      if (userWantsControlRef.value) {\n        return slideSizes.map(size => ({\n          [axis]: `${size[axis]}px`\n        }));\n      }\n\n      const {\n        effect,\n        spaceBetween\n      } = props;\n      const {\n        value: vertical\n      } = verticalRef;\n      const spaceAxis = vertical ? 'bottom' : 'right';\n      const slideStyles = [];\n\n      for (let i = 0; i < length; i++) {\n        const size = slideSizes[i][axis];\n        const style = {\n          [axis]: `${size}px`,\n          [`margin-${spaceAxis}`]: `${spaceBetween}px`\n        };\n\n        if (isMounted && (effect === 'fade' || effect === 'card')) {\n          Object.assign(style, transitionStyleRef.value);\n        }\n\n        slideStyles.push(style);\n      }\n\n      return slideStyles;\n    }); // Total\n\n    const totalViewRef = computed(() => {\n      const {\n        value: slidesPerView\n      } = displaySlidesPerViewRef;\n      const {\n        length: originLength\n      } = slidesElsRef.value;\n\n      if (slidesPerView !== 'auto') {\n        return originLength - slidesPerView + 1;\n      } else {\n        const {\n          value: slideSizes\n        } = slideSizesRef;\n        const {\n          length\n        } = slideSizes;\n        if (!length) return originLength;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n        let i = length;\n\n        while (i > 1 && lastViewSize < perViewSize) {\n          i--;\n          lastViewSize += translates[i] - translates[i - 1];\n        }\n\n        if (i !== length) i++;\n        if (i < 1) i = 1;\n        return i;\n      }\n    });\n    const displayTotalViewRef = computed(() => {\n      const {\n        value: totalView\n      } = totalViewRef;\n      return duplicatedableRef.value && totalView > 3 ? totalView - 2 : totalView;\n    }); // Index\n\n    const initializeIndex = props.defaultIndex + (duplicatedableRef.value ? 1 : 0);\n    const displayIndexRef = ref(getDisplayIndex(initializeIndex, totalViewRef.value, duplicatedableRef.value));\n    const virtualIndexRef = ref(initializeIndex);\n    const realIndexRef = ref(initializeIndex); // record the translate of each slide, so that it can be restored at touch\n\n    let previousTranslate = 0; // Reality methods\n\n    function toRealIndex(index, speed = speedRef.value) {\n      var _a, _b;\n\n      const {\n        value: length\n      } = totalViewRef;\n\n      if ((index = clampValue(index, 0, length - 1)) !== realIndexRef.value) {\n        const {\n          value: lastDisplayIndex\n        } = displayIndexRef; // When it is loop from the first silde to the last one,\n        // we control its animation effect\n\n        if (duplicatedableRef.value && displayTotalViewRef.value > 2) {\n          if (lastDisplayIndex === 0 && index === displayTotalViewRef.value) {\n            index = 0;\n          } else if (lastDisplayIndex === displayTotalViewRef.value - 1 && index === 1) {\n            index = length - 1;\n          }\n        }\n\n        const displayIndex = displayIndexRef.value = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);\n        virtualIndexRef.value = index;\n        realIndexRef.value = getRealIndex(displayIndex, duplicatedableRef.value);\n\n        if (translateableRef.value) {\n          translateTo(index, speed);\n        } else {\n          if (!userWantsControlRef.value && speed > 0) {\n            inTransition = true;\n          }\n\n          fixTranslate();\n        }\n\n        if (displayIndex !== lastDisplayIndex) {\n          (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n          (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n        }\n      }\n    }\n\n    function getRealPrevIndex(index = realIndexRef.value) {\n      return getPrevIndex(index, totalViewRef.value, props.loop);\n    }\n\n    function getRealNextIndex(index = realIndexRef.value) {\n      return getNextIndex(index, totalViewRef.value, props.loop);\n    }\n\n    function isRealPrev(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealPrevIndex() === index;\n    }\n\n    function isRealNext(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealNextIndex() === index;\n    }\n\n    function isRealActive(slideOrIndex) {\n      return realIndexRef.value === getSlideIndex(slideOrIndex);\n    } // Display methods\n    // They are used to deal with the actual values displayed on the UI\n\n\n    function isDisplayActive(index) {\n      return displayIndexRef.value === index;\n    }\n\n    function isPrevDisabled() {\n      return getRealPrevIndex() === null;\n    }\n\n    function isNextDisabled() {\n      return getRealNextIndex() === null;\n    } // Slide to\n\n\n    function to(index) {\n      const realIndex = getRealIndex(index, duplicatedableRef.value);\n\n      if (index !== displayIndexRef.value || realIndex !== realIndexRef.value) {\n        toRealIndex(realIndex);\n      }\n    }\n\n    function prev() {\n      const prevIndex = getRealPrevIndex();\n\n      if (prevIndex !== null) {\n        toRealIndex(prevIndex);\n      }\n    }\n\n    function next() {\n      const nextIndex = getRealNextIndex();\n\n      if (nextIndex !== null) {\n        toRealIndex(nextIndex);\n      }\n    } // Translate to\n\n\n    const translateStyleRef = ref({});\n    let inTransition = false;\n\n    function updateTranslate(translate, speed = 0) {\n      const isVersical = props.direction === 'vertical';\n      translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n        transform: isVersical ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,\n        transitionDuration: `${speed}ms`\n      });\n    }\n\n    function fixTranslate(speed = 0) {\n      if (translateableRef.value) {\n        translateTo(realIndexRef.value, speed);\n      } else if (previousTranslate !== 0) {\n        updateTranslate(previousTranslate = 0, speed);\n      }\n    }\n\n    function translateTo(index, speed = speedRef.value) {\n      const translate = getTranslate(index);\n\n      if (translate !== previousTranslate && speed > 0) {\n        inTransition = true;\n      }\n\n      updateTranslate(translate, speed);\n      previousTranslate = getTranslate(realIndexRef.value);\n    }\n\n    function getTranslate(index) {\n      let translate; // Deal with auto slides pre view\n\n      if (index >= totalViewRef.value - 1) {\n        translate = getLastViewTranslate();\n      } else {\n        translate = slideTranlatesRef.value[index] || 0;\n      }\n\n      return translate;\n    }\n\n    function getLastViewTranslate() {\n      if (displaySlidesPerViewRef.value === 'auto') {\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const {\n          [axis]: perViewSize\n        } = perViewSizeRef.value;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const lastTranslate = translates[translates.length - 1];\n        let overallSize;\n\n        if (lastTranslate === undefined) {\n          overallSize = perViewSize;\n        } else {\n          const {\n            value: slideSizes\n          } = slideSizesRef;\n          overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n        } // Bring the last slide to the edge\n\n\n        return overallSize - perViewSize;\n      } else {\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        return translates[totalViewRef.value - 1] || 0;\n      }\n    } // Provide\n\n\n    function addSlide(slide) {\n      if (!slide) return;\n      slidesElsRef.value.push(slide);\n    }\n\n    function removeSlide(slide) {\n      if (!slide) return;\n      const index = getSlideIndex(slide);\n\n      if (index !== -1) {\n        slidesElsRef.value.splice(index, 1);\n      }\n    }\n\n    function getSlideIndex(slideOrIndex) {\n      return typeof slideOrIndex === 'number' ? slideOrIndex : slidesElsRef.value.indexOf(slideOrIndex);\n    }\n\n    function getSlideStyle(slide) {\n      const index = getSlideIndex(slide);\n\n      if (index !== -1) {\n        return slideStylesRef.value[index];\n      }\n    }\n\n    function onCarouselItemClick(index, event) {\n      const isTryDrag = 4\n      /* PROGRESS */\n      | 8\n      /* SUCCESS */\n      | 16\n      /* FAIL */\n      ;\n      let allowClick = !inTransition && !(dragStatus & isTryDrag);\n\n      if (props.effect === 'card' && !userWantsControlRef.value && !(dragStatus & 8\n      /* SUCCESS */\n      ) && !isRealActive(index)) {\n        to(index);\n        allowClick = false;\n      }\n\n      if (!allowClick) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    const carouselMethods = {\n      to,\n      prev: () => {\n        // wait transition end\n        if (!inTransition || !duplicatedableRef.value) prev();\n      },\n      next: () => {\n        // wait transition end\n        if (!inTransition || !duplicatedableRef.value) next();\n      },\n      isVertical: () => verticalRef.value,\n      isHorizontal: () => !verticalRef.value,\n      isPrev: isRealPrev,\n      isNext: isRealNext,\n      isActive: isRealActive,\n      isPrevDisabled,\n      isNextDisabled,\n      getCurrentIndex: () => displayIndexRef.value,\n      getSlideIndex,\n      getSlideStyle,\n      addSlide,\n      removeSlide,\n      onCarouselItemClick,\n      prevSlideStyleRef: toRef(props, 'prevSlideStyle'),\n      nextSlideStyleRef: toRef(props, 'nextSlideStyle')\n    };\n    provide(carouselMethodsInjectionKey, carouselMethods); // Autoplay\n\n    let autoplayTimer = null;\n\n    function resetAutoplay(cleanOnly) {\n      if (autoplayTimer) {\n        clearInterval(autoplayTimer);\n        autoplayTimer = null;\n      }\n\n      const {\n        autoplay,\n        interval\n      } = props;\n\n      if (autoplay && interval && !cleanOnly) {\n        autoplayTimer = setInterval(next, interval);\n      }\n    }\n\n    function mesureAutoplay() {\n      const {\n        autoplay\n      } = props;\n\n      if (autoplay) {\n        resetAutoplay();\n      } else if (displayTotalViewRef.value < 2) {\n        resetAutoplay(true);\n      }\n    } // Drag\n\n\n    let dragStartX = 0;\n    let dragStartY = 0;\n    let dragOffset = 0;\n    let dragStartTime = 0;\n    let dragStatus = 1\n    /* NORMAL */\n    ;\n\n    function handleTouchstart(event) {\n      if (globalDragging) return;\n      dragStartTime = Date.now();\n      dragStatus = 2\n      /* START */\n      ;\n      globalDragging = true;\n      resetAutoplay(true\n      /** cleanOnly */\n      );\n\n      if (event.type !== 'touchstart' && !event.target.isContentEditable) {\n        event.preventDefault();\n      }\n\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n\n      if (verticalRef.value) {\n        dragStartY = touchEvent.clientY;\n      } else {\n        dragStartX = touchEvent.clientX;\n      }\n\n      if (props.touchable) {\n        on('touchmove', document, handleTouchmove);\n        on('touchend', document, handleTouchend);\n        on('touchcancel', document, handleTouchend);\n      }\n\n      if (props.draggable) {\n        on('mousemove', document, handleTouchmove);\n        on('mouseup', document, handleTouchend);\n      }\n    }\n\n    function handleTouchmove(event) {\n      const {\n        value: vertical\n      } = verticalRef;\n      const axis = vertical ? 'height' : 'width';\n      const perViewSize = perViewSizeRef.value[axis];\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;\n      dragOffset = clampValue(offset, -perViewSize, perViewSize);\n      dragStatus = 4\n      /* PROGRESS */\n      ;\n\n      if (translateableRef.value) {\n        updateTranslate(previousTranslate - dragOffset, 0);\n      }\n    }\n\n    function handleTouchend() {\n      const duration = Date.now() - dragStartTime;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const {\n        value: realIndex\n      } = realIndexRef;\n      const {\n        value: translateable\n      } = translateableRef;\n      let currentIndex = realIndex;\n\n      if (!inTransition && translateable && dragOffset !== 0) {\n        const currentTranslate = previousTranslate - dragOffset;\n        const translates = [...slideTranlatesRef.value.slice(0, totalViewRef.value - 1), getLastViewTranslate()];\n        let prevOffset = null;\n\n        for (let i = 0; i < translates.length; i++) {\n          const offset = Math.abs(translates[i] - currentTranslate);\n\n          if (prevOffset !== null && prevOffset < offset) {\n            break;\n          }\n\n          prevOffset = offset;\n          currentIndex = i;\n        }\n      }\n\n      if (currentIndex === realIndex) {\n        const perViewSize = perViewSizeRef.value[axis]; // more than 50% width or faster than 0.4px per ms\n\n        if (dragOffset > perViewSize / 2 || dragOffset / duration > 0.4) {\n          currentIndex = getRealPrevIndex(realIndex);\n        } else if (dragOffset < -perViewSize / 2 || dragOffset / duration < -0.4) {\n          currentIndex = getRealNextIndex(realIndex);\n        }\n      }\n\n      if (currentIndex !== null && currentIndex !== realIndex) {\n        dragStatus = 8\n        /* SUCCESS */\n        ;\n        toRealIndex(currentIndex);\n      } else {\n        if (dragStatus & 4\n        /* PROGRESS */\n        ) {\n          dragStatus = 16\n          /* FAIL */\n          ;\n        } else {\n          dragStatus = 32\n          /* END */\n          ;\n        }\n\n        fixTranslate(speedRef.value);\n      }\n\n      mesureAutoplay();\n      resetDragStatus();\n    }\n\n    function resetDragStatus() {\n      if (!(dragStatus & 1\n      /* NORMAL */\n      )) {\n        globalDragging = false;\n\n        if (dragStatus & (2\n        /* START */\n        | 4\n        /* PROGRESS */\n        )) {\n          dragStatus = 1\n          /* NORMAL */\n          ;\n        }\n      }\n\n      dragStartX = 0;\n      dragStartY = 0;\n      dragOffset = 0;\n      dragStartTime = 0;\n      off('touchmove', document, handleTouchmove);\n      off('touchend', document, handleTouchend);\n      off('touchcancel', document, handleTouchend);\n      off('mousemove', document, handleTouchmove);\n      off('mouseup', document, handleTouchend);\n    }\n\n    function handleTransitionEnd() {\n      const {\n        value: virtualIndex\n      } = virtualIndexRef;\n      const {\n        value: realIndex\n      } = realIndexRef;\n\n      if (inTransition && virtualIndex !== realIndex) {\n        translateTo(realIndex, 0);\n      } else {\n        resetAutoplay();\n      }\n\n      if (translateableRef.value) {\n        translateStyleRef.value.transitionDuration = '0ms';\n      }\n\n      inTransition = false;\n    }\n\n    function handleMousewheel(event) {\n      event.preventDefault();\n      if (inTransition) return;\n      const {\n        value: vertical\n      } = verticalRef;\n      let {\n        deltaX,\n        deltaY\n      } = event;\n\n      if (event.shiftKey && !deltaX) {\n        deltaX = deltaY;\n      }\n\n      const P_MULTIPLIER = -1;\n      const N_MULTIPLIER = 1;\n      const MULTIPLIER = (deltaX || deltaY) > 0 ? N_MULTIPLIER : P_MULTIPLIER;\n      let rx = 0;\n      let ry = 0;\n\n      if (vertical) {\n        ry = MULTIPLIER;\n      } else {\n        rx = MULTIPLIER;\n      }\n\n      const RESPONSE_STEP = 10;\n\n      if (ry * deltaY >= RESPONSE_STEP || rx * deltaX >= RESPONSE_STEP) {\n        if (MULTIPLIER === N_MULTIPLIER && !isNextDisabled()) {\n          next();\n        } else if (MULTIPLIER === P_MULTIPLIER && !isPrevDisabled()) {\n          prev();\n        }\n      }\n    }\n\n    function handleResize() {\n      perViewSizeRef.value = calculateSize(selfElRef.value, true);\n      resetAutoplay();\n    }\n\n    function handleSlideResize() {\n      var _a, _b;\n\n      if (autoSlideSizeRef.value) {\n        (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n        slideSizesRef.effect.run();\n      }\n    }\n\n    onMounted(() => {\n      watchEffect(mesureAutoplay);\n      void nextTick(() => isMounted = true);\n    });\n    onBeforeUnmount(() => {\n      resetDragStatus();\n      resetAutoplay(true);\n    }); // Fix index when remounting\n\n    onUpdated(() => {\n      const {\n        value: slidesEls\n      } = slidesElsRef;\n      const {\n        value: slideVNodes\n      } = slideVNodesRef;\n      const indexMap = new Map();\n\n      const getDisplayIndex = el => // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      indexMap.has(el) ? indexMap.get(el) : -1;\n\n      let isChanged = false;\n\n      for (let i = 0; i < slidesEls.length; i++) {\n        const index = slideVNodes.findIndex(v => v.el === slidesEls[i]);\n\n        if (index !== i) {\n          isChanged = true;\n        }\n\n        indexMap.set(slidesEls[i], index);\n      }\n\n      if (isChanged) {\n        slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n      }\n    });\n    watch(toRef(props, 'currentIndex'), index => index !== undefined && to(index));\n    watch(duplicatedableRef, () => void nextTick(() => to(displayIndexRef.value)));\n    watch(slideTranlatesRef, () => translateableRef.value && fixTranslate(), {\n      deep: true\n    });\n    watch(translateableRef, value => {\n      if (!value) {\n        inTransition = false; // if the current mode does not support translate, reset the position of the wrapper\n\n        updateTranslate(previousTranslate = 0);\n      } else {\n        fixTranslate();\n      }\n    });\n    const caroulseSlotProps = {\n      arrowSlotProps: computed(() => Object.assign({\n        total: displayTotalViewRef.value,\n        currentIndex: displayIndexRef.value\n      }, keep(carouselMethods, ['to', 'prev', 'next', 'isPrevDisabled', 'isNextDisabled']))),\n      dotSlotProps: computed(() => ({\n        total: displayTotalViewRef.value,\n        currentIndex: displayIndexRef.value,\n        to\n      }))\n    };\n    const caroulseExposedMethod = {\n      getCurrentIndex: () => displayIndexRef.value,\n      to: to,\n      prev: prev,\n      next: next\n    };\n    const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          dotSize,\n          dotColor,\n          dotColorActive,\n          dotColorFocus,\n          dotLineWidth,\n          dotLineWidthActive,\n          arrowColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-dot-color': dotColor,\n        '--n-dot-color-focus': dotColorFocus,\n        '--n-dot-color-active': dotColorActive,\n        '--n-dot-size': dotSize,\n        '--n-dot-line-width': dotLineWidth,\n        '--n-dot-line-width-active': dotLineWidthActive,\n        '--n-arrow-color': arrowColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('carousel', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign(Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      selfElRef,\n      slideVNodes: slideVNodesRef,\n      duplicatedable: duplicatedableRef,\n      userWantsControl: userWantsControlRef,\n      autoSlideSize: autoSlideSizeRef,\n      displayIndex: displayIndexRef,\n      realIndex: realIndexRef,\n      slideStyles: slideStylesRef,\n      translateStyle: translateStyleRef,\n      handleTouchstart,\n      handleTransitionEnd,\n      handleMousewheel,\n      handleResize,\n      handleSlideResize,\n      isActive: isDisplayActive\n    }, caroulseSlotProps), caroulseExposedMethod), {\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n\n  render() {\n    var _a;\n\n    const {\n      mergedClsPrefix,\n      showArrow,\n      userWantsControl,\n      draggable,\n      touchable,\n      slideStyles,\n      dotType,\n      dotPlacement,\n      transitionProps = {},\n      arrowSlotProps,\n      dotSlotProps,\n      $slots: {\n        default: defaultSlot,\n        dots: dotsSlot,\n        arrow: arrowSlot\n      }\n    } = this;\n    const children = defaultSlot && flatten(defaultSlot()) || [];\n    let slides = filterCarouselItem(children);\n\n    if (!slides.length) {\n      slides = children.map(ch => h(NCarouselItem, null, {\n        default: () => cloneVNode(ch)\n      }));\n    }\n\n    const {\n      length: realLength\n    } = slides;\n\n    if (realLength > 1 && this.duplicatedable) {\n      slides.push(duplicateSlide(slides[0], 0, 'append'));\n      slides.unshift(duplicateSlide(slides[realLength - 1], realLength - 1, 'prepend'));\n    }\n\n    this.slideVNodes.value = slides; // When users need to customize the size of the slide,\n    // we listen to them to fix the current translate\n\n    if (this.autoSlideSize) {\n      slides = slides.map(slide => h(VResizeObserver, {\n        onResize: this.handleSlideResize\n      }, {\n        default: () => slide\n      }));\n    }\n\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    return h(\"div\", {\n      ref: \"selfElRef\",\n      class: [this.themeClass, `${mergedClsPrefix}-carousel`, this.direction === 'vertical' && `${mergedClsPrefix}-carousel--vertical`, this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`, `${mergedClsPrefix}-carousel--${dotPlacement}`, `${mergedClsPrefix}-carousel--${this.direction}`, `${mergedClsPrefix}-carousel--${this.effect}`, userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`],\n      style: this.cssVars\n    }, h(VResizeObserver, {\n      onResize: this.handleResize\n    }, {\n      default: () => h(\"div\", {\n        class: `${mergedClsPrefix}-carousel__slides`,\n        role: \"listbox\",\n        style: this.translateStyle,\n        onMousedown: draggable ? this.handleTouchstart : undefined,\n        onTouchstart: touchable ? this.handleTouchstart : undefined,\n        onWheel: this.mousewheel ? this.handleMousewheel : undefined,\n        onTransitionend: this.handleTransitionEnd\n      }, userWantsControl ? slides.map((slide, i) => h(\"div\", {\n        style: slideStyles[i],\n        key: i\n      }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n        default: () => slide\n      }), [[vShow, this.isActive(i)]]))) : slides)\n    }), this.showDots && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [dotSlotProps.total > 1 && h(NCarouselDots, {\n      key: dotType + dotPlacement,\n      total: dotSlotProps.total,\n      currentIndex: dotSlotProps.currentIndex,\n      dotType: dotType,\n      trigger: this.trigger,\n      keyboard: this.keyboard\n    })]), showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [h(NCarouselArrow, null)]));\n  }\n\n});\n\nfunction filterCarouselItem(vnodes, carouselItems = []) {\n  if (Array.isArray(vnodes)) {\n    vnodes.forEach(vnode => {\n      if (vnode.type && vnode.type.name === 'CarouselItem') {\n        carouselItems.push(vnode);\n      }\n    });\n  }\n\n  return carouselItems;\n}\n\nfunction duplicateSlide(child, index, position) {\n  return cloneVNode(child, {\n    // for patch\n    key: `carousel-item-duplicate-${index}-${position}`\n  });\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/carousel/src/Carousel.js"],"names":["h","defineComponent","ref","provide","cloneVNode","computed","onBeforeUnmount","watch","withDirectives","vShow","Transition","toRef","nextTick","onMounted","watchEffect","onUpdated","VResizeObserver","on","off","useConfig","useTheme","useThemeClass","flatten","keep","resolveSlotWithProps","carouselLight","calculateSize","getNextIndex","getPrevIndex","getDisplayIndex","getRealIndex","isTouchEvent","clampValue","resolveSpeed","NCarouselDots","NCarouselArrow","NCarouselItem","carouselMethodsInjectionKey","tuple","style","transitionProperties","carouselProps","Object","assign","props","defaultIndex","type","Number","default","currentIndex","showArrow","Boolean","dotType","String","dotPlacement","slidesPerView","spaceBetween","centeredSlides","direction","autoplay","interval","loop","effect","showDots","trigger","transitionStyle","transitionDuration","transitionProps","draggable","prevSlideStyle","nextSlideStyle","touchable","mousewheel","keyboard","Function","onUpdateCurrentIndex","globalDragging","name","setup","mergedClsPrefixRef","inlineThemeDisabled","selfElRef","slidesElsRef","slideVNodesRef","value","userWantsControlRef","translateableRef","allowLoopRef","duplicatedableRef","displaySlidesPerViewRef","realSlidesPerViewRef","autoSlideSizeRef","transitionStyleRef","speedRef","verticalRef","sizeAxisRef","perViewSizeRef","width","height","slideSizesRef","slidesEls","length","map","slide","perViewSize","axis","slideSize","remaining","percentage","Math","max","slideTranlatesRef","slideSizes","previousTranslate","translate","isMounted","slideStylesRef","size","vertical","spaceAxis","slideStyles","i","push","totalViewRef","originLength","translates","lastViewSize","displayTotalViewRef","totalView","initializeIndex","displayIndexRef","virtualIndexRef","realIndexRef","toRealIndex","index","speed","_a","_b","lastDisplayIndex","displayIndex","translateTo","inTransition","fixTranslate","call","getRealPrevIndex","getRealNextIndex","isRealPrev","slideOrIndex","getSlideIndex","isRealNext","isRealActive","isDisplayActive","isPrevDisabled","isNextDisabled","to","realIndex","prev","prevIndex","next","nextIndex","translateStyleRef","updateTranslate","isVersical","transform","getTranslate","getLastViewTranslate","lastTranslate","overallSize","undefined","addSlide","removeSlide","splice","indexOf","getSlideStyle","onCarouselItemClick","event","isTryDrag","allowClick","dragStatus","preventDefault","stopPropagation","carouselMethods","isVertical","isHorizontal","isPrev","isNext","isActive","getCurrentIndex","prevSlideStyleRef","nextSlideStyleRef","autoplayTimer","resetAutoplay","cleanOnly","clearInterval","setInterval","mesureAutoplay","dragStartX","dragStartY","dragOffset","dragStartTime","handleTouchstart","Date","now","target","isContentEditable","touchEvent","touches","clientY","clientX","document","handleTouchmove","handleTouchend","offset","duration","translateable","currentTranslate","slice","prevOffset","abs","resetDragStatus","handleTransitionEnd","virtualIndex","handleMousewheel","deltaX","deltaY","shiftKey","P_MULTIPLIER","N_MULTIPLIER","MULTIPLIER","rx","ry","RESPONSE_STEP","handleResize","handleSlideResize","scheduler","run","slideVNodes","indexMap","Map","el","has","get","isChanged","findIndex","v","set","sort","a","b","deep","caroulseSlotProps","arrowSlotProps","total","dotSlotProps","caroulseExposedMethod","themeRef","cssVarsRef","common","cubicBezierEaseInOut","self","dotSize","dotColor","dotColorActive","dotColorFocus","dotLineWidth","dotLineWidthActive","arrowColor","themeClassHandle","mergedClsPrefix","duplicatedable","userWantsControl","autoSlideSize","translateStyle","cssVars","themeClass","onRender","render","$slots","defaultSlot","dots","dotsSlot","arrow","arrowSlot","children","slides","filterCarouselItem","ch","realLength","duplicateSlide","unshift","onResize","class","role","onMousedown","onTouchstart","onWheel","onTransitionend","key","vnodes","carouselItems","Array","isArray","forEach","vnode","child","position"],"mappings":"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","sourcesContent":["import { h, defineComponent, ref, provide, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { on, off } from 'evtd';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { flatten, keep, resolveSlotWithProps } from '../../_utils';\nimport { carouselLight } from '../styles';\nimport { calculateSize, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, isTouchEvent, clampValue, resolveSpeed } from './utils';\nimport NCarouselDots from './CarouselDots';\nimport NCarouselArrow from './CarouselArrow';\nimport NCarouselItem from './CarouselItem';\nimport { carouselMethodsInjectionKey, tuple } from './interface';\nimport style from './styles/index.cssr';\nconst transitionProperties = tuple('transitionDuration', 'transitionTimingFunction');\nconst carouselProps = Object.assign(Object.assign({}, useTheme.props), { defaultIndex: {\n        type: Number,\n        default: 0\n    }, currentIndex: Number, showArrow: Boolean, dotType: {\n        type: String,\n        default: 'dot'\n    }, dotPlacement: {\n        type: String,\n        default: 'bottom'\n    }, slidesPerView: {\n        type: [Number, String],\n        default: 1\n    }, spaceBetween: {\n        type: Number,\n        default: 0\n    }, centeredSlides: Boolean, direction: {\n        type: String,\n        default: 'horizontal'\n    }, autoplay: Boolean, interval: {\n        type: Number,\n        default: 5000\n    }, loop: {\n        type: Boolean,\n        default: true\n    }, effect: {\n        type: String,\n        default: 'slide'\n    }, showDots: {\n        type: Boolean,\n        default: true\n    }, trigger: {\n        type: String,\n        default: 'click'\n    }, transitionStyle: {\n        type: Object,\n        default: () => ({\n            transitionDuration: '300ms'\n        })\n    }, transitionProps: Object, draggable: Boolean, prevSlideStyle: [Object, String], nextSlideStyle: [Object, String], touchable: {\n        type: Boolean,\n        default: true\n    }, mousewheel: Boolean, keyboard: Boolean, 'onUpdate:currentIndex': Function, onUpdateCurrentIndex: Function });\n// only one carousel is allowed to trigger touch globally\nlet globalDragging = false;\nexport default defineComponent({\n    name: 'Carousel',\n    props: carouselProps,\n    setup(props) {\n        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);\n        // Dom\n        const selfElRef = ref(null);\n        const slidesElsRef = ref([]);\n        const slideVNodesRef = { value: [] };\n        // user wants to control the transition animation\n        const userWantsControlRef = computed(() => props.effect === 'custom');\n        const translateableRef = computed(() => !userWantsControlRef.value && props.effect === 'slide');\n        // TODO\n        const allowLoopRef = computed(() => props.loop && props.slidesPerView === 1);\n        // Because of the nature of the loop slide work,\n        // we need to add duplicates to the left and right of the carousel\n        // slot    [ 0 1 2 ]\n        // display 2 0 1 2 0\n        // index   0 1 2 3 4\n        const duplicatedableRef = computed(\n        // only duplicate the copy operation in `slide` mode,\n        // because other effects have special process\n        () => translateableRef.value && allowLoopRef.value);\n        // used to calculate total views\n        const displaySlidesPerViewRef = computed(() => userWantsControlRef.value ||\n            props.centeredSlides ||\n            props.effect !== 'slide'\n            ? 1\n            : props.slidesPerView);\n        // used to calculate the size of each slide\n        const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);\n        // we automatically calculate total view for special slides per view\n        const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' ||\n            (props.slidesPerView === 'auto' && props.centeredSlides));\n        const transitionStyleRef = computed(() => props.transitionStyle\n            ? keep(props.transitionStyle, transitionProperties)\n            : {});\n        const speedRef = computed(() => userWantsControlRef.value\n            ? 0\n            : resolveSpeed(transitionStyleRef.value.transitionDuration));\n        const verticalRef = computed(() => props.direction === 'vertical');\n        const sizeAxisRef = computed(() => (verticalRef.value ? 'height' : 'width'));\n        const perViewSizeRef = ref({ width: 0, height: 0 });\n        const slideSizesRef = computed(() => {\n            const { value: slidesEls } = slidesElsRef;\n            const { length } = slidesEls;\n            if (!length)\n                return [];\n            if (autoSlideSizeRef.value) {\n                return slidesEls.map((slide) => calculateSize(slide));\n            }\n            const { value: slidesPerView } = realSlidesPerViewRef;\n            const { value: perViewSize } = perViewSizeRef;\n            const { value: axis } = sizeAxisRef;\n            let slideSize = perViewSize[axis];\n            if (slidesPerView !== 'auto') {\n                const { spaceBetween } = props;\n                const remaining = slideSize - (slidesPerView - 1) * spaceBetween;\n                const percentage = 1 / Math.max(1, slidesPerView);\n                slideSize = remaining * percentage;\n            }\n            return slidesEls.map(() => (Object.assign(Object.assign({}, perViewSize), { [axis]: slideSize })));\n        });\n        // The translate required to reach each slide\n        const slideTranlatesRef = computed(() => {\n            const { value: slideSizes } = slideSizesRef;\n            const { length } = slideSizes;\n            if (!length)\n                return [];\n            const { centeredSlides, spaceBetween } = props;\n            const { value: axis } = sizeAxisRef;\n            const { [axis]: perViewSize } = perViewSizeRef.value;\n            let previousTranslate = 0;\n            return slideSizes.map(({ [axis]: slideSize }) => {\n                let translate = previousTranslate;\n                if (centeredSlides) {\n                    translate += (slideSize - perViewSize) / 2;\n                }\n                previousTranslate += slideSize + spaceBetween;\n                return translate;\n            });\n        });\n        let isMounted = false;\n        const slideStylesRef = computed(() => {\n            const { value: slideSizes } = slideSizesRef;\n            const { length } = slideSizes;\n            if (!length)\n                return [];\n            const { value: axis } = sizeAxisRef;\n            // when user wants to control the transition animation, we center each slide\n            if (userWantsControlRef.value) {\n                return slideSizes.map((size) => ({\n                    [axis]: `${size[axis]}px`\n                }));\n            }\n            const { effect, spaceBetween } = props;\n            const { value: vertical } = verticalRef;\n            const spaceAxis = vertical ? 'bottom' : 'right';\n            const slideStyles = [];\n            for (let i = 0; i < length; i++) {\n                const size = slideSizes[i][axis];\n                const style = {\n                    [axis]: `${size}px`,\n                    [`margin-${spaceAxis}`]: `${spaceBetween}px`\n                };\n                if (isMounted && (effect === 'fade' || effect === 'card')) {\n                    Object.assign(style, transitionStyleRef.value);\n                }\n                slideStyles.push(style);\n            }\n            return slideStyles;\n        });\n        // Total\n        const totalViewRef = computed(() => {\n            const { value: slidesPerView } = displaySlidesPerViewRef;\n            const { length: originLength } = slidesElsRef.value;\n            if (slidesPerView !== 'auto') {\n                return originLength - slidesPerView + 1;\n            }\n            else {\n                const { value: slideSizes } = slideSizesRef;\n                const { length } = slideSizes;\n                if (!length)\n                    return originLength;\n                const { value: translates } = slideTranlatesRef;\n                const { value: axis } = sizeAxisRef;\n                const perViewSize = perViewSizeRef.value[axis];\n                let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n                let i = length;\n                while (i > 1 && lastViewSize < perViewSize) {\n                    i--;\n                    lastViewSize += translates[i] - translates[i - 1];\n                }\n                if (i !== length)\n                    i++;\n                if (i < 1)\n                    i = 1;\n                return i;\n            }\n        });\n        const displayTotalViewRef = computed(() => {\n            const { value: totalView } = totalViewRef;\n            return duplicatedableRef.value && totalView > 3\n                ? totalView - 2\n                : totalView;\n        });\n        // Index\n        const initializeIndex = props.defaultIndex + (duplicatedableRef.value ? 1 : 0);\n        const displayIndexRef = ref(getDisplayIndex(initializeIndex, totalViewRef.value, duplicatedableRef.value));\n        const virtualIndexRef = ref(initializeIndex);\n        const realIndexRef = ref(initializeIndex);\n        // record the translate of each slide, so that it can be restored at touch\n        let previousTranslate = 0;\n        // Reality methods\n        function toRealIndex(index, speed = speedRef.value) {\n            var _a, _b;\n            const { value: length } = totalViewRef;\n            if ((index = clampValue(index, 0, length - 1)) !== realIndexRef.value) {\n                const { value: lastDisplayIndex } = displayIndexRef;\n                // When it is loop from the first silde to the last one,\n                // we control its animation effect\n                if (duplicatedableRef.value && displayTotalViewRef.value > 2) {\n                    if (lastDisplayIndex === 0 && index === displayTotalViewRef.value) {\n                        index = 0;\n                    }\n                    else if (lastDisplayIndex === displayTotalViewRef.value - 1 &&\n                        index === 1) {\n                        index = length - 1;\n                    }\n                }\n                const displayIndex = (displayIndexRef.value = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value));\n                virtualIndexRef.value = index;\n                realIndexRef.value = getRealIndex(displayIndex, duplicatedableRef.value);\n                if (translateableRef.value) {\n                    translateTo(index, speed);\n                }\n                else {\n                    if (!userWantsControlRef.value && speed > 0) {\n                        inTransition = true;\n                    }\n                    fixTranslate();\n                }\n                if (displayIndex !== lastDisplayIndex) {\n                    (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n                    (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n                }\n            }\n        }\n        function getRealPrevIndex(index = realIndexRef.value) {\n            return getPrevIndex(index, totalViewRef.value, props.loop);\n        }\n        function getRealNextIndex(index = realIndexRef.value) {\n            return getNextIndex(index, totalViewRef.value, props.loop);\n        }\n        function isRealPrev(slideOrIndex) {\n            const index = getSlideIndex(slideOrIndex);\n            return index !== null && getRealPrevIndex() === index;\n        }\n        function isRealNext(slideOrIndex) {\n            const index = getSlideIndex(slideOrIndex);\n            return index !== null && getRealNextIndex() === index;\n        }\n        function isRealActive(slideOrIndex) {\n            return realIndexRef.value === getSlideIndex(slideOrIndex);\n        }\n        // Display methods\n        // They are used to deal with the actual values displayed on the UI\n        function isDisplayActive(index) {\n            return displayIndexRef.value === index;\n        }\n        function isPrevDisabled() {\n            return getRealPrevIndex() === null;\n        }\n        function isNextDisabled() {\n            return getRealNextIndex() === null;\n        }\n        // Slide to\n        function to(index) {\n            const realIndex = getRealIndex(index, duplicatedableRef.value);\n            if (index !== displayIndexRef.value || realIndex !== realIndexRef.value) {\n                toRealIndex(realIndex);\n            }\n        }\n        function prev() {\n            const prevIndex = getRealPrevIndex();\n            if (prevIndex !== null) {\n                toRealIndex(prevIndex);\n            }\n        }\n        function next() {\n            const nextIndex = getRealNextIndex();\n            if (nextIndex !== null) {\n                toRealIndex(nextIndex);\n            }\n        }\n        // Translate to\n        const translateStyleRef = ref({});\n        let inTransition = false;\n        function updateTranslate(translate, speed = 0) {\n            const isVersical = props.direction === 'vertical';\n            translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n                transform: isVersical\n                    ? `translateY(${-translate}px)`\n                    : `translateX(${-translate}px)`,\n                transitionDuration: `${speed}ms`\n            });\n        }\n        function fixTranslate(speed = 0) {\n            if (translateableRef.value) {\n                translateTo(realIndexRef.value, speed);\n            }\n            else if (previousTranslate !== 0) {\n                updateTranslate((previousTranslate = 0), speed);\n            }\n        }\n        function translateTo(index, speed = speedRef.value) {\n            const translate = getTranslate(index);\n            if (translate !== previousTranslate && speed > 0) {\n                inTransition = true;\n            }\n            updateTranslate(translate, speed);\n            previousTranslate = getTranslate(realIndexRef.value);\n        }\n        function getTranslate(index) {\n            let translate;\n            // Deal with auto slides pre view\n            if (index >= totalViewRef.value - 1) {\n                translate = getLastViewTranslate();\n            }\n            else {\n                translate = slideTranlatesRef.value[index] || 0;\n            }\n            return translate;\n        }\n        function getLastViewTranslate() {\n            if (displaySlidesPerViewRef.value === 'auto') {\n                const { value: axis } = sizeAxisRef;\n                const { [axis]: perViewSize } = perViewSizeRef.value;\n                const { value: translates } = slideTranlatesRef;\n                const lastTranslate = translates[translates.length - 1];\n                let overallSize;\n                if (lastTranslate === undefined) {\n                    overallSize = perViewSize;\n                }\n                else {\n                    const { value: slideSizes } = slideSizesRef;\n                    overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n                }\n                // Bring the last slide to the edge\n                return overallSize - perViewSize;\n            }\n            else {\n                const { value: translates } = slideTranlatesRef;\n                return translates[totalViewRef.value - 1] || 0;\n            }\n        }\n        // Provide\n        function addSlide(slide) {\n            if (!slide)\n                return;\n            slidesElsRef.value.push(slide);\n        }\n        function removeSlide(slide) {\n            if (!slide)\n                return;\n            const index = getSlideIndex(slide);\n            if (index !== -1) {\n                slidesElsRef.value.splice(index, 1);\n            }\n        }\n        function getSlideIndex(slideOrIndex) {\n            return typeof slideOrIndex === 'number'\n                ? slideOrIndex\n                : slidesElsRef.value.indexOf(slideOrIndex);\n        }\n        function getSlideStyle(slide) {\n            const index = getSlideIndex(slide);\n            if (index !== -1) {\n                return slideStylesRef.value[index];\n            }\n        }\n        function onCarouselItemClick(index, event) {\n            const isTryDrag = 4 /* PROGRESS */ | 8 /* SUCCESS */ | 16 /* FAIL */;\n            let allowClick = !inTransition && !(dragStatus & isTryDrag);\n            if (props.effect === 'card' &&\n                !userWantsControlRef.value &&\n                !(dragStatus & 8 /* SUCCESS */) &&\n                !isRealActive(index)) {\n                to(index);\n                allowClick = false;\n            }\n            if (!allowClick) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        }\n        const carouselMethods = {\n            to,\n            prev: () => {\n                // wait transition end\n                if (!inTransition || !duplicatedableRef.value)\n                    prev();\n            },\n            next: () => {\n                // wait transition end\n                if (!inTransition || !duplicatedableRef.value)\n                    next();\n            },\n            isVertical: () => verticalRef.value,\n            isHorizontal: () => !verticalRef.value,\n            isPrev: isRealPrev,\n            isNext: isRealNext,\n            isActive: isRealActive,\n            isPrevDisabled,\n            isNextDisabled,\n            getCurrentIndex: () => displayIndexRef.value,\n            getSlideIndex,\n            getSlideStyle,\n            addSlide,\n            removeSlide,\n            onCarouselItemClick,\n            prevSlideStyleRef: toRef(props, 'prevSlideStyle'),\n            nextSlideStyleRef: toRef(props, 'nextSlideStyle')\n        };\n        provide(carouselMethodsInjectionKey, carouselMethods);\n        // Autoplay\n        let autoplayTimer = null;\n        function resetAutoplay(cleanOnly) {\n            if (autoplayTimer) {\n                clearInterval(autoplayTimer);\n                autoplayTimer = null;\n            }\n            const { autoplay, interval } = props;\n            if (autoplay && interval && !cleanOnly) {\n                autoplayTimer = setInterval(next, interval);\n            }\n        }\n        function mesureAutoplay() {\n            const { autoplay } = props;\n            if (autoplay) {\n                resetAutoplay();\n            }\n            else if (displayTotalViewRef.value < 2) {\n                resetAutoplay(true);\n            }\n        }\n        // Drag\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragOffset = 0;\n        let dragStartTime = 0;\n        let dragStatus = 1 /* NORMAL */;\n        function handleTouchstart(event) {\n            if (globalDragging)\n                return;\n            dragStartTime = Date.now();\n            dragStatus = 2 /* START */;\n            globalDragging = true;\n            resetAutoplay(true /** cleanOnly */);\n            if (event.type !== 'touchstart' &&\n                !event.target.isContentEditable) {\n                event.preventDefault();\n            }\n            const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n            if (verticalRef.value) {\n                dragStartY = touchEvent.clientY;\n            }\n            else {\n                dragStartX = touchEvent.clientX;\n            }\n            if (props.touchable) {\n                on('touchmove', document, handleTouchmove);\n                on('touchend', document, handleTouchend);\n                on('touchcancel', document, handleTouchend);\n            }\n            if (props.draggable) {\n                on('mousemove', document, handleTouchmove);\n                on('mouseup', document, handleTouchend);\n            }\n        }\n        function handleTouchmove(event) {\n            const { value: vertical } = verticalRef;\n            const axis = vertical ? 'height' : 'width';\n            const perViewSize = perViewSizeRef.value[axis];\n            const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n            const offset = vertical\n                ? touchEvent.clientY - dragStartY\n                : touchEvent.clientX - dragStartX;\n            dragOffset = clampValue(offset, -perViewSize, perViewSize);\n            dragStatus = 4 /* PROGRESS */;\n            if (translateableRef.value) {\n                updateTranslate(previousTranslate - dragOffset, 0);\n            }\n        }\n        function handleTouchend() {\n            const duration = Date.now() - dragStartTime;\n            const { value: axis } = sizeAxisRef;\n            const { value: realIndex } = realIndexRef;\n            const { value: translateable } = translateableRef;\n            let currentIndex = realIndex;\n            if (!inTransition && translateable && dragOffset !== 0) {\n                const currentTranslate = previousTranslate - dragOffset;\n                const translates = [\n                    ...slideTranlatesRef.value.slice(0, totalViewRef.value - 1),\n                    getLastViewTranslate()\n                ];\n                let prevOffset = null;\n                for (let i = 0; i < translates.length; i++) {\n                    const offset = Math.abs(translates[i] - currentTranslate);\n                    if (prevOffset !== null && prevOffset < offset) {\n                        break;\n                    }\n                    prevOffset = offset;\n                    currentIndex = i;\n                }\n            }\n            if (currentIndex === realIndex) {\n                const perViewSize = perViewSizeRef.value[axis];\n                // more than 50% width or faster than 0.4px per ms\n                if (dragOffset > perViewSize / 2 || dragOffset / duration > 0.4) {\n                    currentIndex = getRealPrevIndex(realIndex);\n                }\n                else if (dragOffset < -perViewSize / 2 ||\n                    dragOffset / duration < -0.4) {\n                    currentIndex = getRealNextIndex(realIndex);\n                }\n            }\n            if (currentIndex !== null && currentIndex !== realIndex) {\n                dragStatus = 8 /* SUCCESS */;\n                toRealIndex(currentIndex);\n            }\n            else {\n                if (dragStatus & 4 /* PROGRESS */) {\n                    dragStatus = 16 /* FAIL */;\n                }\n                else {\n                    dragStatus = 32 /* END */;\n                }\n                fixTranslate(speedRef.value);\n            }\n            mesureAutoplay();\n            resetDragStatus();\n        }\n        function resetDragStatus() {\n            if (!(dragStatus & 1 /* NORMAL */)) {\n                globalDragging = false;\n                if (dragStatus & (2 /* START */ | 4 /* PROGRESS */)) {\n                    dragStatus = 1 /* NORMAL */;\n                }\n            }\n            dragStartX = 0;\n            dragStartY = 0;\n            dragOffset = 0;\n            dragStartTime = 0;\n            off('touchmove', document, handleTouchmove);\n            off('touchend', document, handleTouchend);\n            off('touchcancel', document, handleTouchend);\n            off('mousemove', document, handleTouchmove);\n            off('mouseup', document, handleTouchend);\n        }\n        function handleTransitionEnd() {\n            const { value: virtualIndex } = virtualIndexRef;\n            const { value: realIndex } = realIndexRef;\n            if (inTransition && virtualIndex !== realIndex) {\n                translateTo(realIndex, 0);\n            }\n            else {\n                resetAutoplay();\n            }\n            if (translateableRef.value) {\n                translateStyleRef.value.transitionDuration = '0ms';\n            }\n            inTransition = false;\n        }\n        function handleMousewheel(event) {\n            event.preventDefault();\n            if (inTransition)\n                return;\n            const { value: vertical } = verticalRef;\n            let { deltaX, deltaY } = event;\n            if (event.shiftKey && !deltaX) {\n                deltaX = deltaY;\n            }\n            const P_MULTIPLIER = -1;\n            const N_MULTIPLIER = 1;\n            const MULTIPLIER = (deltaX || deltaY) > 0 ? N_MULTIPLIER : P_MULTIPLIER;\n            let rx = 0;\n            let ry = 0;\n            if (vertical) {\n                ry = MULTIPLIER;\n            }\n            else {\n                rx = MULTIPLIER;\n            }\n            const RESPONSE_STEP = 10;\n            if (ry * deltaY >= RESPONSE_STEP || rx * deltaX >= RESPONSE_STEP) {\n                if (MULTIPLIER === N_MULTIPLIER && !isNextDisabled()) {\n                    next();\n                }\n                else if (MULTIPLIER === P_MULTIPLIER && !isPrevDisabled()) {\n                    prev();\n                }\n            }\n        }\n        function handleResize() {\n            perViewSizeRef.value = calculateSize(selfElRef.value, true);\n            resetAutoplay();\n        }\n        function handleSlideResize() {\n            var _a, _b;\n            if (autoSlideSizeRef.value) {\n                (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n                slideSizesRef.effect.run();\n            }\n        }\n        onMounted(() => {\n            watchEffect(mesureAutoplay);\n            void nextTick(() => (isMounted = true));\n        });\n        onBeforeUnmount(() => {\n            resetDragStatus();\n            resetAutoplay(true);\n        });\n        // Fix index when remounting\n        onUpdated(() => {\n            const { value: slidesEls } = slidesElsRef;\n            const { value: slideVNodes } = slideVNodesRef;\n            const indexMap = new Map();\n            const getDisplayIndex = (el) => \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            indexMap.has(el) ? indexMap.get(el) : -1;\n            let isChanged = false;\n            for (let i = 0; i < slidesEls.length; i++) {\n                const index = slideVNodes.findIndex((v) => v.el === slidesEls[i]);\n                if (index !== i) {\n                    isChanged = true;\n                }\n                indexMap.set(slidesEls[i], index);\n            }\n            if (isChanged) {\n                slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n            }\n        });\n        watch(toRef(props, 'currentIndex'), (index) => index !== undefined && to(index));\n        watch(duplicatedableRef, () => void nextTick(() => to(displayIndexRef.value)));\n        watch(slideTranlatesRef, () => translateableRef.value && fixTranslate(), {\n            deep: true\n        });\n        watch(translateableRef, (value) => {\n            if (!value) {\n                inTransition = false;\n                // if the current mode does not support translate, reset the position of the wrapper\n                updateTranslate((previousTranslate = 0));\n            }\n            else {\n                fixTranslate();\n            }\n        });\n        const caroulseSlotProps = {\n            arrowSlotProps: computed(() => (Object.assign({ total: displayTotalViewRef.value, currentIndex: displayIndexRef.value }, keep(carouselMethods, [\n                'to',\n                'prev',\n                'next',\n                'isPrevDisabled',\n                'isNextDisabled'\n            ])))),\n            dotSlotProps: computed(() => ({\n                total: displayTotalViewRef.value,\n                currentIndex: displayIndexRef.value,\n                to\n            }))\n        };\n        const caroulseExposedMethod = {\n            getCurrentIndex: () => displayIndexRef.value,\n            to: to,\n            prev: prev,\n            next: next\n        };\n        const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n        const cssVarsRef = computed(() => {\n            const { common: { cubicBezierEaseInOut }, self: { dotSize, dotColor, dotColorActive, dotColorFocus, dotLineWidth, dotLineWidthActive, arrowColor } } = themeRef.value;\n            return {\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-dot-color': dotColor,\n                '--n-dot-color-focus': dotColorFocus,\n                '--n-dot-color-active': dotColorActive,\n                '--n-dot-size': dotSize,\n                '--n-dot-line-width': dotLineWidth,\n                '--n-dot-line-width-active': dotLineWidthActive,\n                '--n-arrow-color': arrowColor\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('carousel', undefined, cssVarsRef, props)\n            : undefined;\n        return Object.assign(Object.assign(Object.assign({ mergedClsPrefix: mergedClsPrefixRef, selfElRef, slideVNodes: slideVNodesRef, duplicatedable: duplicatedableRef, userWantsControl: userWantsControlRef, autoSlideSize: autoSlideSizeRef, displayIndex: displayIndexRef, realIndex: realIndexRef, slideStyles: slideStylesRef, translateStyle: translateStyleRef, handleTouchstart,\n            handleTransitionEnd,\n            handleMousewheel,\n            handleResize,\n            handleSlideResize, isActive: isDisplayActive }, caroulseSlotProps), caroulseExposedMethod), { cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });\n    },\n    render() {\n        var _a;\n        const { mergedClsPrefix, showArrow, userWantsControl, draggable, touchable, slideStyles, dotType, dotPlacement, transitionProps = {}, arrowSlotProps, dotSlotProps, $slots: { default: defaultSlot, dots: dotsSlot, arrow: arrowSlot } } = this;\n        const children = (defaultSlot && flatten(defaultSlot())) || [];\n        let slides = filterCarouselItem(children);\n        if (!slides.length) {\n            slides = children.map((ch) => (h(NCarouselItem, null, {\n                default: () => cloneVNode(ch)\n            })));\n        }\n        const { length: realLength } = slides;\n        if (realLength > 1 && this.duplicatedable) {\n            slides.push(duplicateSlide(slides[0], 0, 'append'));\n            slides.unshift(duplicateSlide(slides[realLength - 1], realLength - 1, 'prepend'));\n        }\n        this.slideVNodes.value = slides;\n        // When users need to customize the size of the slide,\n        // we listen to them to fix the current translate\n        if (this.autoSlideSize) {\n            slides = slides.map((slide) => (h(VResizeObserver, { onResize: this.handleSlideResize }, {\n                default: () => slide\n            })));\n        }\n        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n        return (h(\"div\", { ref: \"selfElRef\", class: [\n                this.themeClass,\n                `${mergedClsPrefix}-carousel`,\n                this.direction === 'vertical' &&\n                    `${mergedClsPrefix}-carousel--vertical`,\n                this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`,\n                `${mergedClsPrefix}-carousel--${dotPlacement}`,\n                `${mergedClsPrefix}-carousel--${this.direction}`,\n                `${mergedClsPrefix}-carousel--${this.effect}`,\n                userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`\n            ], style: this.cssVars },\n            h(VResizeObserver, { onResize: this.handleResize }, {\n                default: () => (h(\"div\", { class: `${mergedClsPrefix}-carousel__slides`, role: \"listbox\", style: this.translateStyle, onMousedown: draggable ? this.handleTouchstart : undefined, onTouchstart: touchable ? this.handleTouchstart : undefined, onWheel: this.mousewheel ? this.handleMousewheel : undefined, onTransitionend: this.handleTransitionEnd }, userWantsControl\n                    ? slides.map((slide, i) => (h(\"div\", { style: slideStyles[i], key: i }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n                        default: () => slide\n                    }), [[vShow, this.isActive(i)]]))))\n                    : slides))\n            }),\n            this.showDots &&\n                resolveSlotWithProps(dotsSlot, dotSlotProps, () => [\n                    dotSlotProps.total > 1 && (h(NCarouselDots, { key: dotType + dotPlacement, total: dotSlotProps.total, currentIndex: dotSlotProps.currentIndex, dotType: dotType, trigger: this.trigger, keyboard: this.keyboard }))\n                ]),\n            showArrow &&\n                resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [\n                    h(NCarouselArrow, null)\n                ])));\n    }\n});\nfunction filterCarouselItem(vnodes, carouselItems = []) {\n    if (Array.isArray(vnodes)) {\n        vnodes.forEach((vnode) => {\n            if (vnode.type && vnode.type.name === 'CarouselItem') {\n                carouselItems.push(vnode);\n            }\n        });\n    }\n    return carouselItems;\n}\nfunction duplicateSlide(child, index, position) {\n    return cloneVNode(child, {\n        // for patch\n        key: `carousel-item-duplicate-${index}-${position}`\n    });\n}\n"]},"metadata":{},"sourceType":"module"}