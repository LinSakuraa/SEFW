{"ast":null,"code":"export function getFirstAvailableNode(nodes) {\n  if (nodes.length === 0) return null;\n  const node = nodes[0];\n\n  if (node.isGroup || node.ignored || node.disabled) {\n    return node.getNext();\n  }\n\n  return node;\n}\n\nfunction rawGetNext(node, loop) {\n  const sibs = node.siblings;\n  const l = sibs.length;\n  const {\n    index\n  } = node;\n\n  if (loop) {\n    return sibs[(index + 1) % l];\n  } else {\n    if (index === sibs.length - 1) return null;\n    return sibs[index + 1];\n  }\n}\n\nfunction move(fromNode, dir, {\n  loop = false,\n  includeDisabled = false\n} = {}) {\n  const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n  const getChildOptions = {\n    reverse: dir === 'prev'\n  };\n  let meet = false;\n  let endNode = null;\n\n  function traverse(node) {\n    if (node === null) return;\n\n    if (node === fromNode) {\n      if (!meet) {\n        meet = true;\n      } else if (!fromNode.disabled && !fromNode.isGroup) {\n        endNode = fromNode;\n        return;\n      }\n    } else {\n      if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {\n        endNode = node;\n        return;\n      }\n    }\n\n    if (node.isGroup) {\n      const child = getChild(node, getChildOptions);\n\n      if (child !== null) {\n        endNode = child;\n      } else {\n        traverse(iterate(node, loop));\n      }\n    } else {\n      const nextNode = iterate(node, false);\n\n      if (nextNode !== null) {\n        traverse(nextNode);\n      } else {\n        const parent = rawGetParent(node);\n\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n          traverse(iterate(parent, loop));\n        } else if (loop) {\n          traverse(iterate(node, true));\n        }\n      }\n    }\n  }\n\n  traverse(fromNode);\n  return endNode;\n}\n\nfunction rawGetPrev(node, loop) {\n  const sibs = node.siblings;\n  const l = sibs.length;\n  const {\n    index\n  } = node;\n\n  if (loop) {\n    return sibs[(index - 1 + l) % l];\n  } else {\n    if (index === 0) return null;\n    return sibs[index - 1];\n  }\n}\n\nfunction rawGetParent(node) {\n  return node.parent;\n}\n\nfunction getChild(node, options = {}) {\n  const {\n    reverse = false\n  } = options;\n  const {\n    children\n  } = node;\n\n  if (children) {\n    const {\n      length\n    } = children;\n    const start = reverse ? length - 1 : 0;\n    const end = reverse ? -1 : length;\n    const delta = reverse ? -1 : 1;\n\n    for (let i = start; i !== end; i += delta) {\n      const child = children[i];\n\n      if (!child.disabled && !child.ignored) {\n        if (child.isGroup) {\n          const childInGroup = getChild(child, options);\n          if (childInGroup !== null) return childInGroup;\n        } else {\n          return child;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\nexport const moveMethods = {\n  getChild() {\n    if (this.ignored) return null;\n    return getChild(this);\n  },\n\n  getParent() {\n    const {\n      parent\n    } = this;\n\n    if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n      return parent.getParent();\n    }\n\n    return parent;\n  },\n\n  getNext(options = {}) {\n    return move(this, 'next', options);\n  },\n\n  getPrev(options = {}) {\n    return move(this, 'prev', options);\n  }\n\n};","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/treemate/es/move.js"],"names":["getFirstAvailableNode","nodes","length","node","isGroup","ignored","disabled","getNext","rawGetNext","loop","sibs","siblings","l","index","move","fromNode","dir","includeDisabled","iterate","rawGetPrev","getChildOptions","reverse","meet","endNode","traverse","child","getChild","nextNode","parent","rawGetParent","options","children","start","end","delta","i","childInGroup","moveMethods","getParent","getPrev"],"mappings":"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","sourcesContent":["export function getFirstAvailableNode(nodes) {\n    if (nodes.length === 0)\n        return null;\n    const node = nodes[0];\n    if (node.isGroup || node.ignored || node.disabled) {\n        return node.getNext();\n    }\n    return node;\n}\nfunction rawGetNext(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index + 1) % l];\n    }\n    else {\n        if (index === sibs.length - 1)\n            return null;\n        return sibs[index + 1];\n    }\n}\nfunction move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {\n    const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n    const getChildOptions = {\n        reverse: dir === 'prev'\n    };\n    let meet = false;\n    let endNode = null;\n    function traverse(node) {\n        if (node === null)\n            return;\n        if (node === fromNode) {\n            if (!meet) {\n                meet = true;\n            }\n            else if (!fromNode.disabled && !fromNode.isGroup) {\n                endNode = fromNode;\n                return;\n            }\n        }\n        else {\n            if ((!node.disabled || includeDisabled) &&\n                !node.ignored &&\n                !node.isGroup) {\n                endNode = node;\n                return;\n            }\n        }\n        if (node.isGroup) {\n            const child = getChild(node, getChildOptions);\n            if (child !== null) {\n                endNode = child;\n            }\n            else {\n                traverse(iterate(node, loop));\n            }\n        }\n        else {\n            const nextNode = iterate(node, false);\n            if (nextNode !== null) {\n                traverse(nextNode);\n            }\n            else {\n                const parent = rawGetParent(node);\n                if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n                    traverse(iterate(parent, loop));\n                }\n                else if (loop) {\n                    traverse(iterate(node, true));\n                }\n            }\n        }\n    }\n    traverse(fromNode);\n    return endNode;\n}\nfunction rawGetPrev(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index - 1 + l) % l];\n    }\n    else {\n        if (index === 0)\n            return null;\n        return sibs[index - 1];\n    }\n}\nfunction rawGetParent(node) {\n    return node.parent;\n}\nfunction getChild(node, options = {}) {\n    const { reverse = false } = options;\n    const { children } = node;\n    if (children) {\n        const { length } = children;\n        const start = reverse ? length - 1 : 0;\n        const end = reverse ? -1 : length;\n        const delta = reverse ? -1 : 1;\n        for (let i = start; i !== end; i += delta) {\n            const child = children[i];\n            if (!child.disabled && !child.ignored) {\n                if (child.isGroup) {\n                    const childInGroup = getChild(child, options);\n                    if (childInGroup !== null)\n                        return childInGroup;\n                }\n                else {\n                    return child;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport const moveMethods = {\n    getChild() {\n        if (this.ignored)\n            return null;\n        return getChild(this);\n    },\n    getParent() {\n        const { parent } = this;\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n            return parent.getParent();\n        }\n        return parent;\n    },\n    getNext(options = {}) {\n        return move(this, 'next', options);\n    },\n    getPrev(options = {}) {\n        return move(this, 'prev', options);\n    }\n};\n"]},"metadata":{},"sourceType":"module"}