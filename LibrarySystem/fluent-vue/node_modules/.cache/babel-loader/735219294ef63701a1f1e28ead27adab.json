{"ast":null,"code":"/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { defineComponent, renderSlot, h, onMounted, ref, nextTick } from 'vue';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nconst hiddenAttr = 'v-hidden';\nconst style = c('[v-hidden]', {\n  display: 'none!important'\n});\nexport default defineComponent({\n  name: 'Overflow',\n  props: {\n    getCounter: Function,\n    getTail: Function,\n    updateCounter: Function,\n    onUpdateOverflow: Function\n  },\n\n  setup(props, {\n    slots\n  }) {\n    const selfRef = ref(null);\n    const counterRef = ref(null);\n\n    function deriveCounter() {\n      const {\n        value: self\n      } = selfRef;\n      const {\n        getCounter,\n        getTail\n      } = props;\n      let counter;\n      if (getCounter !== undefined) counter = getCounter();else {\n        counter = counterRef.value;\n      }\n      if (!self || !counter) return;\n\n      if (counter.hasAttribute(hiddenAttr)) {\n        counter.removeAttribute(hiddenAttr);\n      }\n\n      const {\n        children\n      } = self;\n      const containerWidth = self.offsetWidth;\n      const childWidths = [];\n      const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;\n      let childWidthSum = tail ? tail.offsetWidth : 0;\n      let overflow = false;\n      const len = self.children.length - (slots.tail ? 1 : 0);\n\n      for (let i = 0; i < len - 1; ++i) {\n        if (i < 0) continue;\n        const child = children[i];\n\n        if (overflow) {\n          if (!child.hasAttribute(hiddenAttr)) {\n            child.setAttribute(hiddenAttr, '');\n          }\n\n          continue;\n        } else if (child.hasAttribute(hiddenAttr)) {\n          child.removeAttribute(hiddenAttr);\n        }\n\n        const childWidth = child.offsetWidth;\n        childWidthSum += childWidth;\n        childWidths[i] = childWidth;\n\n        if (childWidthSum > containerWidth) {\n          const {\n            updateCounter\n          } = props;\n\n          for (let j = i; j >= 0; --j) {\n            const restCount = len - 1 - j;\n\n            if (updateCounter !== undefined) {\n              updateCounter(restCount);\n            } else {\n              counter.textContent = `${restCount}`;\n            }\n\n            const counterWidth = counter.offsetWidth;\n            childWidthSum -= childWidths[j];\n\n            if (childWidthSum + counterWidth <= containerWidth || j === 0) {\n              overflow = true;\n              i = j - 1;\n\n              if (tail) {\n                // tail too long or 1st element too long\n                // we only consider tail now\n                if (i === -1) {\n                  tail.style.maxWidth = `${containerWidth - counterWidth}px`;\n                  tail.style.boxSizing = 'border-box';\n                } else {\n                  tail.style.maxWidth = '';\n                }\n              }\n\n              break;\n            }\n          }\n        }\n      }\n\n      const {\n        onUpdateOverflow\n      } = props;\n\n      if (!overflow) {\n        if (onUpdateOverflow !== undefined) {\n          onUpdateOverflow(false);\n        }\n\n        counter.setAttribute(hiddenAttr, '');\n      } else {\n        if (onUpdateOverflow !== undefined) {\n          onUpdateOverflow(true);\n        }\n      }\n    }\n\n    const ssrAdapter = useSsrAdapter();\n    style.mount({\n      id: 'vueuc/overflow',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onMounted(deriveCounter); // besides onMounted, other case should be manually triggered, or we shoud watch items\n\n    return {\n      selfRef,\n      counterRef,\n      sync: deriveCounter\n    };\n  },\n\n  render() {\n    const {\n      $slots\n    } = this; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    nextTick(this.sync); // It shouldn't have border\n\n    return h('div', {\n      class: 'v-overflow',\n      ref: 'selfRef'\n    }, [renderSlot($slots, 'default'), // $slots.counter should only has 1 element\n    $slots.counter ? $slots.counter() : h('span', {\n      style: {\n        display: 'inline-block'\n      },\n      ref: 'counterRef'\n    }), // $slots.tail should only has 1 element\n    $slots.tail ? $slots.tail() : null]);\n  }\n\n});","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/vueuc/es/overflow/src/index.js"],"names":["defineComponent","renderSlot","h","onMounted","ref","nextTick","useSsrAdapter","c","cssrAnchorMetaName","hiddenAttr","style","display","name","props","getCounter","Function","getTail","updateCounter","onUpdateOverflow","setup","slots","selfRef","counterRef","deriveCounter","value","self","counter","undefined","hasAttribute","removeAttribute","children","containerWidth","offsetWidth","childWidths","tail","childWidthSum","overflow","len","length","i","child","setAttribute","childWidth","j","restCount","textContent","counterWidth","maxWidth","boxSizing","ssrAdapter","mount","id","head","anchorMetaName","ssr","sync","render","$slots","class"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { defineComponent, renderSlot, h, onMounted, ref, nextTick } from 'vue';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nconst hiddenAttr = 'v-hidden';\nconst style = c('[v-hidden]', {\n    display: 'none!important'\n});\nexport default defineComponent({\n    name: 'Overflow',\n    props: {\n        getCounter: Function,\n        getTail: Function,\n        updateCounter: Function,\n        onUpdateOverflow: Function\n    },\n    setup(props, { slots }) {\n        const selfRef = ref(null);\n        const counterRef = ref(null);\n        function deriveCounter() {\n            const { value: self } = selfRef;\n            const { getCounter, getTail } = props;\n            let counter;\n            if (getCounter !== undefined)\n                counter = getCounter();\n            else {\n                counter = counterRef.value;\n            }\n            if (!self || !counter)\n                return;\n            if (counter.hasAttribute(hiddenAttr)) {\n                counter.removeAttribute(hiddenAttr);\n            }\n            const { children } = self;\n            const containerWidth = self.offsetWidth;\n            const childWidths = [];\n            const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;\n            let childWidthSum = tail ? tail.offsetWidth : 0;\n            let overflow = false;\n            const len = self.children.length - (slots.tail ? 1 : 0);\n            for (let i = 0; i < len - 1; ++i) {\n                if (i < 0)\n                    continue;\n                const child = children[i];\n                if (overflow) {\n                    if (!child.hasAttribute(hiddenAttr)) {\n                        child.setAttribute(hiddenAttr, '');\n                    }\n                    continue;\n                }\n                else if (child.hasAttribute(hiddenAttr)) {\n                    child.removeAttribute(hiddenAttr);\n                }\n                const childWidth = child.offsetWidth;\n                childWidthSum += childWidth;\n                childWidths[i] = childWidth;\n                if (childWidthSum > containerWidth) {\n                    const { updateCounter } = props;\n                    for (let j = i; j >= 0; --j) {\n                        const restCount = len - 1 - j;\n                        if (updateCounter !== undefined) {\n                            updateCounter(restCount);\n                        }\n                        else {\n                            counter.textContent = `${restCount}`;\n                        }\n                        const counterWidth = counter.offsetWidth;\n                        childWidthSum -= childWidths[j];\n                        if (childWidthSum + counterWidth <= containerWidth || j === 0) {\n                            overflow = true;\n                            i = j - 1;\n                            if (tail) {\n                                // tail too long or 1st element too long\n                                // we only consider tail now\n                                if (i === -1) {\n                                    tail.style.maxWidth = `${containerWidth - counterWidth}px`;\n                                    tail.style.boxSizing = 'border-box';\n                                }\n                                else {\n                                    tail.style.maxWidth = '';\n                                }\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            const { onUpdateOverflow } = props;\n            if (!overflow) {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(false);\n                }\n                counter.setAttribute(hiddenAttr, '');\n            }\n            else {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(true);\n                }\n            }\n        }\n        const ssrAdapter = useSsrAdapter();\n        style.mount({\n            id: 'vueuc/overflow',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onMounted(deriveCounter);\n        // besides onMounted, other case should be manually triggered, or we shoud watch items\n        return {\n            selfRef,\n            counterRef,\n            sync: deriveCounter\n        };\n    },\n    render() {\n        const { $slots } = this;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nextTick(this.sync);\n        // It shouldn't have border\n        return h('div', {\n            class: 'v-overflow',\n            ref: 'selfRef'\n        }, [\n            renderSlot($slots, 'default'),\n            // $slots.counter should only has 1 element\n            $slots.counter\n                ? $slots.counter()\n                : h('span', {\n                    style: {\n                        display: 'inline-block'\n                    },\n                    ref: 'counterRef'\n                }),\n            // $slots.tail should only has 1 element\n            $slots.tail ? $slots.tail() : null\n        ]);\n    }\n});\n"]},"metadata":{},"sourceType":"module"}