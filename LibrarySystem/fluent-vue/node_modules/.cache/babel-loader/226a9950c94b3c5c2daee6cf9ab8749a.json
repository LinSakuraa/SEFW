{"ast":null,"code":"import { _interpolationEnd, _interpolationStart, DOM } from \"../dom\";\nimport { HTMLBindingDirective } from \"./binding\";\nlet sharedContext = null;\n\nclass CompilationContext {\n  addFactory(factory) {\n    factory.targetIndex = this.targetIndex;\n    this.behaviorFactories.push(factory);\n  }\n\n  captureContentBinding(directive) {\n    directive.targetAtContent();\n    this.addFactory(directive);\n  }\n\n  reset() {\n    this.behaviorFactories = [];\n    this.targetIndex = -1;\n  }\n\n  release() {\n    sharedContext = this;\n  }\n\n  static borrow(directives) {\n    const shareable = sharedContext || new CompilationContext();\n    shareable.directives = directives;\n    shareable.reset();\n    sharedContext = null;\n    return shareable;\n  }\n\n}\n\nfunction createAggregateBinding(parts) {\n  if (parts.length === 1) {\n    return parts[0];\n  }\n\n  let targetName;\n  const partCount = parts.length;\n  const finalParts = parts.map(x => {\n    if (typeof x === \"string\") {\n      return () => x;\n    }\n\n    targetName = x.targetName || targetName;\n    return x.binding;\n  });\n\n  const binding = (scope, context) => {\n    let output = \"\";\n\n    for (let i = 0; i < partCount; ++i) {\n      output += finalParts[i](scope, context);\n    }\n\n    return output;\n  };\n\n  const directive = new HTMLBindingDirective(binding);\n  directive.targetName = targetName;\n  return directive;\n}\n\nconst interpolationEndLength = _interpolationEnd.length;\n\nfunction parseContent(context, value) {\n  const valueParts = value.split(_interpolationStart);\n\n  if (valueParts.length === 1) {\n    return null;\n  }\n\n  const bindingParts = [];\n\n  for (let i = 0, ii = valueParts.length; i < ii; ++i) {\n    const current = valueParts[i];\n    const index = current.indexOf(_interpolationEnd);\n    let literal;\n\n    if (index === -1) {\n      literal = current;\n    } else {\n      const directiveIndex = parseInt(current.substring(0, index));\n      bindingParts.push(context.directives[directiveIndex]);\n      literal = current.substring(index + interpolationEndLength);\n    }\n\n    if (literal !== \"\") {\n      bindingParts.push(literal);\n    }\n  }\n\n  return bindingParts;\n}\n\nfunction compileAttributes(context, node, includeBasicValues = false) {\n  const attributes = node.attributes;\n\n  for (let i = 0, ii = attributes.length; i < ii; ++i) {\n    const attr = attributes[i];\n    const attrValue = attr.value;\n    const parseResult = parseContent(context, attrValue);\n    let result = null;\n\n    if (parseResult === null) {\n      if (includeBasicValues) {\n        result = new HTMLBindingDirective(() => attrValue);\n        result.targetName = attr.name;\n      }\n    } else {\n      result = createAggregateBinding(parseResult);\n    }\n\n    if (result !== null) {\n      node.removeAttributeNode(attr);\n      i--;\n      ii--;\n      context.addFactory(result);\n    }\n  }\n}\n\nfunction compileContent(context, node, walker) {\n  const parseResult = parseContent(context, node.textContent);\n\n  if (parseResult !== null) {\n    let lastNode = node;\n\n    for (let i = 0, ii = parseResult.length; i < ii; ++i) {\n      const currentPart = parseResult[i];\n      const currentNode = i === 0 ? node : lastNode.parentNode.insertBefore(document.createTextNode(\"\"), lastNode.nextSibling);\n\n      if (typeof currentPart === \"string\") {\n        currentNode.textContent = currentPart;\n      } else {\n        currentNode.textContent = \" \";\n        context.captureContentBinding(currentPart);\n      }\n\n      lastNode = currentNode;\n      context.targetIndex++;\n\n      if (currentNode !== node) {\n        walker.nextNode();\n      }\n    }\n\n    context.targetIndex--;\n  }\n}\n/**\n * Compiles a template and associated directives into a raw compilation\n * result which include a cloneable DocumentFragment and factories capable\n * of attaching runtime behavior to nodes within the fragment.\n * @param template - The template to compile.\n * @param directives - The directives referenced by the template.\n * @remarks\n * The template that is provided for compilation is altered in-place\n * and cannot be compiled again. If the original template must be preserved,\n * it is recommended that you clone the original and pass the clone to this API.\n * @public\n */\n\n\nexport function compileTemplate(template, directives) {\n  const fragment = template.content; // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864\n\n  document.adoptNode(fragment);\n  const context = CompilationContext.borrow(directives);\n  compileAttributes(context, template, true);\n  const hostBehaviorFactories = context.behaviorFactories;\n  context.reset();\n  const walker = DOM.createTemplateWalker(fragment);\n  let node;\n\n  while (node = walker.nextNode()) {\n    context.targetIndex++;\n\n    switch (node.nodeType) {\n      case 1:\n        // element node\n        compileAttributes(context, node);\n        break;\n\n      case 3:\n        // text node\n        compileContent(context, node, walker);\n        break;\n\n      case 8:\n        // comment\n        if (DOM.isMarker(node)) {\n          context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);\n        }\n\n    }\n  }\n\n  let targetOffset = 0;\n\n  if ( // If the first node in a fragment is a marker, that means it's an unstable first node,\n  // because something like a when, repeat, etc. could add nodes before the marker.\n  // To mitigate this, we insert a stable first node. However, if we insert a node,\n  // that will alter the result of the TreeWalker. So, we also need to offset the target index.\n  DOM.isMarker(fragment.firstChild) || // Or if there is only one node and a directive, it means the template's content\n  // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by\n  // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.\n  fragment.childNodes.length === 1 && directives.length) {\n    fragment.insertBefore(document.createComment(\"\"), fragment.firstChild);\n    targetOffset = -1;\n  }\n\n  const viewBehaviorFactories = context.behaviorFactories;\n  context.release();\n  return {\n    fragment,\n    viewBehaviorFactories,\n    hostBehaviorFactories,\n    targetOffset\n  };\n}","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js"],"names":["_interpolationEnd","_interpolationStart","DOM","HTMLBindingDirective","sharedContext","CompilationContext","addFactory","factory","targetIndex","behaviorFactories","push","captureContentBinding","directive","targetAtContent","reset","release","borrow","directives","shareable","createAggregateBinding","parts","length","targetName","partCount","finalParts","map","x","binding","scope","context","output","i","interpolationEndLength","parseContent","value","valueParts","split","bindingParts","ii","current","index","indexOf","literal","directiveIndex","parseInt","substring","compileAttributes","node","includeBasicValues","attributes","attr","attrValue","parseResult","result","name","removeAttributeNode","compileContent","walker","textContent","lastNode","currentPart","currentNode","parentNode","insertBefore","document","createTextNode","nextSibling","nextNode","compileTemplate","template","fragment","content","adoptNode","hostBehaviorFactories","createTemplateWalker","nodeType","isMarker","extractDirectiveIndexFromMarker","targetOffset","firstChild","childNodes","createComment","viewBehaviorFactories"],"mappings":"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","sourcesContent":["import { _interpolationEnd, _interpolationStart, DOM } from \"../dom\";\nimport { HTMLBindingDirective } from \"./binding\";\nlet sharedContext = null;\nclass CompilationContext {\n    addFactory(factory) {\n        factory.targetIndex = this.targetIndex;\n        this.behaviorFactories.push(factory);\n    }\n    captureContentBinding(directive) {\n        directive.targetAtContent();\n        this.addFactory(directive);\n    }\n    reset() {\n        this.behaviorFactories = [];\n        this.targetIndex = -1;\n    }\n    release() {\n        sharedContext = this;\n    }\n    static borrow(directives) {\n        const shareable = sharedContext || new CompilationContext();\n        shareable.directives = directives;\n        shareable.reset();\n        sharedContext = null;\n        return shareable;\n    }\n}\nfunction createAggregateBinding(parts) {\n    if (parts.length === 1) {\n        return parts[0];\n    }\n    let targetName;\n    const partCount = parts.length;\n    const finalParts = parts.map((x) => {\n        if (typeof x === \"string\") {\n            return () => x;\n        }\n        targetName = x.targetName || targetName;\n        return x.binding;\n    });\n    const binding = (scope, context) => {\n        let output = \"\";\n        for (let i = 0; i < partCount; ++i) {\n            output += finalParts[i](scope, context);\n        }\n        return output;\n    };\n    const directive = new HTMLBindingDirective(binding);\n    directive.targetName = targetName;\n    return directive;\n}\nconst interpolationEndLength = _interpolationEnd.length;\nfunction parseContent(context, value) {\n    const valueParts = value.split(_interpolationStart);\n    if (valueParts.length === 1) {\n        return null;\n    }\n    const bindingParts = [];\n    for (let i = 0, ii = valueParts.length; i < ii; ++i) {\n        const current = valueParts[i];\n        const index = current.indexOf(_interpolationEnd);\n        let literal;\n        if (index === -1) {\n            literal = current;\n        }\n        else {\n            const directiveIndex = parseInt(current.substring(0, index));\n            bindingParts.push(context.directives[directiveIndex]);\n            literal = current.substring(index + interpolationEndLength);\n        }\n        if (literal !== \"\") {\n            bindingParts.push(literal);\n        }\n    }\n    return bindingParts;\n}\nfunction compileAttributes(context, node, includeBasicValues = false) {\n    const attributes = node.attributes;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n        const attr = attributes[i];\n        const attrValue = attr.value;\n        const parseResult = parseContent(context, attrValue);\n        let result = null;\n        if (parseResult === null) {\n            if (includeBasicValues) {\n                result = new HTMLBindingDirective(() => attrValue);\n                result.targetName = attr.name;\n            }\n        }\n        else {\n            result = createAggregateBinding(parseResult);\n        }\n        if (result !== null) {\n            node.removeAttributeNode(attr);\n            i--;\n            ii--;\n            context.addFactory(result);\n        }\n    }\n}\nfunction compileContent(context, node, walker) {\n    const parseResult = parseContent(context, node.textContent);\n    if (parseResult !== null) {\n        let lastNode = node;\n        for (let i = 0, ii = parseResult.length; i < ii; ++i) {\n            const currentPart = parseResult[i];\n            const currentNode = i === 0\n                ? node\n                : lastNode.parentNode.insertBefore(document.createTextNode(\"\"), lastNode.nextSibling);\n            if (typeof currentPart === \"string\") {\n                currentNode.textContent = currentPart;\n            }\n            else {\n                currentNode.textContent = \" \";\n                context.captureContentBinding(currentPart);\n            }\n            lastNode = currentNode;\n            context.targetIndex++;\n            if (currentNode !== node) {\n                walker.nextNode();\n            }\n        }\n        context.targetIndex--;\n    }\n}\n/**\n * Compiles a template and associated directives into a raw compilation\n * result which include a cloneable DocumentFragment and factories capable\n * of attaching runtime behavior to nodes within the fragment.\n * @param template - The template to compile.\n * @param directives - The directives referenced by the template.\n * @remarks\n * The template that is provided for compilation is altered in-place\n * and cannot be compiled again. If the original template must be preserved,\n * it is recommended that you clone the original and pass the clone to this API.\n * @public\n */\nexport function compileTemplate(template, directives) {\n    const fragment = template.content;\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864\n    document.adoptNode(fragment);\n    const context = CompilationContext.borrow(directives);\n    compileAttributes(context, template, true);\n    const hostBehaviorFactories = context.behaviorFactories;\n    context.reset();\n    const walker = DOM.createTemplateWalker(fragment);\n    let node;\n    while ((node = walker.nextNode())) {\n        context.targetIndex++;\n        switch (node.nodeType) {\n            case 1: // element node\n                compileAttributes(context, node);\n                break;\n            case 3: // text node\n                compileContent(context, node, walker);\n                break;\n            case 8: // comment\n                if (DOM.isMarker(node)) {\n                    context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node)]);\n                }\n        }\n    }\n    let targetOffset = 0;\n    if (\n    // If the first node in a fragment is a marker, that means it's an unstable first node,\n    // because something like a when, repeat, etc. could add nodes before the marker.\n    // To mitigate this, we insert a stable first node. However, if we insert a node,\n    // that will alter the result of the TreeWalker. So, we also need to offset the target index.\n    DOM.isMarker(fragment.firstChild) ||\n        // Or if there is only one node and a directive, it means the template's content\n        // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by\n        // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.\n        (fragment.childNodes.length === 1 && directives.length)) {\n        fragment.insertBefore(document.createComment(\"\"), fragment.firstChild);\n        targetOffset = -1;\n    }\n    const viewBehaviorFactories = context.behaviorFactories;\n    context.release();\n    return {\n        fragment,\n        viewBehaviorFactories,\n        hostBehaviorFactories,\n        targetOffset,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}