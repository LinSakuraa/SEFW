{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, observable, Observable } from \"@microsoft/fast-element\";\nimport { findLastIndex, keyArrowDown, keyArrowUp, keyEnd, keyEnter, keyEscape, keyHome, keySpace, keyTab, uniqueId } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element\";\nimport { isListboxOption } from \"../listbox-option/listbox-option\";\nimport { ARIAGlobalStatesAndProperties } from \"../patterns/aria-global\";\nimport { applyMixins } from \"../utilities/apply-mixins\";\n/**\n * A Listbox Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#listbox | ARIA listbox }.\n *\n * @public\n */\n\nexport class Listbox extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * The internal unfiltered list of selectable options.\n     *\n     * @internal\n     */\n\n    this._options = [];\n    /**\n     * The index of the selected option.\n     *\n     * @public\n     */\n\n    this.selectedIndex = -1;\n    /**\n     * A collection of the selected options.\n     *\n     * @public\n     */\n\n    this.selectedOptions = [];\n    /**\n     * A standard `click` event creates a `focus` event before firing, so a\n     * `mousedown` event is used to skip that initial focus.\n     *\n     * @internal\n     */\n\n    this.shouldSkipFocus = false;\n    /**\n     * The current typeahead buffer string.\n     *\n     * @internal\n     */\n\n    this.typeaheadBuffer = \"\";\n    /**\n     * Flag for the typeahead timeout expiration.\n     *\n     * @internal\n     */\n\n    this.typeaheadExpired = true;\n    /**\n     * The timeout ID for the typeahead handler.\n     *\n     * @internal\n     */\n\n    this.typeaheadTimeout = -1;\n  }\n  /**\n   * The first selected option.\n   *\n   * @internal\n   */\n\n\n  get firstSelectedOption() {\n    var _a;\n\n    return (_a = this.selectedOptions[0]) !== null && _a !== void 0 ? _a : null;\n  }\n  /**\n   * Returns true if there is one or more selectable option.\n   *\n   * @internal\n   */\n\n\n  get hasSelectableOptions() {\n    return this.options.length > 0 && !this.options.every(o => o.disabled);\n  }\n  /**\n   * The number of options.\n   *\n   * @public\n   */\n\n\n  get length() {\n    var _a, _b;\n\n    return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n  }\n  /**\n   * The list of options.\n   *\n   * @public\n   */\n\n\n  get options() {\n    Observable.track(this, \"options\");\n    return this._options;\n  }\n\n  set options(value) {\n    this._options = value;\n    Observable.notify(this, \"options\");\n  }\n  /**\n   * Flag for the typeahead timeout expiration.\n   *\n   * @deprecated use `Listbox.typeaheadExpired`\n   * @internal\n   */\n\n\n  get typeAheadExpired() {\n    return this.typeaheadExpired;\n  }\n\n  set typeAheadExpired(value) {\n    this.typeaheadExpired = value;\n  }\n  /**\n   * Handle click events for listbox options.\n   *\n   * @internal\n   */\n\n\n  clickHandler(e) {\n    const captured = e.target.closest(`option,[role=option]`);\n\n    if (captured && !captured.disabled) {\n      this.selectedIndex = this.options.indexOf(captured);\n      return true;\n    }\n  }\n  /**\n   * Ensures that the provided option is focused and scrolled into view.\n   *\n   * @param optionToFocus - The option to focus\n   * @internal\n   */\n\n\n  focusAndScrollOptionIntoView(optionToFocus = this.firstSelectedOption) {\n    // To ensure that the browser handles both `focus()` and `scrollIntoView()`, the\n    // timing here needs to guarantee that they happen on different frames. Since this\n    // function is typically called from the `openChanged` observer, `DOM.queueUpdate`\n    // causes the calls to be grouped into the same frame. To prevent this,\n    // `requestAnimationFrame` is used instead of `DOM.queueUpdate`.\n    if (this.contains(document.activeElement) && optionToFocus !== null) {\n      optionToFocus.focus();\n      requestAnimationFrame(() => {\n        optionToFocus.scrollIntoView({\n          block: \"nearest\"\n        });\n      });\n    }\n  }\n  /**\n   * Handles `focusin` actions for the component. When the component receives focus,\n   * the list of selected options is refreshed and the first selected option is scrolled\n   * into view.\n   *\n   * @internal\n   */\n\n\n  focusinHandler(e) {\n    if (!this.shouldSkipFocus && e.target === e.currentTarget) {\n      this.setSelectedOptions();\n      this.focusAndScrollOptionIntoView();\n    }\n\n    this.shouldSkipFocus = false;\n  }\n  /**\n   * Returns the options which match the current typeahead buffer.\n   *\n   * @internal\n   */\n\n\n  getTypeaheadMatches() {\n    const pattern = this.typeaheadBuffer.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    const re = new RegExp(`^${pattern}`, \"gi\");\n    return this.options.filter(o => o.text.trim().match(re));\n  }\n  /**\n   * Determines the index of the next option which is selectable, if any.\n   *\n   * @param prev - the previous selected index\n   * @param next - the next index to select\n   *\n   * @internal\n   */\n\n\n  getSelectableIndex(prev = this.selectedIndex, next) {\n    const direction = prev > next ? -1 : prev < next ? 1 : 0;\n    const potentialDirection = prev + direction;\n    let nextSelectableOption = null;\n\n    switch (direction) {\n      case -1:\n        {\n          nextSelectableOption = this.options.reduceRight((nextSelectableOption, thisOption, index) => !nextSelectableOption && !thisOption.disabled && index < potentialDirection ? thisOption : nextSelectableOption, nextSelectableOption);\n          break;\n        }\n\n      case 1:\n        {\n          nextSelectableOption = this.options.reduce((nextSelectableOption, thisOption, index) => !nextSelectableOption && !thisOption.disabled && index > potentialDirection ? thisOption : nextSelectableOption, nextSelectableOption);\n          break;\n        }\n    }\n\n    return this.options.indexOf(nextSelectableOption);\n  }\n  /**\n   * Handles external changes to child options.\n   *\n   * @param source - the source object\n   * @param propertyName - the property\n   *\n   * @internal\n   */\n\n\n  handleChange(source, propertyName) {\n    switch (propertyName) {\n      case \"selected\":\n        {\n          if (Listbox.slottedOptionFilter(source)) {\n            this.selectedIndex = this.options.indexOf(source);\n          }\n\n          this.setSelectedOptions();\n          break;\n        }\n    }\n  }\n  /**\n   * Moves focus to an option whose label matches characters typed by the user.\n   * Consecutive keystrokes are batched into a buffer of search text used\n   * to match against the set of options.  If `TYPE_AHEAD_TIMEOUT_MS` passes\n   * between consecutive keystrokes, the search restarts.\n   *\n   * @param key - the key to be evaluated\n   *\n   * @internal\n   */\n\n\n  handleTypeAhead(key) {\n    if (this.typeaheadTimeout) {\n      window.clearTimeout(this.typeaheadTimeout);\n    }\n\n    this.typeaheadTimeout = window.setTimeout(() => this.typeaheadExpired = true, Listbox.TYPE_AHEAD_TIMEOUT_MS);\n\n    if (key.length > 1) {\n      return;\n    }\n\n    this.typeaheadBuffer = `${this.typeaheadExpired ? \"\" : this.typeaheadBuffer}${key}`;\n  }\n  /**\n   * Handles `keydown` actions for listbox navigation and typeahead.\n   *\n   * @internal\n   */\n\n\n  keydownHandler(e) {\n    if (this.disabled) {\n      return true;\n    }\n\n    this.shouldSkipFocus = false;\n    const key = e.key;\n\n    switch (key) {\n      // Select the first available option\n      case keyHome:\n        {\n          if (!e.shiftKey) {\n            e.preventDefault();\n            this.selectFirstOption();\n          }\n\n          break;\n        }\n      // Select the next selectable option\n\n      case keyArrowDown:\n        {\n          if (!e.shiftKey) {\n            e.preventDefault();\n            this.selectNextOption();\n          }\n\n          break;\n        }\n      // Select the previous selectable option\n\n      case keyArrowUp:\n        {\n          if (!e.shiftKey) {\n            e.preventDefault();\n            this.selectPreviousOption();\n          }\n\n          break;\n        }\n      // Select the last available option\n\n      case keyEnd:\n        {\n          e.preventDefault();\n          this.selectLastOption();\n          break;\n        }\n\n      case keyTab:\n        {\n          this.focusAndScrollOptionIntoView();\n          return true;\n        }\n\n      case keyEnter:\n      case keyEscape:\n        {\n          return true;\n        }\n\n      case keySpace:\n        {\n          if (this.typeaheadExpired) {\n            return true;\n          }\n        }\n      // Send key to Typeahead handler\n\n      default:\n        {\n          if (key.length === 1) {\n            this.handleTypeAhead(`${key}`);\n          }\n\n          return true;\n        }\n    }\n  }\n  /**\n   * Prevents `focusin` events from firing before `click` events when the\n   * element is unfocused.\n   *\n   * @internal\n   */\n\n\n  mousedownHandler(e) {\n    this.shouldSkipFocus = !this.contains(document.activeElement);\n    return true;\n  }\n  /**\n   * Switches between single-selection and multi-selection mode.\n   *\n   * @param prev - the previous value of the `multiple` attribute\n   * @param next - the next value of the `multiple` attribute\n   *\n   * @internal\n   */\n\n\n  multipleChanged(prev, next) {\n    this.ariaMultiSelectable = next ? \"true\" : undefined;\n  }\n  /**\n   * Updates the list of selected options when the `selectedIndex` changes.\n   *\n   * @param prev - the previous selected index value\n   * @param next - the current selected index value\n   *\n   * @internal\n   */\n\n\n  selectedIndexChanged(prev, next) {\n    var _a;\n\n    if (!this.hasSelectableOptions) {\n      this.selectedIndex = -1;\n      return;\n    }\n\n    if (((_a = this.options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.disabled) && typeof prev === \"number\") {\n      const selectableIndex = this.getSelectableIndex(prev, next);\n      const newNext = selectableIndex > -1 ? selectableIndex : prev;\n      this.selectedIndex = newNext;\n\n      if (next === newNext) {\n        this.selectedIndexChanged(next, newNext);\n      }\n\n      return;\n    }\n\n    this.setSelectedOptions();\n  }\n  /**\n   * Updates the selectedness of each option when the list of selected options changes.\n   *\n   * @param prev - the previous list of selected options\n   * @param next - the current list of selected options\n   *\n   * @internal\n   */\n\n\n  selectedOptionsChanged(prev, next) {\n    var _a;\n\n    const filteredNext = next.filter(Listbox.slottedOptionFilter);\n    (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach(o => {\n      const notifier = Observable.getNotifier(o);\n      notifier.unsubscribe(this, \"selected\");\n      o.selected = filteredNext.includes(o);\n      notifier.subscribe(this, \"selected\");\n    });\n  }\n  /**\n   * Moves focus to the first selectable option.\n   *\n   * @public\n   */\n\n\n  selectFirstOption() {\n    var _a, _b;\n\n    if (!this.disabled) {\n      this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(o => !o.disabled)) !== null && _b !== void 0 ? _b : -1;\n    }\n  }\n  /**\n   * Moves focus to the last selectable option.\n   *\n   * @internal\n   */\n\n\n  selectLastOption() {\n    if (!this.disabled) {\n      this.selectedIndex = findLastIndex(this.options, o => !o.disabled);\n    }\n  }\n  /**\n   * Moves focus to the next selectable option.\n   *\n   * @internal\n   */\n\n\n  selectNextOption() {\n    if (!this.disabled && this.selectedIndex < this.options.length - 1) {\n      this.selectedIndex += 1;\n    }\n  }\n  /**\n   * Moves focus to the previous selectable option.\n   *\n   * @internal\n   */\n\n\n  selectPreviousOption() {\n    if (!this.disabled && this.selectedIndex > 0) {\n      this.selectedIndex = this.selectedIndex - 1;\n    }\n  }\n  /**\n   * Updates the selected index to match the first selected option.\n   *\n   * @internal\n   */\n\n\n  setDefaultSelectedOption() {\n    var _a;\n\n    if (this.$fastController.isConnected) {\n      const selectedIndex = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(el => el.getAttribute(\"selected\") !== null);\n\n      if (selectedIndex !== -1) {\n        this.selectedIndex = selectedIndex;\n        return;\n      }\n\n      this.selectedIndex = 0;\n    }\n  }\n  /**\n   * Sets an option as selected and gives it focus.\n   *\n   * @public\n   */\n\n\n  setSelectedOptions() {\n    var _a, _b, _c;\n\n    if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) && !this.disabled) {\n      this.selectedOptions = [this.options[this.selectedIndex]];\n      this.ariaActiveDescendant = (_c = (_b = this.firstSelectedOption) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : \"\";\n      this.focusAndScrollOptionIntoView();\n    }\n  }\n  /**\n   * Updates the list of options and resets the selected option when the slotted option content changes.\n   *\n   * @param prev - the previous list of slotted options\n   * @param next - the current list of slotted options\n   *\n   * @internal\n   */\n\n\n  slottedOptionsChanged(prev, next) {\n    this.options = next.reduce((options, item) => {\n      if (isListboxOption(item)) {\n        options.push(item);\n      }\n\n      return options;\n    }, []);\n    const setSize = `${this.options.length}`;\n    this.options.forEach((option, index) => {\n      if (!option.id) {\n        option.id = uniqueId(\"option-\");\n      }\n\n      option.ariaPosInSet = `${index + 1}`;\n      option.ariaSetSize = setSize;\n    });\n\n    if (this.$fastController.isConnected) {\n      this.setSelectedOptions();\n      this.setDefaultSelectedOption();\n    }\n  }\n  /**\n   * Updates the filtered list of options when the typeahead buffer changes.\n   *\n   * @param prev - the previous typeahead buffer value\n   * @param next - the current typeahead buffer value\n   *\n   * @internal\n   */\n\n\n  typeaheadBufferChanged(prev, next) {\n    if (this.$fastController.isConnected) {\n      const typeaheadMatches = this.getTypeaheadMatches();\n\n      if (typeaheadMatches.length) {\n        const selectedIndex = this.options.indexOf(typeaheadMatches[0]);\n\n        if (selectedIndex > -1) {\n          this.selectedIndex = selectedIndex;\n        }\n      }\n\n      this.typeaheadExpired = false;\n    }\n  }\n\n}\n/**\n * A static filter to include only selectable options.\n *\n * @param n - element to filter\n * @public\n */\n\nListbox.slottedOptionFilter = n => isListboxOption(n) && !n.disabled && !n.hidden;\n/**\n * Typeahead timeout in milliseconds.\n *\n * @internal\n */\n\n\nListbox.TYPE_AHEAD_TIMEOUT_MS = 1000;\n\n__decorate([attr({\n  mode: \"boolean\"\n})], Listbox.prototype, \"disabled\", void 0);\n\n__decorate([attr({\n  mode: \"boolean\"\n})], Listbox.prototype, \"multiple\", void 0);\n\n__decorate([observable], Listbox.prototype, \"selectedIndex\", void 0);\n\n__decorate([observable], Listbox.prototype, \"selectedOptions\", void 0);\n\n__decorate([observable], Listbox.prototype, \"slottedOptions\", void 0);\n\n__decorate([observable], Listbox.prototype, \"typeaheadBuffer\", void 0);\n/**\n * Includes ARIA states and properties relating to the ARIA listbox role\n *\n * @public\n */\n\n\nexport class DelegatesARIAListbox {}\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaActiveDescendant\", void 0);\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaDisabled\", void 0);\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaExpanded\", void 0);\n\n__decorate([observable], DelegatesARIAListbox.prototype, \"ariaMultiSelectable\", void 0);\n\napplyMixins(DelegatesARIAListbox, ARIAGlobalStatesAndProperties);\napplyMixins(Listbox, DelegatesARIAListbox);","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/listbox/listbox.js"],"names":["__decorate","attr","observable","Observable","findLastIndex","keyArrowDown","keyArrowUp","keyEnd","keyEnter","keyEscape","keyHome","keySpace","keyTab","uniqueId","FoundationElement","isListboxOption","ARIAGlobalStatesAndProperties","applyMixins","Listbox","constructor","arguments","_options","selectedIndex","selectedOptions","shouldSkipFocus","typeaheadBuffer","typeaheadExpired","typeaheadTimeout","firstSelectedOption","_a","hasSelectableOptions","options","length","every","o","disabled","_b","track","value","notify","typeAheadExpired","clickHandler","e","captured","target","closest","indexOf","focusAndScrollOptionIntoView","optionToFocus","contains","document","activeElement","focus","requestAnimationFrame","scrollIntoView","block","focusinHandler","currentTarget","setSelectedOptions","getTypeaheadMatches","pattern","replace","re","RegExp","filter","text","trim","match","getSelectableIndex","prev","next","direction","potentialDirection","nextSelectableOption","reduceRight","thisOption","index","reduce","handleChange","source","propertyName","slottedOptionFilter","handleTypeAhead","key","window","clearTimeout","setTimeout","TYPE_AHEAD_TIMEOUT_MS","keydownHandler","shiftKey","preventDefault","selectFirstOption","selectNextOption","selectPreviousOption","selectLastOption","mousedownHandler","multipleChanged","ariaMultiSelectable","undefined","selectedIndexChanged","selectableIndex","newNext","selectedOptionsChanged","filteredNext","forEach","notifier","getNotifier","unsubscribe","selected","includes","subscribe","findIndex","setDefaultSelectedOption","$fastController","isConnected","el","getAttribute","_c","ariaActiveDescendant","id","slottedOptionsChanged","item","push","setSize","option","ariaPosInSet","ariaSetSize","typeaheadBufferChanged","typeaheadMatches","n","hidden","mode","prototype","DelegatesARIAListbox"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,IAAT,EAAeC,UAAf,EAA2BC,UAA3B,QAA6C,yBAA7C;AACA,SAASC,aAAT,EAAwBC,YAAxB,EAAsCC,UAAtC,EAAkDC,MAAlD,EAA0DC,QAA1D,EAAoEC,SAApE,EAA+EC,OAA/E,EAAwFC,QAAxF,EAAkGC,MAAlG,EAA0GC,QAA1G,QAA2H,+BAA3H;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA,SAASC,eAAT,QAAgC,kCAAhC;AACA,SAASC,6BAAT,QAA8C,yBAA9C;AACA,SAASC,WAAT,QAA4B,2BAA5B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,OAAN,SAAsBJ,iBAAtB,CAAwC;AAC3CK,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGC,SAAT;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,QAAL,GAAgB,EAAhB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,aAAL,GAAqB,CAAC,CAAtB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,EAAvB;AACA;AACR;AACA;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,KAAvB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,EAAvB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,gBAAL,GAAwB,IAAxB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,gBAAL,GAAwB,CAAC,CAAzB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AAC2B,MAAnBC,mBAAmB,GAAG;AACtB,QAAIC,EAAJ;;AACA,WAAO,CAACA,EAAE,GAAG,KAAKN,eAAL,CAAqB,CAArB,CAAN,MAAmC,IAAnC,IAA2CM,EAAE,KAAK,KAAK,CAAvD,GAA2DA,EAA3D,GAAgE,IAAvE;AACH;AACD;AACJ;AACA;AACA;AACA;;;AAC4B,MAApBC,oBAAoB,GAAG;AACvB,WAAO,KAAKC,OAAL,CAAaC,MAAb,GAAsB,CAAtB,IAA2B,CAAC,KAAKD,OAAL,CAAaE,KAAb,CAAmBC,CAAC,IAAIA,CAAC,CAACC,QAA1B,CAAnC;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACc,MAANH,MAAM,GAAG;AACT,QAAIH,EAAJ,EAAQO,EAAR;;AACA,WAAO,CAACA,EAAE,GAAG,CAACP,EAAE,GAAG,KAAKE,OAAX,MAAwB,IAAxB,IAAgCF,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACG,MAAlE,MAA8E,IAA9E,IAAsFI,EAAE,KAAK,KAAK,CAAlG,GAAsGA,EAAtG,GAA2G,CAAlH;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACe,MAAPL,OAAO,GAAG;AACV5B,IAAAA,UAAU,CAACkC,KAAX,CAAiB,IAAjB,EAAuB,SAAvB;AACA,WAAO,KAAKhB,QAAZ;AACH;;AACU,MAAPU,OAAO,CAACO,KAAD,EAAQ;AACf,SAAKjB,QAAL,GAAgBiB,KAAhB;AACAnC,IAAAA,UAAU,CAACoC,MAAX,CAAkB,IAAlB,EAAwB,SAAxB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACwB,MAAhBC,gBAAgB,GAAG;AACnB,WAAO,KAAKd,gBAAZ;AACH;;AACmB,MAAhBc,gBAAgB,CAACF,KAAD,EAAQ;AACxB,SAAKZ,gBAAL,GAAwBY,KAAxB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIG,EAAAA,YAAY,CAACC,CAAD,EAAI;AACZ,UAAMC,QAAQ,GAAGD,CAAC,CAACE,MAAF,CAASC,OAAT,CAAkB,sBAAlB,CAAjB;;AACA,QAAIF,QAAQ,IAAI,CAACA,QAAQ,CAACR,QAA1B,EAAoC;AAChC,WAAKb,aAAL,GAAqB,KAAKS,OAAL,CAAae,OAAb,CAAqBH,QAArB,CAArB;AACA,aAAO,IAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACII,EAAAA,4BAA4B,CAACC,aAAa,GAAG,KAAKpB,mBAAtB,EAA2C;AACnE;AACA;AACA;AACA;AACA;AACA,QAAI,KAAKqB,QAAL,CAAcC,QAAQ,CAACC,aAAvB,KAAyCH,aAAa,KAAK,IAA/D,EAAqE;AACjEA,MAAAA,aAAa,CAACI,KAAd;AACAC,MAAAA,qBAAqB,CAAC,MAAM;AACxBL,QAAAA,aAAa,CAACM,cAAd,CAA6B;AAAEC,UAAAA,KAAK,EAAE;AAAT,SAA7B;AACH,OAFoB,CAArB;AAGH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,cAAc,CAACd,CAAD,EAAI;AACd,QAAI,CAAC,KAAKlB,eAAN,IAAyBkB,CAAC,CAACE,MAAF,KAAaF,CAAC,CAACe,aAA5C,EAA2D;AACvD,WAAKC,kBAAL;AACA,WAAKX,4BAAL;AACH;;AACD,SAAKvB,eAAL,GAAuB,KAAvB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACImC,EAAAA,mBAAmB,GAAG;AAClB,UAAMC,OAAO,GAAG,KAAKnC,eAAL,CAAqBoC,OAArB,CAA6B,uBAA7B,EAAsD,MAAtD,CAAhB;AACA,UAAMC,EAAE,GAAG,IAAIC,MAAJ,CAAY,IAAGH,OAAQ,EAAvB,EAA0B,IAA1B,CAAX;AACA,WAAO,KAAK7B,OAAL,CAAaiC,MAAb,CAAqB9B,CAAD,IAAOA,CAAC,CAAC+B,IAAF,CAAOC,IAAP,GAAcC,KAAd,CAAoBL,EAApB,CAA3B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIM,EAAAA,kBAAkB,CAACC,IAAI,GAAG,KAAK/C,aAAb,EAA4BgD,IAA5B,EAAkC;AAChD,UAAMC,SAAS,GAAGF,IAAI,GAAGC,IAAP,GAAc,CAAC,CAAf,GAAmBD,IAAI,GAAGC,IAAP,GAAc,CAAd,GAAkB,CAAvD;AACA,UAAME,kBAAkB,GAAGH,IAAI,GAAGE,SAAlC;AACA,QAAIE,oBAAoB,GAAG,IAA3B;;AACA,YAAQF,SAAR;AACI,WAAK,CAAC,CAAN;AAAS;AACLE,UAAAA,oBAAoB,GAAG,KAAK1C,OAAL,CAAa2C,WAAb,CAAyB,CAACD,oBAAD,EAAuBE,UAAvB,EAAmCC,KAAnC,KAA6C,CAACH,oBAAD,IACzF,CAACE,UAAU,CAACxC,QAD6E,IAEzFyC,KAAK,GAAGJ,kBAFiF,GAGvFG,UAHuF,GAIvFF,oBAJiB,EAIKA,oBAJL,CAAvB;AAKA;AACH;;AACD,WAAK,CAAL;AAAQ;AACJA,UAAAA,oBAAoB,GAAG,KAAK1C,OAAL,CAAa8C,MAAb,CAAoB,CAACJ,oBAAD,EAAuBE,UAAvB,EAAmCC,KAAnC,KAA6C,CAACH,oBAAD,IACpF,CAACE,UAAU,CAACxC,QADwE,IAEpFyC,KAAK,GAAGJ,kBAF4E,GAGlFG,UAHkF,GAIlFF,oBAJiB,EAIKA,oBAJL,CAAvB;AAKA;AACH;AAhBL;;AAkBA,WAAO,KAAK1C,OAAL,CAAae,OAAb,CAAqB2B,oBAArB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,YAAY,CAACC,MAAD,EAASC,YAAT,EAAuB;AAC/B,YAAQA,YAAR;AACI,WAAK,UAAL;AAAiB;AACb,cAAI9D,OAAO,CAAC+D,mBAAR,CAA4BF,MAA5B,CAAJ,EAAyC;AACrC,iBAAKzD,aAAL,GAAqB,KAAKS,OAAL,CAAae,OAAb,CAAqBiC,MAArB,CAArB;AACH;;AACD,eAAKrB,kBAAL;AACA;AACH;AAPL;AASH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIwB,EAAAA,eAAe,CAACC,GAAD,EAAM;AACjB,QAAI,KAAKxD,gBAAT,EAA2B;AACvByD,MAAAA,MAAM,CAACC,YAAP,CAAoB,KAAK1D,gBAAzB;AACH;;AACD,SAAKA,gBAAL,GAAwByD,MAAM,CAACE,UAAP,CAAkB,MAAO,KAAK5D,gBAAL,GAAwB,IAAjD,EAAwDR,OAAO,CAACqE,qBAAhE,CAAxB;;AACA,QAAIJ,GAAG,CAACnD,MAAJ,GAAa,CAAjB,EAAoB;AAChB;AACH;;AACD,SAAKP,eAAL,GAAwB,GAAE,KAAKC,gBAAL,GAAwB,EAAxB,GAA6B,KAAKD,eAAgB,GAAE0D,GAAI,EAAlF;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIK,EAAAA,cAAc,CAAC9C,CAAD,EAAI;AACd,QAAI,KAAKP,QAAT,EAAmB;AACf,aAAO,IAAP;AACH;;AACD,SAAKX,eAAL,GAAuB,KAAvB;AACA,UAAM2D,GAAG,GAAGzC,CAAC,CAACyC,GAAd;;AACA,YAAQA,GAAR;AACI;AACA,WAAKzE,OAAL;AAAc;AACV,cAAI,CAACgC,CAAC,CAAC+C,QAAP,EAAiB;AACb/C,YAAAA,CAAC,CAACgD,cAAF;AACA,iBAAKC,iBAAL;AACH;;AACD;AACH;AACD;;AACA,WAAKtF,YAAL;AAAmB;AACf,cAAI,CAACqC,CAAC,CAAC+C,QAAP,EAAiB;AACb/C,YAAAA,CAAC,CAACgD,cAAF;AACA,iBAAKE,gBAAL;AACH;;AACD;AACH;AACD;;AACA,WAAKtF,UAAL;AAAiB;AACb,cAAI,CAACoC,CAAC,CAAC+C,QAAP,EAAiB;AACb/C,YAAAA,CAAC,CAACgD,cAAF;AACA,iBAAKG,oBAAL;AACH;;AACD;AACH;AACD;;AACA,WAAKtF,MAAL;AAAa;AACTmC,UAAAA,CAAC,CAACgD,cAAF;AACA,eAAKI,gBAAL;AACA;AACH;;AACD,WAAKlF,MAAL;AAAa;AACT,eAAKmC,4BAAL;AACA,iBAAO,IAAP;AACH;;AACD,WAAKvC,QAAL;AACA,WAAKC,SAAL;AAAgB;AACZ,iBAAO,IAAP;AACH;;AACD,WAAKE,QAAL;AAAe;AACX,cAAI,KAAKe,gBAAT,EAA2B;AACvB,mBAAO,IAAP;AACH;AACJ;AACD;;AACA;AAAS;AACL,cAAIyD,GAAG,CAACnD,MAAJ,KAAe,CAAnB,EAAsB;AAClB,iBAAKkD,eAAL,CAAsB,GAAEC,GAAI,EAA5B;AACH;;AACD,iBAAO,IAAP;AACH;AAlDL;AAoDH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIY,EAAAA,gBAAgB,CAACrD,CAAD,EAAI;AAChB,SAAKlB,eAAL,GAAuB,CAAC,KAAKyB,QAAL,CAAcC,QAAQ,CAACC,aAAvB,CAAxB;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI6C,EAAAA,eAAe,CAAC3B,IAAD,EAAOC,IAAP,EAAa;AACxB,SAAK2B,mBAAL,GAA2B3B,IAAI,GAAG,MAAH,GAAY4B,SAA3C;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,oBAAoB,CAAC9B,IAAD,EAAOC,IAAP,EAAa;AAC7B,QAAIzC,EAAJ;;AACA,QAAI,CAAC,KAAKC,oBAAV,EAAgC;AAC5B,WAAKR,aAAL,GAAqB,CAAC,CAAtB;AACA;AACH;;AACD,QAAI,CAAC,CAACO,EAAE,GAAG,KAAKE,OAAL,CAAa,KAAKT,aAAlB,CAAN,MAA4C,IAA5C,IAAoDO,EAAE,KAAK,KAAK,CAAhE,GAAoE,KAAK,CAAzE,GAA6EA,EAAE,CAACM,QAAjF,KAA8F,OAAOkC,IAAP,KAAgB,QAAlH,EAA4H;AACxH,YAAM+B,eAAe,GAAG,KAAKhC,kBAAL,CAAwBC,IAAxB,EAA8BC,IAA9B,CAAxB;AACA,YAAM+B,OAAO,GAAGD,eAAe,GAAG,CAAC,CAAnB,GAAuBA,eAAvB,GAAyC/B,IAAzD;AACA,WAAK/C,aAAL,GAAqB+E,OAArB;;AACA,UAAI/B,IAAI,KAAK+B,OAAb,EAAsB;AAClB,aAAKF,oBAAL,CAA0B7B,IAA1B,EAAgC+B,OAAhC;AACH;;AACD;AACH;;AACD,SAAK3C,kBAAL;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI4C,EAAAA,sBAAsB,CAACjC,IAAD,EAAOC,IAAP,EAAa;AAC/B,QAAIzC,EAAJ;;AACA,UAAM0E,YAAY,GAAGjC,IAAI,CAACN,MAAL,CAAY9C,OAAO,CAAC+D,mBAApB,CAArB;AACA,KAACpD,EAAE,GAAG,KAAKE,OAAX,MAAwB,IAAxB,IAAgCF,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAAC2E,OAAH,CAAWtE,CAAC,IAAI;AACrE,YAAMuE,QAAQ,GAAGtG,UAAU,CAACuG,WAAX,CAAuBxE,CAAvB,CAAjB;AACAuE,MAAAA,QAAQ,CAACE,WAAT,CAAqB,IAArB,EAA2B,UAA3B;AACAzE,MAAAA,CAAC,CAAC0E,QAAF,GAAaL,YAAY,CAACM,QAAb,CAAsB3E,CAAtB,CAAb;AACAuE,MAAAA,QAAQ,CAACK,SAAT,CAAmB,IAAnB,EAAyB,UAAzB;AACH,KALwD,CAAzD;AAMH;AACD;AACJ;AACA;AACA;AACA;;;AACInB,EAAAA,iBAAiB,GAAG;AAChB,QAAI9D,EAAJ,EAAQO,EAAR;;AACA,QAAI,CAAC,KAAKD,QAAV,EAAoB;AAChB,WAAKb,aAAL,GAAqB,CAACc,EAAE,GAAG,CAACP,EAAE,GAAG,KAAKE,OAAX,MAAwB,IAAxB,IAAgCF,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACkF,SAAH,CAAa7E,CAAC,IAAI,CAACA,CAAC,CAACC,QAArB,CAA/D,MAAmG,IAAnG,IAA2GC,EAAE,KAAK,KAAK,CAAvH,GAA2HA,EAA3H,GAAgI,CAAC,CAAtJ;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACI0D,EAAAA,gBAAgB,GAAG;AACf,QAAI,CAAC,KAAK3D,QAAV,EAAoB;AAChB,WAAKb,aAAL,GAAqBlB,aAAa,CAAC,KAAK2B,OAAN,EAAeG,CAAC,IAAI,CAACA,CAAC,CAACC,QAAvB,CAAlC;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIyD,EAAAA,gBAAgB,GAAG;AACf,QAAI,CAAC,KAAKzD,QAAN,IAAkB,KAAKb,aAAL,GAAqB,KAAKS,OAAL,CAAaC,MAAb,GAAsB,CAAjE,EAAoE;AAChE,WAAKV,aAAL,IAAsB,CAAtB;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIuE,EAAAA,oBAAoB,GAAG;AACnB,QAAI,CAAC,KAAK1D,QAAN,IAAkB,KAAKb,aAAL,GAAqB,CAA3C,EAA8C;AAC1C,WAAKA,aAAL,GAAqB,KAAKA,aAAL,GAAqB,CAA1C;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACI0F,EAAAA,wBAAwB,GAAG;AACvB,QAAInF,EAAJ;;AACA,QAAI,KAAKoF,eAAL,CAAqBC,WAAzB,EAAsC;AAClC,YAAM5F,aAAa,GAAG,CAACO,EAAE,GAAG,KAAKE,OAAX,MAAwB,IAAxB,IAAgCF,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACkF,SAAH,CAAaI,EAAE,IAAIA,EAAE,CAACC,YAAH,CAAgB,UAAhB,MAAgC,IAAnD,CAA/E;;AACA,UAAI9F,aAAa,KAAK,CAAC,CAAvB,EAA0B;AACtB,aAAKA,aAAL,GAAqBA,aAArB;AACA;AACH;;AACD,WAAKA,aAAL,GAAqB,CAArB;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIoC,EAAAA,kBAAkB,GAAG;AACjB,QAAI7B,EAAJ,EAAQO,EAAR,EAAYiF,EAAZ;;AACA,QAAI,CAAC,CAACxF,EAAE,GAAG,KAAKE,OAAX,MAAwB,IAAxB,IAAgCF,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACG,MAA7D,KAAwE,CAAC,KAAKG,QAAlF,EAA4F;AACxF,WAAKZ,eAAL,GAAuB,CAAC,KAAKQ,OAAL,CAAa,KAAKT,aAAlB,CAAD,CAAvB;AACA,WAAKgG,oBAAL,GAA4B,CAACD,EAAE,GAAG,CAACjF,EAAE,GAAG,KAAKR,mBAAX,MAAoC,IAApC,IAA4CQ,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAACmF,EAA9E,MAAsF,IAAtF,IAA8FF,EAAE,KAAK,KAAK,CAA1G,GAA8GA,EAA9G,GAAmH,EAA/I;AACA,WAAKtE,4BAAL;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIyE,EAAAA,qBAAqB,CAACnD,IAAD,EAAOC,IAAP,EAAa;AAC9B,SAAKvC,OAAL,GAAeuC,IAAI,CAACO,MAAL,CAAY,CAAC9C,OAAD,EAAU0F,IAAV,KAAmB;AAC1C,UAAI1G,eAAe,CAAC0G,IAAD,CAAnB,EAA2B;AACvB1F,QAAAA,OAAO,CAAC2F,IAAR,CAAaD,IAAb;AACH;;AACD,aAAO1F,OAAP;AACH,KALc,EAKZ,EALY,CAAf;AAMA,UAAM4F,OAAO,GAAI,GAAE,KAAK5F,OAAL,CAAaC,MAAO,EAAvC;AACA,SAAKD,OAAL,CAAayE,OAAb,CAAqB,CAACoB,MAAD,EAAShD,KAAT,KAAmB;AACpC,UAAI,CAACgD,MAAM,CAACL,EAAZ,EAAgB;AACZK,QAAAA,MAAM,CAACL,EAAP,GAAY1G,QAAQ,CAAC,SAAD,CAApB;AACH;;AACD+G,MAAAA,MAAM,CAACC,YAAP,GAAuB,GAAEjD,KAAK,GAAG,CAAE,EAAnC;AACAgD,MAAAA,MAAM,CAACE,WAAP,GAAqBH,OAArB;AACH,KAND;;AAOA,QAAI,KAAKV,eAAL,CAAqBC,WAAzB,EAAsC;AAClC,WAAKxD,kBAAL;AACA,WAAKsD,wBAAL;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIe,EAAAA,sBAAsB,CAAC1D,IAAD,EAAOC,IAAP,EAAa;AAC/B,QAAI,KAAK2C,eAAL,CAAqBC,WAAzB,EAAsC;AAClC,YAAMc,gBAAgB,GAAG,KAAKrE,mBAAL,EAAzB;;AACA,UAAIqE,gBAAgB,CAAChG,MAArB,EAA6B;AACzB,cAAMV,aAAa,GAAG,KAAKS,OAAL,CAAae,OAAb,CAAqBkF,gBAAgB,CAAC,CAAD,CAArC,CAAtB;;AACA,YAAI1G,aAAa,GAAG,CAAC,CAArB,EAAwB;AACpB,eAAKA,aAAL,GAAqBA,aAArB;AACH;AACJ;;AACD,WAAKI,gBAAL,GAAwB,KAAxB;AACH;AACJ;;AArd0C;AAud/C;AACA;AACA;AACA;AACA;AACA;;AACAR,OAAO,CAAC+D,mBAAR,GAA+BgD,CAAD,IAAOlH,eAAe,CAACkH,CAAD,CAAf,IAAsB,CAACA,CAAC,CAAC9F,QAAzB,IAAqC,CAAC8F,CAAC,CAACC,MAA7E;AACA;AACA;AACA;AACA;AACA;;;AACAhH,OAAO,CAACqE,qBAAR,GAAgC,IAAhC;;AACAvF,UAAU,CAAC,CACPC,IAAI,CAAC;AAAEkI,EAAAA,IAAI,EAAE;AAAR,CAAD,CADG,CAAD,EAEPjH,OAAO,CAACkH,SAFD,EAEY,UAFZ,EAEwB,KAAK,CAF7B,CAAV;;AAGApI,UAAU,CAAC,CACPC,IAAI,CAAC;AAAEkI,EAAAA,IAAI,EAAE;AAAR,CAAD,CADG,CAAD,EAEPjH,OAAO,CAACkH,SAFD,EAEY,UAFZ,EAEwB,KAAK,CAF7B,CAAV;;AAGApI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPgB,OAAO,CAACkH,SAFD,EAEY,eAFZ,EAE6B,KAAK,CAFlC,CAAV;;AAGApI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPgB,OAAO,CAACkH,SAFD,EAEY,iBAFZ,EAE+B,KAAK,CAFpC,CAAV;;AAGApI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPgB,OAAO,CAACkH,SAFD,EAEY,gBAFZ,EAE8B,KAAK,CAFnC,CAAV;;AAGApI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPgB,OAAO,CAACkH,SAFD,EAEY,iBAFZ,EAE+B,KAAK,CAFpC,CAAV;AAGA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,oBAAN,CAA2B;;AAElCrI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPmI,oBAAoB,CAACD,SAFd,EAEyB,sBAFzB,EAEiD,KAAK,CAFtD,CAAV;;AAGApI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPmI,oBAAoB,CAACD,SAFd,EAEyB,cAFzB,EAEyC,KAAK,CAF9C,CAAV;;AAGApI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPmI,oBAAoB,CAACD,SAFd,EAEyB,cAFzB,EAEyC,KAAK,CAF9C,CAAV;;AAGApI,UAAU,CAAC,CACPE,UADO,CAAD,EAEPmI,oBAAoB,CAACD,SAFd,EAEyB,qBAFzB,EAEgD,KAAK,CAFrD,CAAV;;AAGAnH,WAAW,CAACoH,oBAAD,EAAuBrH,6BAAvB,CAAX;AACAC,WAAW,CAACC,OAAD,EAAUmH,oBAAV,CAAX","sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, observable, Observable } from \"@microsoft/fast-element\";\nimport { findLastIndex, keyArrowDown, keyArrowUp, keyEnd, keyEnter, keyEscape, keyHome, keySpace, keyTab, uniqueId, } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element\";\nimport { isListboxOption } from \"../listbox-option/listbox-option\";\nimport { ARIAGlobalStatesAndProperties } from \"../patterns/aria-global\";\nimport { applyMixins } from \"../utilities/apply-mixins\";\n/**\n * A Listbox Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#listbox | ARIA listbox }.\n *\n * @public\n */\nexport class Listbox extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * The internal unfiltered list of selectable options.\n         *\n         * @internal\n         */\n        this._options = [];\n        /**\n         * The index of the selected option.\n         *\n         * @public\n         */\n        this.selectedIndex = -1;\n        /**\n         * A collection of the selected options.\n         *\n         * @public\n         */\n        this.selectedOptions = [];\n        /**\n         * A standard `click` event creates a `focus` event before firing, so a\n         * `mousedown` event is used to skip that initial focus.\n         *\n         * @internal\n         */\n        this.shouldSkipFocus = false;\n        /**\n         * The current typeahead buffer string.\n         *\n         * @internal\n         */\n        this.typeaheadBuffer = \"\";\n        /**\n         * Flag for the typeahead timeout expiration.\n         *\n         * @internal\n         */\n        this.typeaheadExpired = true;\n        /**\n         * The timeout ID for the typeahead handler.\n         *\n         * @internal\n         */\n        this.typeaheadTimeout = -1;\n    }\n    /**\n     * The first selected option.\n     *\n     * @internal\n     */\n    get firstSelectedOption() {\n        var _a;\n        return (_a = this.selectedOptions[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Returns true if there is one or more selectable option.\n     *\n     * @internal\n     */\n    get hasSelectableOptions() {\n        return this.options.length > 0 && !this.options.every(o => o.disabled);\n    }\n    /**\n     * The number of options.\n     *\n     * @public\n     */\n    get length() {\n        var _a, _b;\n        return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n    }\n    /**\n     * The list of options.\n     *\n     * @public\n     */\n    get options() {\n        Observable.track(this, \"options\");\n        return this._options;\n    }\n    set options(value) {\n        this._options = value;\n        Observable.notify(this, \"options\");\n    }\n    /**\n     * Flag for the typeahead timeout expiration.\n     *\n     * @deprecated use `Listbox.typeaheadExpired`\n     * @internal\n     */\n    get typeAheadExpired() {\n        return this.typeaheadExpired;\n    }\n    set typeAheadExpired(value) {\n        this.typeaheadExpired = value;\n    }\n    /**\n     * Handle click events for listbox options.\n     *\n     * @internal\n     */\n    clickHandler(e) {\n        const captured = e.target.closest(`option,[role=option]`);\n        if (captured && !captured.disabled) {\n            this.selectedIndex = this.options.indexOf(captured);\n            return true;\n        }\n    }\n    /**\n     * Ensures that the provided option is focused and scrolled into view.\n     *\n     * @param optionToFocus - The option to focus\n     * @internal\n     */\n    focusAndScrollOptionIntoView(optionToFocus = this.firstSelectedOption) {\n        // To ensure that the browser handles both `focus()` and `scrollIntoView()`, the\n        // timing here needs to guarantee that they happen on different frames. Since this\n        // function is typically called from the `openChanged` observer, `DOM.queueUpdate`\n        // causes the calls to be grouped into the same frame. To prevent this,\n        // `requestAnimationFrame` is used instead of `DOM.queueUpdate`.\n        if (this.contains(document.activeElement) && optionToFocus !== null) {\n            optionToFocus.focus();\n            requestAnimationFrame(() => {\n                optionToFocus.scrollIntoView({ block: \"nearest\" });\n            });\n        }\n    }\n    /**\n     * Handles `focusin` actions for the component. When the component receives focus,\n     * the list of selected options is refreshed and the first selected option is scrolled\n     * into view.\n     *\n     * @internal\n     */\n    focusinHandler(e) {\n        if (!this.shouldSkipFocus && e.target === e.currentTarget) {\n            this.setSelectedOptions();\n            this.focusAndScrollOptionIntoView();\n        }\n        this.shouldSkipFocus = false;\n    }\n    /**\n     * Returns the options which match the current typeahead buffer.\n     *\n     * @internal\n     */\n    getTypeaheadMatches() {\n        const pattern = this.typeaheadBuffer.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        const re = new RegExp(`^${pattern}`, \"gi\");\n        return this.options.filter((o) => o.text.trim().match(re));\n    }\n    /**\n     * Determines the index of the next option which is selectable, if any.\n     *\n     * @param prev - the previous selected index\n     * @param next - the next index to select\n     *\n     * @internal\n     */\n    getSelectableIndex(prev = this.selectedIndex, next) {\n        const direction = prev > next ? -1 : prev < next ? 1 : 0;\n        const potentialDirection = prev + direction;\n        let nextSelectableOption = null;\n        switch (direction) {\n            case -1: {\n                nextSelectableOption = this.options.reduceRight((nextSelectableOption, thisOption, index) => !nextSelectableOption &&\n                    !thisOption.disabled &&\n                    index < potentialDirection\n                    ? thisOption\n                    : nextSelectableOption, nextSelectableOption);\n                break;\n            }\n            case 1: {\n                nextSelectableOption = this.options.reduce((nextSelectableOption, thisOption, index) => !nextSelectableOption &&\n                    !thisOption.disabled &&\n                    index > potentialDirection\n                    ? thisOption\n                    : nextSelectableOption, nextSelectableOption);\n                break;\n            }\n        }\n        return this.options.indexOf(nextSelectableOption);\n    }\n    /**\n     * Handles external changes to child options.\n     *\n     * @param source - the source object\n     * @param propertyName - the property\n     *\n     * @internal\n     */\n    handleChange(source, propertyName) {\n        switch (propertyName) {\n            case \"selected\": {\n                if (Listbox.slottedOptionFilter(source)) {\n                    this.selectedIndex = this.options.indexOf(source);\n                }\n                this.setSelectedOptions();\n                break;\n            }\n        }\n    }\n    /**\n     * Moves focus to an option whose label matches characters typed by the user.\n     * Consecutive keystrokes are batched into a buffer of search text used\n     * to match against the set of options.  If `TYPE_AHEAD_TIMEOUT_MS` passes\n     * between consecutive keystrokes, the search restarts.\n     *\n     * @param key - the key to be evaluated\n     *\n     * @internal\n     */\n    handleTypeAhead(key) {\n        if (this.typeaheadTimeout) {\n            window.clearTimeout(this.typeaheadTimeout);\n        }\n        this.typeaheadTimeout = window.setTimeout(() => (this.typeaheadExpired = true), Listbox.TYPE_AHEAD_TIMEOUT_MS);\n        if (key.length > 1) {\n            return;\n        }\n        this.typeaheadBuffer = `${this.typeaheadExpired ? \"\" : this.typeaheadBuffer}${key}`;\n    }\n    /**\n     * Handles `keydown` actions for listbox navigation and typeahead.\n     *\n     * @internal\n     */\n    keydownHandler(e) {\n        if (this.disabled) {\n            return true;\n        }\n        this.shouldSkipFocus = false;\n        const key = e.key;\n        switch (key) {\n            // Select the first available option\n            case keyHome: {\n                if (!e.shiftKey) {\n                    e.preventDefault();\n                    this.selectFirstOption();\n                }\n                break;\n            }\n            // Select the next selectable option\n            case keyArrowDown: {\n                if (!e.shiftKey) {\n                    e.preventDefault();\n                    this.selectNextOption();\n                }\n                break;\n            }\n            // Select the previous selectable option\n            case keyArrowUp: {\n                if (!e.shiftKey) {\n                    e.preventDefault();\n                    this.selectPreviousOption();\n                }\n                break;\n            }\n            // Select the last available option\n            case keyEnd: {\n                e.preventDefault();\n                this.selectLastOption();\n                break;\n            }\n            case keyTab: {\n                this.focusAndScrollOptionIntoView();\n                return true;\n            }\n            case keyEnter:\n            case keyEscape: {\n                return true;\n            }\n            case keySpace: {\n                if (this.typeaheadExpired) {\n                    return true;\n                }\n            }\n            // Send key to Typeahead handler\n            default: {\n                if (key.length === 1) {\n                    this.handleTypeAhead(`${key}`);\n                }\n                return true;\n            }\n        }\n    }\n    /**\n     * Prevents `focusin` events from firing before `click` events when the\n     * element is unfocused.\n     *\n     * @internal\n     */\n    mousedownHandler(e) {\n        this.shouldSkipFocus = !this.contains(document.activeElement);\n        return true;\n    }\n    /**\n     * Switches between single-selection and multi-selection mode.\n     *\n     * @param prev - the previous value of the `multiple` attribute\n     * @param next - the next value of the `multiple` attribute\n     *\n     * @internal\n     */\n    multipleChanged(prev, next) {\n        this.ariaMultiSelectable = next ? \"true\" : undefined;\n    }\n    /**\n     * Updates the list of selected options when the `selectedIndex` changes.\n     *\n     * @param prev - the previous selected index value\n     * @param next - the current selected index value\n     *\n     * @internal\n     */\n    selectedIndexChanged(prev, next) {\n        var _a;\n        if (!this.hasSelectableOptions) {\n            this.selectedIndex = -1;\n            return;\n        }\n        if (((_a = this.options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.disabled) && typeof prev === \"number\") {\n            const selectableIndex = this.getSelectableIndex(prev, next);\n            const newNext = selectableIndex > -1 ? selectableIndex : prev;\n            this.selectedIndex = newNext;\n            if (next === newNext) {\n                this.selectedIndexChanged(next, newNext);\n            }\n            return;\n        }\n        this.setSelectedOptions();\n    }\n    /**\n     * Updates the selectedness of each option when the list of selected options changes.\n     *\n     * @param prev - the previous list of selected options\n     * @param next - the current list of selected options\n     *\n     * @internal\n     */\n    selectedOptionsChanged(prev, next) {\n        var _a;\n        const filteredNext = next.filter(Listbox.slottedOptionFilter);\n        (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach(o => {\n            const notifier = Observable.getNotifier(o);\n            notifier.unsubscribe(this, \"selected\");\n            o.selected = filteredNext.includes(o);\n            notifier.subscribe(this, \"selected\");\n        });\n    }\n    /**\n     * Moves focus to the first selectable option.\n     *\n     * @public\n     */\n    selectFirstOption() {\n        var _a, _b;\n        if (!this.disabled) {\n            this.selectedIndex = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(o => !o.disabled)) !== null && _b !== void 0 ? _b : -1;\n        }\n    }\n    /**\n     * Moves focus to the last selectable option.\n     *\n     * @internal\n     */\n    selectLastOption() {\n        if (!this.disabled) {\n            this.selectedIndex = findLastIndex(this.options, o => !o.disabled);\n        }\n    }\n    /**\n     * Moves focus to the next selectable option.\n     *\n     * @internal\n     */\n    selectNextOption() {\n        if (!this.disabled && this.selectedIndex < this.options.length - 1) {\n            this.selectedIndex += 1;\n        }\n    }\n    /**\n     * Moves focus to the previous selectable option.\n     *\n     * @internal\n     */\n    selectPreviousOption() {\n        if (!this.disabled && this.selectedIndex > 0) {\n            this.selectedIndex = this.selectedIndex - 1;\n        }\n    }\n    /**\n     * Updates the selected index to match the first selected option.\n     *\n     * @internal\n     */\n    setDefaultSelectedOption() {\n        var _a;\n        if (this.$fastController.isConnected) {\n            const selectedIndex = (_a = this.options) === null || _a === void 0 ? void 0 : _a.findIndex(el => el.getAttribute(\"selected\") !== null);\n            if (selectedIndex !== -1) {\n                this.selectedIndex = selectedIndex;\n                return;\n            }\n            this.selectedIndex = 0;\n        }\n    }\n    /**\n     * Sets an option as selected and gives it focus.\n     *\n     * @public\n     */\n    setSelectedOptions() {\n        var _a, _b, _c;\n        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) && !this.disabled) {\n            this.selectedOptions = [this.options[this.selectedIndex]];\n            this.ariaActiveDescendant = (_c = (_b = this.firstSelectedOption) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : \"\";\n            this.focusAndScrollOptionIntoView();\n        }\n    }\n    /**\n     * Updates the list of options and resets the selected option when the slotted option content changes.\n     *\n     * @param prev - the previous list of slotted options\n     * @param next - the current list of slotted options\n     *\n     * @internal\n     */\n    slottedOptionsChanged(prev, next) {\n        this.options = next.reduce((options, item) => {\n            if (isListboxOption(item)) {\n                options.push(item);\n            }\n            return options;\n        }, []);\n        const setSize = `${this.options.length}`;\n        this.options.forEach((option, index) => {\n            if (!option.id) {\n                option.id = uniqueId(\"option-\");\n            }\n            option.ariaPosInSet = `${index + 1}`;\n            option.ariaSetSize = setSize;\n        });\n        if (this.$fastController.isConnected) {\n            this.setSelectedOptions();\n            this.setDefaultSelectedOption();\n        }\n    }\n    /**\n     * Updates the filtered list of options when the typeahead buffer changes.\n     *\n     * @param prev - the previous typeahead buffer value\n     * @param next - the current typeahead buffer value\n     *\n     * @internal\n     */\n    typeaheadBufferChanged(prev, next) {\n        if (this.$fastController.isConnected) {\n            const typeaheadMatches = this.getTypeaheadMatches();\n            if (typeaheadMatches.length) {\n                const selectedIndex = this.options.indexOf(typeaheadMatches[0]);\n                if (selectedIndex > -1) {\n                    this.selectedIndex = selectedIndex;\n                }\n            }\n            this.typeaheadExpired = false;\n        }\n    }\n}\n/**\n * A static filter to include only selectable options.\n *\n * @param n - element to filter\n * @public\n */\nListbox.slottedOptionFilter = (n) => isListboxOption(n) && !n.disabled && !n.hidden;\n/**\n * Typeahead timeout in milliseconds.\n *\n * @internal\n */\nListbox.TYPE_AHEAD_TIMEOUT_MS = 1000;\n__decorate([\n    attr({ mode: \"boolean\" })\n], Listbox.prototype, \"disabled\", void 0);\n__decorate([\n    attr({ mode: \"boolean\" })\n], Listbox.prototype, \"multiple\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"selectedIndex\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"selectedOptions\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"slottedOptions\", void 0);\n__decorate([\n    observable\n], Listbox.prototype, \"typeaheadBuffer\", void 0);\n/**\n * Includes ARIA states and properties relating to the ARIA listbox role\n *\n * @public\n */\nexport class DelegatesARIAListbox {\n}\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaActiveDescendant\", void 0);\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaDisabled\", void 0);\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaExpanded\", void 0);\n__decorate([\n    observable\n], DelegatesARIAListbox.prototype, \"ariaMultiSelectable\", void 0);\napplyMixins(DelegatesARIAListbox, ARIAGlobalStatesAndProperties);\napplyMixins(Listbox, DelegatesARIAListbox);\n"]},"metadata":{},"sourceType":"module"}