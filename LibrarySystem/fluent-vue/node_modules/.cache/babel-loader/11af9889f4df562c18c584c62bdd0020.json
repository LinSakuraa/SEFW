{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { DOM, observable } from \"@microsoft/fast-element\";\nimport { isHTMLElement, keyArrowDown, keyArrowUp, keyEnd, keyHome } from \"@microsoft/fast-web-utilities\";\nimport { MenuItem, MenuItemRole, roleForMenuItem } from \"../menu-item/index\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A Menu Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#menu | ARIA menu }.\n *\n * @public\n */\n\nexport class Menu extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    this.expandedItem = null;\n    /**\n     * The index of the focusable element in the items array\n     * defaults to -1\n     */\n\n    this.focusIndex = -1;\n    /**\n     * @internal\n     */\n\n    this.isNestedMenu = () => {\n      return this.parentElement !== null && isHTMLElement(this.parentElement) && this.parentElement.getAttribute(\"role\") === \"menuitem\";\n    };\n    /**\n     * if focus is moving out of the menu, reset to a stable initial state\n     * @internal\n     */\n\n\n    this.handleFocusOut = e => {\n      if (!this.contains(e.relatedTarget) && this.menuItems !== undefined) {\n        this.collapseExpandedItem(); // find our first focusable element\n\n        const focusIndex = this.menuItems.findIndex(this.isFocusableElement); // set the current focus index's tabindex to -1\n\n        this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\"); // set the first focusable element tabindex to 0\n\n        this.menuItems[focusIndex].setAttribute(\"tabindex\", \"0\"); // set the focus index\n\n        this.focusIndex = focusIndex;\n      }\n    };\n\n    this.handleItemFocus = e => {\n      const targetItem = e.target;\n\n      if (this.menuItems !== undefined && targetItem !== this.menuItems[this.focusIndex]) {\n        this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n        this.focusIndex = this.menuItems.indexOf(targetItem);\n        targetItem.setAttribute(\"tabindex\", \"0\");\n      }\n    };\n\n    this.handleExpandedChanged = e => {\n      if (e.defaultPrevented || e.target === null || this.menuItems === undefined || this.menuItems.indexOf(e.target) < 0) {\n        return;\n      }\n\n      e.preventDefault();\n      const changedItem = e.target; // closing an expanded item without opening another\n\n      if (this.expandedItem !== null && changedItem === this.expandedItem && changedItem.expanded === false) {\n        this.expandedItem = null;\n        return;\n      }\n\n      if (changedItem.expanded) {\n        if (this.expandedItem !== null && this.expandedItem !== changedItem) {\n          this.expandedItem.expanded = false;\n        }\n\n        this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n        this.expandedItem = changedItem;\n        this.focusIndex = this.menuItems.indexOf(changedItem);\n        changedItem.setAttribute(\"tabindex\", \"0\");\n      }\n    };\n\n    this.removeItemListeners = () => {\n      if (this.menuItems !== undefined) {\n        this.menuItems.forEach(item => {\n          item.removeEventListener(\"expanded-change\", this.handleExpandedChanged);\n          item.removeEventListener(\"focus\", this.handleItemFocus);\n        });\n      }\n    };\n\n    this.setItems = () => {\n      const newItems = this.domChildren();\n      this.removeItemListeners();\n      this.menuItems = newItems;\n      const menuItems = this.menuItems.filter(this.isMenuItemElement); // if our focus index is not -1 we have items\n\n      if (menuItems.length) {\n        this.focusIndex = 0;\n      }\n\n      function elementIndent(el) {\n        const role = el.getAttribute(\"role\");\n        const startSlot = el.querySelector(\"[slot=start]\");\n\n        if (role !== MenuItemRole.menuitem && startSlot === null) {\n          return 1;\n        } else if (role === MenuItemRole.menuitem && startSlot !== null) {\n          return 1;\n        } else if (role !== MenuItemRole.menuitem && startSlot !== null) {\n          return 2;\n        } else {\n          return 0;\n        }\n      }\n\n      const indent = menuItems.reduce((accum, current) => {\n        const elementValue = elementIndent(current);\n        return accum > elementValue ? accum : elementValue;\n      }, 0);\n      menuItems.forEach((item, index) => {\n        item.setAttribute(\"tabindex\", index === 0 ? \"0\" : \"-1\");\n        item.addEventListener(\"expanded-change\", this.handleExpandedChanged);\n        item.addEventListener(\"focus\", this.handleItemFocus);\n\n        if (item instanceof MenuItem) {\n          item.startColumnCount = indent;\n        }\n      });\n    };\n    /**\n     * handle change from child element\n     */\n\n\n    this.changeHandler = e => {\n      if (this.menuItems === undefined) {\n        return;\n      }\n\n      const changedMenuItem = e.target;\n      const changeItemIndex = this.menuItems.indexOf(changedMenuItem);\n\n      if (changeItemIndex === -1) {\n        return;\n      }\n\n      if (changedMenuItem.role === \"menuitemradio\" && changedMenuItem.checked === true) {\n        for (let i = changeItemIndex - 1; i >= 0; --i) {\n          const item = this.menuItems[i];\n          const role = item.getAttribute(\"role\");\n\n          if (role === MenuItemRole.menuitemradio) {\n            item.checked = false;\n          }\n\n          if (role === \"separator\") {\n            break;\n          }\n        }\n\n        const maxIndex = this.menuItems.length - 1;\n\n        for (let i = changeItemIndex + 1; i <= maxIndex; ++i) {\n          const item = this.menuItems[i];\n          const role = item.getAttribute(\"role\");\n\n          if (role === MenuItemRole.menuitemradio) {\n            item.checked = false;\n          }\n\n          if (role === \"separator\") {\n            break;\n          }\n        }\n      }\n    };\n    /**\n     * check if the item is a menu item\n     */\n\n\n    this.isMenuItemElement = el => {\n      return isHTMLElement(el) && Menu.focusableElementRoles.hasOwnProperty(el.getAttribute(\"role\"));\n    };\n    /**\n     * check if the item is focusable\n     */\n\n\n    this.isFocusableElement = el => {\n      return this.isMenuItemElement(el);\n    };\n  }\n\n  itemsChanged(oldValue, newValue) {\n    // only update children after the component is connected and\n    // the setItems has run on connectedCallback\n    // (menuItems is undefined until then)\n    if (this.$fastController.isConnected && this.menuItems !== undefined) {\n      this.setItems();\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    DOM.queueUpdate(() => {\n      // wait until children have had a chance to\n      // connect before setting/checking their props/attributes\n      this.setItems();\n    });\n    this.addEventListener(\"change\", this.changeHandler);\n  }\n  /**\n   * @internal\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeItemListeners();\n    this.menuItems = undefined;\n    this.removeEventListener(\"change\", this.changeHandler);\n  }\n  /**\n   * Focuses the first item in the menu.\n   *\n   * @public\n   */\n\n\n  focus() {\n    this.setFocus(0, 1);\n  }\n  /**\n   * Collapses any expanded menu items.\n   *\n   * @public\n   */\n\n\n  collapseExpandedItem() {\n    if (this.expandedItem !== null) {\n      this.expandedItem.expanded = false;\n      this.expandedItem = null;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  handleMenuKeyDown(e) {\n    if (e.defaultPrevented || this.menuItems === undefined) {\n      return;\n    }\n\n    switch (e.key) {\n      case keyArrowDown:\n        // go forward one index\n        this.setFocus(this.focusIndex + 1, 1);\n        return;\n\n      case keyArrowUp:\n        // go back one index\n        this.setFocus(this.focusIndex - 1, -1);\n        return;\n\n      case keyEnd:\n        // set focus on last item\n        this.setFocus(this.menuItems.length - 1, -1);\n        return;\n\n      case keyHome:\n        // set focus on first item\n        this.setFocus(0, 1);\n        return;\n\n      default:\n        // if we are not handling the event, do not prevent default\n        return true;\n    }\n  }\n  /**\n   * get an array of valid DOM children\n   */\n\n\n  domChildren() {\n    return Array.from(this.children);\n  }\n\n  setFocus(focusIndex, adjustment) {\n    if (this.menuItems === undefined) {\n      return;\n    }\n\n    while (focusIndex >= 0 && focusIndex < this.menuItems.length) {\n      const child = this.menuItems[focusIndex];\n\n      if (this.isFocusableElement(child)) {\n        // change the previous index to -1\n        if (this.focusIndex > -1 && this.menuItems.length >= this.focusIndex - 1) {\n          this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n        } // update the focus index\n\n\n        this.focusIndex = focusIndex; // update the tabindex of next focusable element\n\n        child.setAttribute(\"tabindex\", \"0\"); // focus the element\n\n        child.focus();\n        break;\n      }\n\n      focusIndex += adjustment;\n    }\n  }\n\n}\nMenu.focusableElementRoles = roleForMenuItem;\n\n__decorate([observable], Menu.prototype, \"items\", void 0);","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/menu/menu.js"],"names":["__decorate","DOM","observable","isHTMLElement","keyArrowDown","keyArrowUp","keyEnd","keyHome","MenuItem","MenuItemRole","roleForMenuItem","FoundationElement","Menu","constructor","arguments","expandedItem","focusIndex","isNestedMenu","parentElement","getAttribute","handleFocusOut","e","contains","relatedTarget","menuItems","undefined","collapseExpandedItem","findIndex","isFocusableElement","setAttribute","handleItemFocus","targetItem","target","indexOf","handleExpandedChanged","defaultPrevented","preventDefault","changedItem","expanded","removeItemListeners","forEach","item","removeEventListener","setItems","newItems","domChildren","filter","isMenuItemElement","length","elementIndent","el","role","startSlot","querySelector","menuitem","indent","reduce","accum","current","elementValue","index","addEventListener","startColumnCount","changeHandler","changedMenuItem","changeItemIndex","checked","i","menuitemradio","maxIndex","focusableElementRoles","hasOwnProperty","itemsChanged","oldValue","newValue","$fastController","isConnected","connectedCallback","queueUpdate","disconnectedCallback","focus","setFocus","handleMenuKeyDown","key","Array","from","children","adjustment","child","prototype"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,GAAT,EAAcC,UAAd,QAAgC,yBAAhC;AACA,SAASC,aAAT,EAAwBC,YAAxB,EAAsCC,UAAtC,EAAkDC,MAAlD,EAA0DC,OAA1D,QAA0E,+BAA1E;AACA,SAASC,QAAT,EAAmBC,YAAnB,EAAiCC,eAAjC,QAAyD,oBAAzD;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,IAAN,SAAmBD,iBAAnB,CAAqC;AACxCE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGC,SAAT;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,UAAL,GAAkB,CAAC,CAAnB;AACA;AACR;AACA;;AACQ,SAAKC,YAAL,GAAoB,MAAM;AACtB,aAAQ,KAAKC,aAAL,KAAuB,IAAvB,IACJf,aAAa,CAAC,KAAKe,aAAN,CADT,IAEJ,KAAKA,aAAL,CAAmBC,YAAnB,CAAgC,MAAhC,MAA4C,UAFhD;AAGH,KAJD;AAKA;AACR;AACA;AACA;;;AACQ,SAAKC,cAAL,GAAuBC,CAAD,IAAO;AACzB,UAAI,CAAC,KAAKC,QAAL,CAAcD,CAAC,CAACE,aAAhB,CAAD,IAAmC,KAAKC,SAAL,KAAmBC,SAA1D,EAAqE;AACjE,aAAKC,oBAAL,GADiE,CAEjE;;AACA,cAAMV,UAAU,GAAG,KAAKQ,SAAL,CAAeG,SAAf,CAAyB,KAAKC,kBAA9B,CAAnB,CAHiE,CAIjE;;AACA,aAAKJ,SAAL,CAAe,KAAKR,UAApB,EAAgCa,YAAhC,CAA6C,UAA7C,EAAyD,IAAzD,EALiE,CAMjE;;AACA,aAAKL,SAAL,CAAeR,UAAf,EAA2Ba,YAA3B,CAAwC,UAAxC,EAAoD,GAApD,EAPiE,CAQjE;;AACA,aAAKb,UAAL,GAAkBA,UAAlB;AACH;AACJ,KAZD;;AAaA,SAAKc,eAAL,GAAwBT,CAAD,IAAO;AAC1B,YAAMU,UAAU,GAAGV,CAAC,CAACW,MAArB;;AACA,UAAI,KAAKR,SAAL,KAAmBC,SAAnB,IACAM,UAAU,KAAK,KAAKP,SAAL,CAAe,KAAKR,UAApB,CADnB,EACoD;AAChD,aAAKQ,SAAL,CAAe,KAAKR,UAApB,EAAgCa,YAAhC,CAA6C,UAA7C,EAAyD,IAAzD;AACA,aAAKb,UAAL,GAAkB,KAAKQ,SAAL,CAAeS,OAAf,CAAuBF,UAAvB,CAAlB;AACAA,QAAAA,UAAU,CAACF,YAAX,CAAwB,UAAxB,EAAoC,GAApC;AACH;AACJ,KARD;;AASA,SAAKK,qBAAL,GAA8Bb,CAAD,IAAO;AAChC,UAAIA,CAAC,CAACc,gBAAF,IACAd,CAAC,CAACW,MAAF,KAAa,IADb,IAEA,KAAKR,SAAL,KAAmBC,SAFnB,IAGA,KAAKD,SAAL,CAAeS,OAAf,CAAuBZ,CAAC,CAACW,MAAzB,IAAmC,CAHvC,EAG0C;AACtC;AACH;;AACDX,MAAAA,CAAC,CAACe,cAAF;AACA,YAAMC,WAAW,GAAGhB,CAAC,CAACW,MAAtB,CARgC,CAShC;;AACA,UAAI,KAAKjB,YAAL,KAAsB,IAAtB,IACAsB,WAAW,KAAK,KAAKtB,YADrB,IAEAsB,WAAW,CAACC,QAAZ,KAAyB,KAF7B,EAEoC;AAChC,aAAKvB,YAAL,GAAoB,IAApB;AACA;AACH;;AACD,UAAIsB,WAAW,CAACC,QAAhB,EAA0B;AACtB,YAAI,KAAKvB,YAAL,KAAsB,IAAtB,IAA8B,KAAKA,YAAL,KAAsBsB,WAAxD,EAAqE;AACjE,eAAKtB,YAAL,CAAkBuB,QAAlB,GAA6B,KAA7B;AACH;;AACD,aAAKd,SAAL,CAAe,KAAKR,UAApB,EAAgCa,YAAhC,CAA6C,UAA7C,EAAyD,IAAzD;AACA,aAAKd,YAAL,GAAoBsB,WAApB;AACA,aAAKrB,UAAL,GAAkB,KAAKQ,SAAL,CAAeS,OAAf,CAAuBI,WAAvB,CAAlB;AACAA,QAAAA,WAAW,CAACR,YAAZ,CAAyB,UAAzB,EAAqC,GAArC;AACH;AACJ,KAzBD;;AA0BA,SAAKU,mBAAL,GAA2B,MAAM;AAC7B,UAAI,KAAKf,SAAL,KAAmBC,SAAvB,EAAkC;AAC9B,aAAKD,SAAL,CAAegB,OAAf,CAAwBC,IAAD,IAAU;AAC7BA,UAAAA,IAAI,CAACC,mBAAL,CAAyB,iBAAzB,EAA4C,KAAKR,qBAAjD;AACAO,UAAAA,IAAI,CAACC,mBAAL,CAAyB,OAAzB,EAAkC,KAAKZ,eAAvC;AACH,SAHD;AAIH;AACJ,KAPD;;AAQA,SAAKa,QAAL,GAAgB,MAAM;AAClB,YAAMC,QAAQ,GAAG,KAAKC,WAAL,EAAjB;AACA,WAAKN,mBAAL;AACA,WAAKf,SAAL,GAAiBoB,QAAjB;AACA,YAAMpB,SAAS,GAAG,KAAKA,SAAL,CAAesB,MAAf,CAAsB,KAAKC,iBAA3B,CAAlB,CAJkB,CAKlB;;AACA,UAAIvB,SAAS,CAACwB,MAAd,EAAsB;AAClB,aAAKhC,UAAL,GAAkB,CAAlB;AACH;;AACD,eAASiC,aAAT,CAAuBC,EAAvB,EAA2B;AACvB,cAAMC,IAAI,GAAGD,EAAE,CAAC/B,YAAH,CAAgB,MAAhB,CAAb;AACA,cAAMiC,SAAS,GAAGF,EAAE,CAACG,aAAH,CAAiB,cAAjB,CAAlB;;AACA,YAAIF,IAAI,KAAK1C,YAAY,CAAC6C,QAAtB,IAAkCF,SAAS,KAAK,IAApD,EAA0D;AACtD,iBAAO,CAAP;AACH,SAFD,MAGK,IAAID,IAAI,KAAK1C,YAAY,CAAC6C,QAAtB,IAAkCF,SAAS,KAAK,IAApD,EAA0D;AAC3D,iBAAO,CAAP;AACH,SAFI,MAGA,IAAID,IAAI,KAAK1C,YAAY,CAAC6C,QAAtB,IAAkCF,SAAS,KAAK,IAApD,EAA0D;AAC3D,iBAAO,CAAP;AACH,SAFI,MAGA;AACD,iBAAO,CAAP;AACH;AACJ;;AACD,YAAMG,MAAM,GAAG/B,SAAS,CAACgC,MAAV,CAAiB,CAACC,KAAD,EAAQC,OAAR,KAAoB;AAChD,cAAMC,YAAY,GAAGV,aAAa,CAACS,OAAD,CAAlC;AACA,eAAOD,KAAK,GAAGE,YAAR,GAAuBF,KAAvB,GAA+BE,YAAtC;AACH,OAHc,EAGZ,CAHY,CAAf;AAIAnC,MAAAA,SAAS,CAACgB,OAAV,CAAkB,CAACC,IAAD,EAAOmB,KAAP,KAAiB;AAC/BnB,QAAAA,IAAI,CAACZ,YAAL,CAAkB,UAAlB,EAA8B+B,KAAK,KAAK,CAAV,GAAc,GAAd,GAAoB,IAAlD;AACAnB,QAAAA,IAAI,CAACoB,gBAAL,CAAsB,iBAAtB,EAAyC,KAAK3B,qBAA9C;AACAO,QAAAA,IAAI,CAACoB,gBAAL,CAAsB,OAAtB,EAA+B,KAAK/B,eAApC;;AACA,YAAIW,IAAI,YAAYjC,QAApB,EAA8B;AAC1BiC,UAAAA,IAAI,CAACqB,gBAAL,GAAwBP,MAAxB;AACH;AACJ,OAPD;AAQH,KArCD;AAsCA;AACR;AACA;;;AACQ,SAAKQ,aAAL,GAAsB1C,CAAD,IAAO;AACxB,UAAI,KAAKG,SAAL,KAAmBC,SAAvB,EAAkC;AAC9B;AACH;;AACD,YAAMuC,eAAe,GAAG3C,CAAC,CAACW,MAA1B;AACA,YAAMiC,eAAe,GAAG,KAAKzC,SAAL,CAAeS,OAAf,CAAuB+B,eAAvB,CAAxB;;AACA,UAAIC,eAAe,KAAK,CAAC,CAAzB,EAA4B;AACxB;AACH;;AACD,UAAID,eAAe,CAACb,IAAhB,KAAyB,eAAzB,IACAa,eAAe,CAACE,OAAhB,KAA4B,IADhC,EACsC;AAClC,aAAK,IAAIC,CAAC,GAAGF,eAAe,GAAG,CAA/B,EAAkCE,CAAC,IAAI,CAAvC,EAA0C,EAAEA,CAA5C,EAA+C;AAC3C,gBAAM1B,IAAI,GAAG,KAAKjB,SAAL,CAAe2C,CAAf,CAAb;AACA,gBAAMhB,IAAI,GAAGV,IAAI,CAACtB,YAAL,CAAkB,MAAlB,CAAb;;AACA,cAAIgC,IAAI,KAAK1C,YAAY,CAAC2D,aAA1B,EAAyC;AACrC3B,YAAAA,IAAI,CAACyB,OAAL,GAAe,KAAf;AACH;;AACD,cAAIf,IAAI,KAAK,WAAb,EAA0B;AACtB;AACH;AACJ;;AACD,cAAMkB,QAAQ,GAAG,KAAK7C,SAAL,CAAewB,MAAf,GAAwB,CAAzC;;AACA,aAAK,IAAImB,CAAC,GAAGF,eAAe,GAAG,CAA/B,EAAkCE,CAAC,IAAIE,QAAvC,EAAiD,EAAEF,CAAnD,EAAsD;AAClD,gBAAM1B,IAAI,GAAG,KAAKjB,SAAL,CAAe2C,CAAf,CAAb;AACA,gBAAMhB,IAAI,GAAGV,IAAI,CAACtB,YAAL,CAAkB,MAAlB,CAAb;;AACA,cAAIgC,IAAI,KAAK1C,YAAY,CAAC2D,aAA1B,EAAyC;AACrC3B,YAAAA,IAAI,CAACyB,OAAL,GAAe,KAAf;AACH;;AACD,cAAIf,IAAI,KAAK,WAAb,EAA0B;AACtB;AACH;AACJ;AACJ;AACJ,KAjCD;AAkCA;AACR;AACA;;;AACQ,SAAKJ,iBAAL,GAA0BG,EAAD,IAAQ;AAC7B,aAAQ/C,aAAa,CAAC+C,EAAD,CAAb,IACJtC,IAAI,CAAC0D,qBAAL,CAA2BC,cAA3B,CAA0CrB,EAAE,CAAC/B,YAAH,CAAgB,MAAhB,CAA1C,CADJ;AAEH,KAHD;AAIA;AACR;AACA;;;AACQ,SAAKS,kBAAL,GAA2BsB,EAAD,IAAQ;AAC9B,aAAO,KAAKH,iBAAL,CAAuBG,EAAvB,CAAP;AACH,KAFD;AAGH;;AACDsB,EAAAA,YAAY,CAACC,QAAD,EAAWC,QAAX,EAAqB;AAC7B;AACA;AACA;AACA,QAAI,KAAKC,eAAL,CAAqBC,WAArB,IAAoC,KAAKpD,SAAL,KAAmBC,SAA3D,EAAsE;AAClE,WAAKkB,QAAL;AACH;AACJ;AACD;AACJ;AACA;;;AACIkC,EAAAA,iBAAiB,GAAG;AAChB,UAAMA,iBAAN;AACA5E,IAAAA,GAAG,CAAC6E,WAAJ,CAAgB,MAAM;AAClB;AACA;AACA,WAAKnC,QAAL;AACH,KAJD;AAKA,SAAKkB,gBAAL,CAAsB,QAAtB,EAAgC,KAAKE,aAArC;AACH;AACD;AACJ;AACA;;;AACIgB,EAAAA,oBAAoB,GAAG;AACnB,UAAMA,oBAAN;AACA,SAAKxC,mBAAL;AACA,SAAKf,SAAL,GAAiBC,SAAjB;AACA,SAAKiB,mBAAL,CAAyB,QAAzB,EAAmC,KAAKqB,aAAxC;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIiB,EAAAA,KAAK,GAAG;AACJ,SAAKC,QAAL,CAAc,CAAd,EAAiB,CAAjB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIvD,EAAAA,oBAAoB,GAAG;AACnB,QAAI,KAAKX,YAAL,KAAsB,IAA1B,EAAgC;AAC5B,WAAKA,YAAL,CAAkBuB,QAAlB,GAA6B,KAA7B;AACA,WAAKvB,YAAL,GAAoB,IAApB;AACH;AACJ;AACD;AACJ;AACA;;;AACImE,EAAAA,iBAAiB,CAAC7D,CAAD,EAAI;AACjB,QAAIA,CAAC,CAACc,gBAAF,IAAsB,KAAKX,SAAL,KAAmBC,SAA7C,EAAwD;AACpD;AACH;;AACD,YAAQJ,CAAC,CAAC8D,GAAV;AACI,WAAK/E,YAAL;AACI;AACA,aAAK6E,QAAL,CAAc,KAAKjE,UAAL,GAAkB,CAAhC,EAAmC,CAAnC;AACA;;AACJ,WAAKX,UAAL;AACI;AACA,aAAK4E,QAAL,CAAc,KAAKjE,UAAL,GAAkB,CAAhC,EAAmC,CAAC,CAApC;AACA;;AACJ,WAAKV,MAAL;AACI;AACA,aAAK2E,QAAL,CAAc,KAAKzD,SAAL,CAAewB,MAAf,GAAwB,CAAtC,EAAyC,CAAC,CAA1C;AACA;;AACJ,WAAKzC,OAAL;AACI;AACA,aAAK0E,QAAL,CAAc,CAAd,EAAiB,CAAjB;AACA;;AACJ;AACI;AACA,eAAO,IAAP;AAnBR;AAqBH;AACD;AACJ;AACA;;;AACIpC,EAAAA,WAAW,GAAG;AACV,WAAOuC,KAAK,CAACC,IAAN,CAAW,KAAKC,QAAhB,CAAP;AACH;;AACDL,EAAAA,QAAQ,CAACjE,UAAD,EAAauE,UAAb,EAAyB;AAC7B,QAAI,KAAK/D,SAAL,KAAmBC,SAAvB,EAAkC;AAC9B;AACH;;AACD,WAAOT,UAAU,IAAI,CAAd,IAAmBA,UAAU,GAAG,KAAKQ,SAAL,CAAewB,MAAtD,EAA8D;AAC1D,YAAMwC,KAAK,GAAG,KAAKhE,SAAL,CAAeR,UAAf,CAAd;;AACA,UAAI,KAAKY,kBAAL,CAAwB4D,KAAxB,CAAJ,EAAoC;AAChC;AACA,YAAI,KAAKxE,UAAL,GAAkB,CAAC,CAAnB,IACA,KAAKQ,SAAL,CAAewB,MAAf,IAAyB,KAAKhC,UAAL,GAAkB,CAD/C,EACkD;AAC9C,eAAKQ,SAAL,CAAe,KAAKR,UAApB,EAAgCa,YAAhC,CAA6C,UAA7C,EAAyD,IAAzD;AACH,SAL+B,CAMhC;;;AACA,aAAKb,UAAL,GAAkBA,UAAlB,CAPgC,CAQhC;;AACAwE,QAAAA,KAAK,CAAC3D,YAAN,CAAmB,UAAnB,EAA+B,GAA/B,EATgC,CAUhC;;AACA2D,QAAAA,KAAK,CAACR,KAAN;AACA;AACH;;AACDhE,MAAAA,UAAU,IAAIuE,UAAd;AACH;AACJ;;AA/QuC;AAiR5C3E,IAAI,CAAC0D,qBAAL,GAA6B5D,eAA7B;;AACAV,UAAU,CAAC,CACPE,UADO,CAAD,EAEPU,IAAI,CAAC6E,SAFE,EAES,OAFT,EAEkB,KAAK,CAFvB,CAAV","sourcesContent":["import { __decorate } from \"tslib\";\nimport { DOM, observable } from \"@microsoft/fast-element\";\nimport { isHTMLElement, keyArrowDown, keyArrowUp, keyEnd, keyHome, } from \"@microsoft/fast-web-utilities\";\nimport { MenuItem, MenuItemRole, roleForMenuItem, } from \"../menu-item/index\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A Menu Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#menu | ARIA menu }.\n *\n * @public\n */\nexport class Menu extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        this.expandedItem = null;\n        /**\n         * The index of the focusable element in the items array\n         * defaults to -1\n         */\n        this.focusIndex = -1;\n        /**\n         * @internal\n         */\n        this.isNestedMenu = () => {\n            return (this.parentElement !== null &&\n                isHTMLElement(this.parentElement) &&\n                this.parentElement.getAttribute(\"role\") === \"menuitem\");\n        };\n        /**\n         * if focus is moving out of the menu, reset to a stable initial state\n         * @internal\n         */\n        this.handleFocusOut = (e) => {\n            if (!this.contains(e.relatedTarget) && this.menuItems !== undefined) {\n                this.collapseExpandedItem();\n                // find our first focusable element\n                const focusIndex = this.menuItems.findIndex(this.isFocusableElement);\n                // set the current focus index's tabindex to -1\n                this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                // set the first focusable element tabindex to 0\n                this.menuItems[focusIndex].setAttribute(\"tabindex\", \"0\");\n                // set the focus index\n                this.focusIndex = focusIndex;\n            }\n        };\n        this.handleItemFocus = (e) => {\n            const targetItem = e.target;\n            if (this.menuItems !== undefined &&\n                targetItem !== this.menuItems[this.focusIndex]) {\n                this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                this.focusIndex = this.menuItems.indexOf(targetItem);\n                targetItem.setAttribute(\"tabindex\", \"0\");\n            }\n        };\n        this.handleExpandedChanged = (e) => {\n            if (e.defaultPrevented ||\n                e.target === null ||\n                this.menuItems === undefined ||\n                this.menuItems.indexOf(e.target) < 0) {\n                return;\n            }\n            e.preventDefault();\n            const changedItem = e.target;\n            // closing an expanded item without opening another\n            if (this.expandedItem !== null &&\n                changedItem === this.expandedItem &&\n                changedItem.expanded === false) {\n                this.expandedItem = null;\n                return;\n            }\n            if (changedItem.expanded) {\n                if (this.expandedItem !== null && this.expandedItem !== changedItem) {\n                    this.expandedItem.expanded = false;\n                }\n                this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                this.expandedItem = changedItem;\n                this.focusIndex = this.menuItems.indexOf(changedItem);\n                changedItem.setAttribute(\"tabindex\", \"0\");\n            }\n        };\n        this.removeItemListeners = () => {\n            if (this.menuItems !== undefined) {\n                this.menuItems.forEach((item) => {\n                    item.removeEventListener(\"expanded-change\", this.handleExpandedChanged);\n                    item.removeEventListener(\"focus\", this.handleItemFocus);\n                });\n            }\n        };\n        this.setItems = () => {\n            const newItems = this.domChildren();\n            this.removeItemListeners();\n            this.menuItems = newItems;\n            const menuItems = this.menuItems.filter(this.isMenuItemElement);\n            // if our focus index is not -1 we have items\n            if (menuItems.length) {\n                this.focusIndex = 0;\n            }\n            function elementIndent(el) {\n                const role = el.getAttribute(\"role\");\n                const startSlot = el.querySelector(\"[slot=start]\");\n                if (role !== MenuItemRole.menuitem && startSlot === null) {\n                    return 1;\n                }\n                else if (role === MenuItemRole.menuitem && startSlot !== null) {\n                    return 1;\n                }\n                else if (role !== MenuItemRole.menuitem && startSlot !== null) {\n                    return 2;\n                }\n                else {\n                    return 0;\n                }\n            }\n            const indent = menuItems.reduce((accum, current) => {\n                const elementValue = elementIndent(current);\n                return accum > elementValue ? accum : elementValue;\n            }, 0);\n            menuItems.forEach((item, index) => {\n                item.setAttribute(\"tabindex\", index === 0 ? \"0\" : \"-1\");\n                item.addEventListener(\"expanded-change\", this.handleExpandedChanged);\n                item.addEventListener(\"focus\", this.handleItemFocus);\n                if (item instanceof MenuItem) {\n                    item.startColumnCount = indent;\n                }\n            });\n        };\n        /**\n         * handle change from child element\n         */\n        this.changeHandler = (e) => {\n            if (this.menuItems === undefined) {\n                return;\n            }\n            const changedMenuItem = e.target;\n            const changeItemIndex = this.menuItems.indexOf(changedMenuItem);\n            if (changeItemIndex === -1) {\n                return;\n            }\n            if (changedMenuItem.role === \"menuitemradio\" &&\n                changedMenuItem.checked === true) {\n                for (let i = changeItemIndex - 1; i >= 0; --i) {\n                    const item = this.menuItems[i];\n                    const role = item.getAttribute(\"role\");\n                    if (role === MenuItemRole.menuitemradio) {\n                        item.checked = false;\n                    }\n                    if (role === \"separator\") {\n                        break;\n                    }\n                }\n                const maxIndex = this.menuItems.length - 1;\n                for (let i = changeItemIndex + 1; i <= maxIndex; ++i) {\n                    const item = this.menuItems[i];\n                    const role = item.getAttribute(\"role\");\n                    if (role === MenuItemRole.menuitemradio) {\n                        item.checked = false;\n                    }\n                    if (role === \"separator\") {\n                        break;\n                    }\n                }\n            }\n        };\n        /**\n         * check if the item is a menu item\n         */\n        this.isMenuItemElement = (el) => {\n            return (isHTMLElement(el) &&\n                Menu.focusableElementRoles.hasOwnProperty(el.getAttribute(\"role\")));\n        };\n        /**\n         * check if the item is focusable\n         */\n        this.isFocusableElement = (el) => {\n            return this.isMenuItemElement(el);\n        };\n    }\n    itemsChanged(oldValue, newValue) {\n        // only update children after the component is connected and\n        // the setItems has run on connectedCallback\n        // (menuItems is undefined until then)\n        if (this.$fastController.isConnected && this.menuItems !== undefined) {\n            this.setItems();\n        }\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        DOM.queueUpdate(() => {\n            // wait until children have had a chance to\n            // connect before setting/checking their props/attributes\n            this.setItems();\n        });\n        this.addEventListener(\"change\", this.changeHandler);\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.removeItemListeners();\n        this.menuItems = undefined;\n        this.removeEventListener(\"change\", this.changeHandler);\n    }\n    /**\n     * Focuses the first item in the menu.\n     *\n     * @public\n     */\n    focus() {\n        this.setFocus(0, 1);\n    }\n    /**\n     * Collapses any expanded menu items.\n     *\n     * @public\n     */\n    collapseExpandedItem() {\n        if (this.expandedItem !== null) {\n            this.expandedItem.expanded = false;\n            this.expandedItem = null;\n        }\n    }\n    /**\n     * @internal\n     */\n    handleMenuKeyDown(e) {\n        if (e.defaultPrevented || this.menuItems === undefined) {\n            return;\n        }\n        switch (e.key) {\n            case keyArrowDown:\n                // go forward one index\n                this.setFocus(this.focusIndex + 1, 1);\n                return;\n            case keyArrowUp:\n                // go back one index\n                this.setFocus(this.focusIndex - 1, -1);\n                return;\n            case keyEnd:\n                // set focus on last item\n                this.setFocus(this.menuItems.length - 1, -1);\n                return;\n            case keyHome:\n                // set focus on first item\n                this.setFocus(0, 1);\n                return;\n            default:\n                // if we are not handling the event, do not prevent default\n                return true;\n        }\n    }\n    /**\n     * get an array of valid DOM children\n     */\n    domChildren() {\n        return Array.from(this.children);\n    }\n    setFocus(focusIndex, adjustment) {\n        if (this.menuItems === undefined) {\n            return;\n        }\n        while (focusIndex >= 0 && focusIndex < this.menuItems.length) {\n            const child = this.menuItems[focusIndex];\n            if (this.isFocusableElement(child)) {\n                // change the previous index to -1\n                if (this.focusIndex > -1 &&\n                    this.menuItems.length >= this.focusIndex - 1) {\n                    this.menuItems[this.focusIndex].setAttribute(\"tabindex\", \"-1\");\n                }\n                // update the focus index\n                this.focusIndex = focusIndex;\n                // update the tabindex of next focusable element\n                child.setAttribute(\"tabindex\", \"0\");\n                // focus the element\n                child.focus();\n                break;\n            }\n            focusIndex += adjustment;\n        }\n    }\n}\nMenu.focusableElementRoles = roleForMenuItem;\n__decorate([\n    observable\n], Menu.prototype, \"items\", void 0);\n"]},"metadata":{},"sourceType":"module"}