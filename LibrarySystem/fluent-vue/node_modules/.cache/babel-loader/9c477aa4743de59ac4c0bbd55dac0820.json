{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, DOM, observable, RepeatDirective } from \"@microsoft/fast-element\";\nimport { eventFocus, eventFocusOut, eventKeyDown, keyArrowDown, keyArrowUp, keyEnd, keyHome, keyPageDown, keyPageUp } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element\";\nimport { DataGridRowTypes, GenerateHeaderOptions } from \"./data-grid.options\";\nexport { DataGridRowTypes, GenerateHeaderOptions };\n/**\n * A Data Grid Custom HTML Element.\n *\n * @public\n */\n\nexport class DataGrid extends FoundationElement {\n  constructor() {\n    super();\n    /**\n     * When true the component will not add itself to the tab queue.\n     * Default is false.\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: no-tabbing\n     */\n\n    this.noTabbing = false;\n    /**\n     *  Whether the grid should automatically generate a header row and its type\n     *\n     * @public\n     * @remarks\n     * HTML Attribute: generate-header\n     */\n\n    this.generateHeader = GenerateHeaderOptions.default;\n    /**\n     * The data being displayed in the grid\n     *\n     * @public\n     */\n\n    this.rowsData = [];\n    /**\n     * The column definitions of the grid\n     *\n     * @public\n     */\n\n    this.columnDefinitions = null;\n    /**\n     * The index of the row that will receive focus the next time the\n     * grid is focused. This value changes as focus moves to different\n     * rows within the grid.  Changing this value when focus is already\n     * within the grid moves focus to the specified row.\n     *\n     * @public\n     */\n\n    this.focusRowIndex = 0;\n    /**\n     * The index of the column that will receive focus the next time the\n     * grid is focused. This value changes as focus moves to different rows\n     * within the grid.  Changing this value when focus is already within\n     * the grid moves focus to the specified column.\n     *\n     * @public\n     */\n\n    this.focusColumnIndex = 0;\n    this.rowsPlaceholder = null;\n    this.generatedHeader = null;\n    this.isUpdatingFocus = false;\n    this.pendingFocusUpdate = false;\n    this.rowindexUpdateQueued = false;\n    this.columnDefinitionsStale = true;\n    this.generatedGridTemplateColumns = \"\";\n\n    this.focusOnCell = (rowIndex, columnIndex, scrollIntoView) => {\n      if (this.rowElements.length === 0) {\n        this.focusRowIndex = 0;\n        this.focusColumnIndex = 0;\n        return;\n      }\n\n      const focusRowIndex = Math.max(0, Math.min(this.rowElements.length - 1, rowIndex));\n      const focusRow = this.rowElements[focusRowIndex];\n      const cells = focusRow.querySelectorAll('[role=\"cell\"], [role=\"gridcell\"], [role=\"columnheader\"], [role=\"rowheader\"]');\n      const focusColumnIndex = Math.max(0, Math.min(cells.length - 1, columnIndex));\n      const focusTarget = cells[focusColumnIndex];\n\n      if (scrollIntoView && this.scrollHeight !== this.clientHeight && (focusRowIndex < this.focusRowIndex && this.scrollTop > 0 || focusRowIndex > this.focusRowIndex && this.scrollTop < this.scrollHeight - this.clientHeight)) {\n        focusTarget.scrollIntoView({\n          block: \"center\",\n          inline: \"center\"\n        });\n      }\n\n      focusTarget.focus();\n    };\n\n    this.onChildListChange = (mutations,\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    observer) => {\n      if (mutations && mutations.length) {\n        mutations.forEach(mutation => {\n          mutation.addedNodes.forEach(newNode => {\n            if (newNode.nodeType === 1 && newNode.getAttribute(\"role\") === \"row\") {\n              newNode.columnDefinitions = this.columnDefinitions;\n            }\n          });\n        });\n        this.queueRowIndexUpdate();\n      }\n    };\n\n    this.queueRowIndexUpdate = () => {\n      if (!this.rowindexUpdateQueued) {\n        this.rowindexUpdateQueued = true;\n        DOM.queueUpdate(this.updateRowIndexes);\n      }\n    };\n\n    this.updateRowIndexes = () => {\n      let newGridTemplateColumns = this.gridTemplateColumns;\n\n      if (newGridTemplateColumns === undefined) {\n        // try to generate columns based on manual rows\n        if (this.generatedGridTemplateColumns === \"\" && this.rowElements.length > 0) {\n          const firstRow = this.rowElements[0];\n          this.generatedGridTemplateColumns = new Array(firstRow.cellElements.length).fill(\"1fr\").join(\" \");\n        }\n\n        newGridTemplateColumns = this.generatedGridTemplateColumns;\n      }\n\n      this.rowElements.forEach((element, index) => {\n        const thisRow = element;\n        thisRow.rowIndex = index;\n        thisRow.gridTemplateColumns = newGridTemplateColumns;\n\n        if (this.columnDefinitionsStale) {\n          thisRow.columnDefinitions = this.columnDefinitions;\n        }\n      });\n      this.rowindexUpdateQueued = false;\n      this.columnDefinitionsStale = false;\n    };\n  }\n  /**\n   *  generates a gridTemplateColumns based on columndata array\n   */\n\n\n  static generateTemplateColumns(columnDefinitions) {\n    let templateColumns = \"\";\n    columnDefinitions.forEach(column => {\n      templateColumns = `${templateColumns}${templateColumns === \"\" ? \"\" : \" \"}${\"1fr\"}`;\n    });\n    return templateColumns;\n  }\n\n  noTabbingChanged() {\n    if (this.$fastController.isConnected) {\n      if (this.noTabbing) {\n        this.setAttribute(\"tabIndex\", \"-1\");\n      } else {\n        this.setAttribute(\"tabIndex\", this.contains(document.activeElement) || this === document.activeElement ? \"-1\" : \"0\");\n      }\n    }\n  }\n\n  generateHeaderChanged() {\n    if (this.$fastController.isConnected) {\n      this.toggleGeneratedHeader();\n    }\n  }\n\n  gridTemplateColumnsChanged() {\n    if (this.$fastController.isConnected) {\n      this.updateRowIndexes();\n    }\n  }\n\n  rowsDataChanged() {\n    if (this.columnDefinitions === null && this.rowsData.length > 0) {\n      this.columnDefinitions = DataGrid.generateColumns(this.rowsData[0]);\n    }\n\n    if (this.$fastController.isConnected) {\n      this.toggleGeneratedHeader();\n    }\n  }\n\n  columnDefinitionsChanged() {\n    if (this.columnDefinitions === null) {\n      this.generatedGridTemplateColumns = \"\";\n      return;\n    }\n\n    this.generatedGridTemplateColumns = DataGrid.generateTemplateColumns(this.columnDefinitions);\n\n    if (this.$fastController.isConnected) {\n      this.columnDefinitionsStale = true;\n      this.queueRowIndexUpdate();\n    }\n  }\n\n  headerCellItemTemplateChanged() {\n    if (this.$fastController.isConnected) {\n      if (this.generatedHeader !== null) {\n        this.generatedHeader.headerCellItemTemplate = this.headerCellItemTemplate;\n      }\n    }\n  }\n\n  focusRowIndexChanged() {\n    if (this.$fastController.isConnected) {\n      this.queueFocusUpdate();\n    }\n  }\n\n  focusColumnIndexChanged() {\n    if (this.$fastController.isConnected) {\n      this.queueFocusUpdate();\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (this.rowItemTemplate === undefined) {\n      this.rowItemTemplate = this.defaultRowItemTemplate;\n    }\n\n    this.rowsPlaceholder = document.createComment(\"\");\n    this.appendChild(this.rowsPlaceholder);\n    this.toggleGeneratedHeader();\n    this.rowsRepeatBehavior = new RepeatDirective(x => x.rowsData, x => x.rowItemTemplate, {\n      positioning: true\n    }).createBehavior(this.rowsPlaceholder);\n    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n\n    this.$fastController.addBehaviors([this.rowsRepeatBehavior]);\n    this.addEventListener(\"row-focused\", this.handleRowFocus);\n    this.addEventListener(eventFocus, this.handleFocus);\n    this.addEventListener(eventKeyDown, this.handleKeydown);\n    this.addEventListener(eventFocusOut, this.handleFocusOut);\n    this.observer = new MutationObserver(this.onChildListChange); // only observe if nodes are added or removed\n\n    this.observer.observe(this, {\n      childList: true\n    });\n\n    if (this.noTabbing) {\n      this.setAttribute(\"tabindex\", \"-1\");\n    }\n\n    DOM.queueUpdate(this.queueRowIndexUpdate);\n  }\n  /**\n   * @internal\n   */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener(\"row-focused\", this.handleRowFocus);\n    this.removeEventListener(eventFocus, this.handleFocus);\n    this.removeEventListener(eventKeyDown, this.handleKeydown);\n    this.removeEventListener(eventFocusOut, this.handleFocusOut); // disconnect observer\n\n    this.observer.disconnect();\n    this.rowsPlaceholder = null;\n    this.generatedHeader = null;\n  }\n  /**\n   * @internal\n   */\n\n\n  handleRowFocus(e) {\n    this.isUpdatingFocus = true;\n    const focusRow = e.target;\n    this.focusRowIndex = this.rowElements.indexOf(focusRow);\n    this.focusColumnIndex = focusRow.focusColumnIndex;\n    this.setAttribute(\"tabIndex\", \"-1\");\n    this.isUpdatingFocus = false;\n  }\n  /**\n   * @internal\n   */\n\n\n  handleFocus(e) {\n    this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n  }\n  /**\n   * @internal\n   */\n\n\n  handleFocusOut(e) {\n    if (e.relatedTarget === null || !this.contains(e.relatedTarget)) {\n      this.setAttribute(\"tabIndex\", this.noTabbing ? \"-1\" : \"0\");\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  handleKeydown(e) {\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    let newFocusRowIndex;\n    const maxIndex = this.rowElements.length - 1;\n    const currentGridBottom = this.offsetHeight + this.scrollTop;\n    const lastRow = this.rowElements[maxIndex];\n\n    switch (e.key) {\n      case keyArrowUp:\n        e.preventDefault(); // focus up one row\n\n        this.focusOnCell(this.focusRowIndex - 1, this.focusColumnIndex, true);\n        break;\n\n      case keyArrowDown:\n        e.preventDefault(); // focus down one row\n\n        this.focusOnCell(this.focusRowIndex + 1, this.focusColumnIndex, true);\n        break;\n\n      case keyPageUp:\n        e.preventDefault();\n\n        if (this.rowElements.length === 0) {\n          this.focusOnCell(0, 0, false);\n          break;\n        }\n\n        if (this.focusRowIndex === 0) {\n          this.focusOnCell(0, this.focusColumnIndex, false);\n          return;\n        }\n\n        newFocusRowIndex = this.focusRowIndex - 1;\n\n        for (newFocusRowIndex; newFocusRowIndex >= 0; newFocusRowIndex--) {\n          const thisRow = this.rowElements[newFocusRowIndex];\n\n          if (thisRow.offsetTop < this.scrollTop) {\n            this.scrollTop = thisRow.offsetTop + thisRow.clientHeight - this.clientHeight;\n            break;\n          }\n        }\n\n        this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n        break;\n\n      case keyPageDown:\n        e.preventDefault();\n\n        if (this.rowElements.length === 0) {\n          this.focusOnCell(0, 0, false);\n          break;\n        } // focus down one \"page\"\n\n\n        if (this.focusRowIndex >= maxIndex || lastRow.offsetTop + lastRow.offsetHeight <= currentGridBottom) {\n          this.focusOnCell(maxIndex, this.focusColumnIndex, false);\n          return;\n        }\n\n        newFocusRowIndex = this.focusRowIndex + 1;\n\n        for (newFocusRowIndex; newFocusRowIndex <= maxIndex; newFocusRowIndex++) {\n          const thisRow = this.rowElements[newFocusRowIndex];\n\n          if (thisRow.offsetTop + thisRow.offsetHeight > currentGridBottom) {\n            let stickyHeaderOffset = 0;\n\n            if (this.generateHeader === GenerateHeaderOptions.sticky && this.generatedHeader !== null) {\n              stickyHeaderOffset = this.generatedHeader.clientHeight;\n            }\n\n            this.scrollTop = thisRow.offsetTop - stickyHeaderOffset;\n            break;\n          }\n        }\n\n        this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n        break;\n\n      case keyHome:\n        if (e.ctrlKey) {\n          e.preventDefault(); // focus first cell of first row\n\n          this.focusOnCell(0, 0, true);\n        }\n\n        break;\n\n      case keyEnd:\n        if (e.ctrlKey && this.columnDefinitions !== null) {\n          e.preventDefault(); // focus last cell of last row\n\n          this.focusOnCell(this.rowElements.length - 1, this.columnDefinitions.length - 1, true);\n        }\n\n        break;\n    }\n  }\n\n  queueFocusUpdate() {\n    if (this.isUpdatingFocus && (this.contains(document.activeElement) || this === document.activeElement)) {\n      return;\n    }\n\n    if (this.pendingFocusUpdate === false) {\n      this.pendingFocusUpdate = true;\n      DOM.queueUpdate(() => this.updateFocus());\n    }\n  }\n\n  updateFocus() {\n    this.pendingFocusUpdate = false;\n    this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n  }\n\n  toggleGeneratedHeader() {\n    if (this.generatedHeader !== null) {\n      this.removeChild(this.generatedHeader);\n      this.generatedHeader = null;\n    }\n\n    if (this.generateHeader !== GenerateHeaderOptions.none && this.rowsData.length > 0) {\n      const generatedHeaderElement = document.createElement(this.rowElementTag);\n      this.generatedHeader = generatedHeaderElement;\n      this.generatedHeader.columnDefinitions = this.columnDefinitions;\n      this.generatedHeader.gridTemplateColumns = this.gridTemplateColumns;\n      this.generatedHeader.rowType = this.generateHeader === GenerateHeaderOptions.sticky ? DataGridRowTypes.stickyHeader : DataGridRowTypes.header;\n\n      if (this.firstChild !== null || this.rowsPlaceholder !== null) {\n        this.insertBefore(generatedHeaderElement, this.firstChild !== null ? this.firstChild : this.rowsPlaceholder);\n      }\n\n      return;\n    }\n  }\n\n}\n/**\n *  generates a basic column definition by examining sample row data\n */\n\nDataGrid.generateColumns = row => {\n  return Object.getOwnPropertyNames(row).map((property, index) => {\n    return {\n      columnDataKey: property,\n      gridColumn: `${index}`\n    };\n  });\n};\n\n__decorate([attr({\n  attribute: \"no-tabbing\",\n  mode: \"boolean\"\n})], DataGrid.prototype, \"noTabbing\", void 0);\n\n__decorate([attr({\n  attribute: \"generate-header\"\n})], DataGrid.prototype, \"generateHeader\", void 0);\n\n__decorate([attr({\n  attribute: \"grid-template-columns\"\n})], DataGrid.prototype, \"gridTemplateColumns\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowsData\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"columnDefinitions\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"cellItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"headerCellItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"focusRowIndex\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"focusColumnIndex\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"defaultRowItemTemplate\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowElementTag\", void 0);\n\n__decorate([observable], DataGrid.prototype, \"rowElements\", void 0);","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/data-grid/data-grid.js"],"names":["__decorate","attr","DOM","observable","RepeatDirective","eventFocus","eventFocusOut","eventKeyDown","keyArrowDown","keyArrowUp","keyEnd","keyHome","keyPageDown","keyPageUp","FoundationElement","DataGridRowTypes","GenerateHeaderOptions","DataGrid","constructor","noTabbing","generateHeader","default","rowsData","columnDefinitions","focusRowIndex","focusColumnIndex","rowsPlaceholder","generatedHeader","isUpdatingFocus","pendingFocusUpdate","rowindexUpdateQueued","columnDefinitionsStale","generatedGridTemplateColumns","focusOnCell","rowIndex","columnIndex","scrollIntoView","rowElements","length","Math","max","min","focusRow","cells","querySelectorAll","focusTarget","scrollHeight","clientHeight","scrollTop","block","inline","focus","onChildListChange","mutations","observer","forEach","mutation","addedNodes","newNode","nodeType","getAttribute","queueRowIndexUpdate","queueUpdate","updateRowIndexes","newGridTemplateColumns","gridTemplateColumns","undefined","firstRow","Array","cellElements","fill","join","element","index","thisRow","generateTemplateColumns","templateColumns","column","noTabbingChanged","$fastController","isConnected","setAttribute","contains","document","activeElement","generateHeaderChanged","toggleGeneratedHeader","gridTemplateColumnsChanged","rowsDataChanged","generateColumns","columnDefinitionsChanged","headerCellItemTemplateChanged","headerCellItemTemplate","focusRowIndexChanged","queueFocusUpdate","focusColumnIndexChanged","connectedCallback","rowItemTemplate","defaultRowItemTemplate","createComment","appendChild","rowsRepeatBehavior","x","positioning","createBehavior","addBehaviors","addEventListener","handleRowFocus","handleFocus","handleKeydown","handleFocusOut","MutationObserver","observe","childList","disconnectedCallback","removeEventListener","disconnect","e","target","indexOf","relatedTarget","defaultPrevented","newFocusRowIndex","maxIndex","currentGridBottom","offsetHeight","lastRow","key","preventDefault","offsetTop","stickyHeaderOffset","sticky","ctrlKey","updateFocus","removeChild","none","generatedHeaderElement","createElement","rowElementTag","rowType","stickyHeader","header","firstChild","insertBefore","row","Object","getOwnPropertyNames","map","property","columnDataKey","gridColumn","attribute","mode","prototype"],"mappings":"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","sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, DOM, observable, RepeatDirective, } from \"@microsoft/fast-element\";\nimport { eventFocus, eventFocusOut, eventKeyDown, keyArrowDown, keyArrowUp, keyEnd, keyHome, keyPageDown, keyPageUp, } from \"@microsoft/fast-web-utilities\";\nimport { FoundationElement } from \"../foundation-element\";\nimport { DataGridRowTypes, GenerateHeaderOptions } from \"./data-grid.options\";\nexport { DataGridRowTypes, GenerateHeaderOptions };\n/**\n * A Data Grid Custom HTML Element.\n *\n * @public\n */\nexport class DataGrid extends FoundationElement {\n    constructor() {\n        super();\n        /**\n         * When true the component will not add itself to the tab queue.\n         * Default is false.\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: no-tabbing\n         */\n        this.noTabbing = false;\n        /**\n         *  Whether the grid should automatically generate a header row and its type\n         *\n         * @public\n         * @remarks\n         * HTML Attribute: generate-header\n         */\n        this.generateHeader = GenerateHeaderOptions.default;\n        /**\n         * The data being displayed in the grid\n         *\n         * @public\n         */\n        this.rowsData = [];\n        /**\n         * The column definitions of the grid\n         *\n         * @public\n         */\n        this.columnDefinitions = null;\n        /**\n         * The index of the row that will receive focus the next time the\n         * grid is focused. This value changes as focus moves to different\n         * rows within the grid.  Changing this value when focus is already\n         * within the grid moves focus to the specified row.\n         *\n         * @public\n         */\n        this.focusRowIndex = 0;\n        /**\n         * The index of the column that will receive focus the next time the\n         * grid is focused. This value changes as focus moves to different rows\n         * within the grid.  Changing this value when focus is already within\n         * the grid moves focus to the specified column.\n         *\n         * @public\n         */\n        this.focusColumnIndex = 0;\n        this.rowsPlaceholder = null;\n        this.generatedHeader = null;\n        this.isUpdatingFocus = false;\n        this.pendingFocusUpdate = false;\n        this.rowindexUpdateQueued = false;\n        this.columnDefinitionsStale = true;\n        this.generatedGridTemplateColumns = \"\";\n        this.focusOnCell = (rowIndex, columnIndex, scrollIntoView) => {\n            if (this.rowElements.length === 0) {\n                this.focusRowIndex = 0;\n                this.focusColumnIndex = 0;\n                return;\n            }\n            const focusRowIndex = Math.max(0, Math.min(this.rowElements.length - 1, rowIndex));\n            const focusRow = this.rowElements[focusRowIndex];\n            const cells = focusRow.querySelectorAll('[role=\"cell\"], [role=\"gridcell\"], [role=\"columnheader\"], [role=\"rowheader\"]');\n            const focusColumnIndex = Math.max(0, Math.min(cells.length - 1, columnIndex));\n            const focusTarget = cells[focusColumnIndex];\n            if (scrollIntoView &&\n                this.scrollHeight !== this.clientHeight &&\n                ((focusRowIndex < this.focusRowIndex && this.scrollTop > 0) ||\n                    (focusRowIndex > this.focusRowIndex &&\n                        this.scrollTop < this.scrollHeight - this.clientHeight))) {\n                focusTarget.scrollIntoView({ block: \"center\", inline: \"center\" });\n            }\n            focusTarget.focus();\n        };\n        this.onChildListChange = (mutations, \n        /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n        observer) => {\n            if (mutations && mutations.length) {\n                mutations.forEach((mutation) => {\n                    mutation.addedNodes.forEach((newNode) => {\n                        if (newNode.nodeType === 1 &&\n                            newNode.getAttribute(\"role\") === \"row\") {\n                            newNode.columnDefinitions = this.columnDefinitions;\n                        }\n                    });\n                });\n                this.queueRowIndexUpdate();\n            }\n        };\n        this.queueRowIndexUpdate = () => {\n            if (!this.rowindexUpdateQueued) {\n                this.rowindexUpdateQueued = true;\n                DOM.queueUpdate(this.updateRowIndexes);\n            }\n        };\n        this.updateRowIndexes = () => {\n            let newGridTemplateColumns = this.gridTemplateColumns;\n            if (newGridTemplateColumns === undefined) {\n                // try to generate columns based on manual rows\n                if (this.generatedGridTemplateColumns === \"\" && this.rowElements.length > 0) {\n                    const firstRow = this.rowElements[0];\n                    this.generatedGridTemplateColumns = new Array(firstRow.cellElements.length)\n                        .fill(\"1fr\")\n                        .join(\" \");\n                }\n                newGridTemplateColumns = this.generatedGridTemplateColumns;\n            }\n            this.rowElements.forEach((element, index) => {\n                const thisRow = element;\n                thisRow.rowIndex = index;\n                thisRow.gridTemplateColumns = newGridTemplateColumns;\n                if (this.columnDefinitionsStale) {\n                    thisRow.columnDefinitions = this.columnDefinitions;\n                }\n            });\n            this.rowindexUpdateQueued = false;\n            this.columnDefinitionsStale = false;\n        };\n    }\n    /**\n     *  generates a gridTemplateColumns based on columndata array\n     */\n    static generateTemplateColumns(columnDefinitions) {\n        let templateColumns = \"\";\n        columnDefinitions.forEach((column) => {\n            templateColumns = `${templateColumns}${templateColumns === \"\" ? \"\" : \" \"}${\"1fr\"}`;\n        });\n        return templateColumns;\n    }\n    noTabbingChanged() {\n        if (this.$fastController.isConnected) {\n            if (this.noTabbing) {\n                this.setAttribute(\"tabIndex\", \"-1\");\n            }\n            else {\n                this.setAttribute(\"tabIndex\", this.contains(document.activeElement) ||\n                    this === document.activeElement\n                    ? \"-1\"\n                    : \"0\");\n            }\n        }\n    }\n    generateHeaderChanged() {\n        if (this.$fastController.isConnected) {\n            this.toggleGeneratedHeader();\n        }\n    }\n    gridTemplateColumnsChanged() {\n        if (this.$fastController.isConnected) {\n            this.updateRowIndexes();\n        }\n    }\n    rowsDataChanged() {\n        if (this.columnDefinitions === null && this.rowsData.length > 0) {\n            this.columnDefinitions = DataGrid.generateColumns(this.rowsData[0]);\n        }\n        if (this.$fastController.isConnected) {\n            this.toggleGeneratedHeader();\n        }\n    }\n    columnDefinitionsChanged() {\n        if (this.columnDefinitions === null) {\n            this.generatedGridTemplateColumns = \"\";\n            return;\n        }\n        this.generatedGridTemplateColumns = DataGrid.generateTemplateColumns(this.columnDefinitions);\n        if (this.$fastController.isConnected) {\n            this.columnDefinitionsStale = true;\n            this.queueRowIndexUpdate();\n        }\n    }\n    headerCellItemTemplateChanged() {\n        if (this.$fastController.isConnected) {\n            if (this.generatedHeader !== null) {\n                this.generatedHeader.headerCellItemTemplate = this.headerCellItemTemplate;\n            }\n        }\n    }\n    focusRowIndexChanged() {\n        if (this.$fastController.isConnected) {\n            this.queueFocusUpdate();\n        }\n    }\n    focusColumnIndexChanged() {\n        if (this.$fastController.isConnected) {\n            this.queueFocusUpdate();\n        }\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.rowItemTemplate === undefined) {\n            this.rowItemTemplate = this.defaultRowItemTemplate;\n        }\n        this.rowsPlaceholder = document.createComment(\"\");\n        this.appendChild(this.rowsPlaceholder);\n        this.toggleGeneratedHeader();\n        this.rowsRepeatBehavior = new RepeatDirective(x => x.rowsData, x => x.rowItemTemplate, { positioning: true }).createBehavior(this.rowsPlaceholder);\n        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n        this.$fastController.addBehaviors([this.rowsRepeatBehavior]);\n        this.addEventListener(\"row-focused\", this.handleRowFocus);\n        this.addEventListener(eventFocus, this.handleFocus);\n        this.addEventListener(eventKeyDown, this.handleKeydown);\n        this.addEventListener(eventFocusOut, this.handleFocusOut);\n        this.observer = new MutationObserver(this.onChildListChange);\n        // only observe if nodes are added or removed\n        this.observer.observe(this, { childList: true });\n        if (this.noTabbing) {\n            this.setAttribute(\"tabindex\", \"-1\");\n        }\n        DOM.queueUpdate(this.queueRowIndexUpdate);\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.removeEventListener(\"row-focused\", this.handleRowFocus);\n        this.removeEventListener(eventFocus, this.handleFocus);\n        this.removeEventListener(eventKeyDown, this.handleKeydown);\n        this.removeEventListener(eventFocusOut, this.handleFocusOut);\n        // disconnect observer\n        this.observer.disconnect();\n        this.rowsPlaceholder = null;\n        this.generatedHeader = null;\n    }\n    /**\n     * @internal\n     */\n    handleRowFocus(e) {\n        this.isUpdatingFocus = true;\n        const focusRow = e.target;\n        this.focusRowIndex = this.rowElements.indexOf(focusRow);\n        this.focusColumnIndex = focusRow.focusColumnIndex;\n        this.setAttribute(\"tabIndex\", \"-1\");\n        this.isUpdatingFocus = false;\n    }\n    /**\n     * @internal\n     */\n    handleFocus(e) {\n        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n    }\n    /**\n     * @internal\n     */\n    handleFocusOut(e) {\n        if (e.relatedTarget === null || !this.contains(e.relatedTarget)) {\n            this.setAttribute(\"tabIndex\", this.noTabbing ? \"-1\" : \"0\");\n        }\n    }\n    /**\n     * @internal\n     */\n    handleKeydown(e) {\n        if (e.defaultPrevented) {\n            return;\n        }\n        let newFocusRowIndex;\n        const maxIndex = this.rowElements.length - 1;\n        const currentGridBottom = this.offsetHeight + this.scrollTop;\n        const lastRow = this.rowElements[maxIndex];\n        switch (e.key) {\n            case keyArrowUp:\n                e.preventDefault();\n                // focus up one row\n                this.focusOnCell(this.focusRowIndex - 1, this.focusColumnIndex, true);\n                break;\n            case keyArrowDown:\n                e.preventDefault();\n                // focus down one row\n                this.focusOnCell(this.focusRowIndex + 1, this.focusColumnIndex, true);\n                break;\n            case keyPageUp:\n                e.preventDefault();\n                if (this.rowElements.length === 0) {\n                    this.focusOnCell(0, 0, false);\n                    break;\n                }\n                if (this.focusRowIndex === 0) {\n                    this.focusOnCell(0, this.focusColumnIndex, false);\n                    return;\n                }\n                newFocusRowIndex = this.focusRowIndex - 1;\n                for (newFocusRowIndex; newFocusRowIndex >= 0; newFocusRowIndex--) {\n                    const thisRow = this.rowElements[newFocusRowIndex];\n                    if (thisRow.offsetTop < this.scrollTop) {\n                        this.scrollTop =\n                            thisRow.offsetTop + thisRow.clientHeight - this.clientHeight;\n                        break;\n                    }\n                }\n                this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n                break;\n            case keyPageDown:\n                e.preventDefault();\n                if (this.rowElements.length === 0) {\n                    this.focusOnCell(0, 0, false);\n                    break;\n                }\n                // focus down one \"page\"\n                if (this.focusRowIndex >= maxIndex ||\n                    lastRow.offsetTop + lastRow.offsetHeight <= currentGridBottom) {\n                    this.focusOnCell(maxIndex, this.focusColumnIndex, false);\n                    return;\n                }\n                newFocusRowIndex = this.focusRowIndex + 1;\n                for (newFocusRowIndex; newFocusRowIndex <= maxIndex; newFocusRowIndex++) {\n                    const thisRow = this.rowElements[newFocusRowIndex];\n                    if (thisRow.offsetTop + thisRow.offsetHeight > currentGridBottom) {\n                        let stickyHeaderOffset = 0;\n                        if (this.generateHeader === GenerateHeaderOptions.sticky &&\n                            this.generatedHeader !== null) {\n                            stickyHeaderOffset = this.generatedHeader.clientHeight;\n                        }\n                        this.scrollTop = thisRow.offsetTop - stickyHeaderOffset;\n                        break;\n                    }\n                }\n                this.focusOnCell(newFocusRowIndex, this.focusColumnIndex, false);\n                break;\n            case keyHome:\n                if (e.ctrlKey) {\n                    e.preventDefault();\n                    // focus first cell of first row\n                    this.focusOnCell(0, 0, true);\n                }\n                break;\n            case keyEnd:\n                if (e.ctrlKey && this.columnDefinitions !== null) {\n                    e.preventDefault();\n                    // focus last cell of last row\n                    this.focusOnCell(this.rowElements.length - 1, this.columnDefinitions.length - 1, true);\n                }\n                break;\n        }\n    }\n    queueFocusUpdate() {\n        if (this.isUpdatingFocus &&\n            (this.contains(document.activeElement) || this === document.activeElement)) {\n            return;\n        }\n        if (this.pendingFocusUpdate === false) {\n            this.pendingFocusUpdate = true;\n            DOM.queueUpdate(() => this.updateFocus());\n        }\n    }\n    updateFocus() {\n        this.pendingFocusUpdate = false;\n        this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, true);\n    }\n    toggleGeneratedHeader() {\n        if (this.generatedHeader !== null) {\n            this.removeChild(this.generatedHeader);\n            this.generatedHeader = null;\n        }\n        if (this.generateHeader !== GenerateHeaderOptions.none &&\n            this.rowsData.length > 0) {\n            const generatedHeaderElement = document.createElement(this.rowElementTag);\n            this.generatedHeader = generatedHeaderElement;\n            this.generatedHeader.columnDefinitions = this.columnDefinitions;\n            this.generatedHeader.gridTemplateColumns = this.gridTemplateColumns;\n            this.generatedHeader.rowType =\n                this.generateHeader === GenerateHeaderOptions.sticky\n                    ? DataGridRowTypes.stickyHeader\n                    : DataGridRowTypes.header;\n            if (this.firstChild !== null || this.rowsPlaceholder !== null) {\n                this.insertBefore(generatedHeaderElement, this.firstChild !== null ? this.firstChild : this.rowsPlaceholder);\n            }\n            return;\n        }\n    }\n}\n/**\n *  generates a basic column definition by examining sample row data\n */\nDataGrid.generateColumns = (row) => {\n    return Object.getOwnPropertyNames(row).map((property, index) => {\n        return {\n            columnDataKey: property,\n            gridColumn: `${index}`,\n        };\n    });\n};\n__decorate([\n    attr({ attribute: \"no-tabbing\", mode: \"boolean\" })\n], DataGrid.prototype, \"noTabbing\", void 0);\n__decorate([\n    attr({ attribute: \"generate-header\" })\n], DataGrid.prototype, \"generateHeader\", void 0);\n__decorate([\n    attr({ attribute: \"grid-template-columns\" })\n], DataGrid.prototype, \"gridTemplateColumns\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowsData\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"columnDefinitions\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"cellItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"headerCellItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"focusRowIndex\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"focusColumnIndex\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"defaultRowItemTemplate\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowElementTag\", void 0);\n__decorate([\n    observable\n], DataGrid.prototype, \"rowElements\", void 0);\n"]},"metadata":{},"sourceType":"module"}