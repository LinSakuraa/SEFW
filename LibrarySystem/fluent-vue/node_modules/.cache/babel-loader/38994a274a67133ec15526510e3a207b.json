{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/**\n * Big thanks to https://github.com/fkleuver and the https://github.com/aurelia/aurelia project\n * for the bulk of this code and many of the associated tests.\n */\nimport { emptyArray, FASTElement } from \"@microsoft/fast-element\"; // Tiny polyfill for TypeScript's Reflect metadata API.\n\nconst metadataByTarget = new Map();\n\nif (!(\"metadata\" in Reflect)) {\n  Reflect.metadata = function (key, value) {\n    return function (target) {\n      Reflect.defineMetadata(key, value, target);\n    };\n  };\n\n  Reflect.defineMetadata = function (key, value, target) {\n    let metadata = metadataByTarget.get(target);\n\n    if (metadata === void 0) {\n      metadataByTarget.set(target, metadata = new Map());\n    }\n\n    metadata.set(key, value);\n  };\n\n  Reflect.getOwnMetadata = function (key, target) {\n    const metadata = metadataByTarget.get(target);\n\n    if (metadata !== void 0) {\n      return metadata.get(key);\n    }\n\n    return void 0;\n  };\n}\n/**\n * A utility class used that constructs and registers resolvers for a dependency\n * injection container. Supports a standard set of object lifetimes.\n * @public\n */\n\n\nexport class ResolverBuilder {\n  /**\n   *\n   * @param container - The container to create resolvers for.\n   * @param key - The key to register resolvers under.\n   */\n  constructor(container, key) {\n    this.container = container;\n    this.key = key;\n  }\n  /**\n   * Creates a resolver for an existing object instance.\n   * @param value - The instance to resolve.\n   * @returns The resolver.\n   */\n\n\n  instance(value) {\n    return this.registerResolver(0\n    /* instance */\n    , value);\n  }\n  /**\n   * Creates a resolver that enforces a singleton lifetime.\n   * @param value - The type to create and cache the singleton for.\n   * @returns The resolver.\n   */\n\n\n  singleton(value) {\n    return this.registerResolver(1\n    /* singleton */\n    , value);\n  }\n  /**\n   * Creates a resolver that creates a new instance for every dependency request.\n   * @param value - The type to create instances of.\n   * @returns - The resolver.\n   */\n\n\n  transient(value) {\n    return this.registerResolver(2\n    /* transient */\n    , value);\n  }\n  /**\n   * Creates a resolver that invokes a callback function for every dependency resolution\n   * request, allowing custom logic to return the dependency.\n   * @param value - The callback to call during resolution.\n   * @returns The resolver.\n   */\n\n\n  callback(value) {\n    return this.registerResolver(3\n    /* callback */\n    , value);\n  }\n  /**\n   * Creates a resolver that invokes a callback function the first time that a dependency\n   * resolution is requested. The returned value is then cached and provided for all\n   * subsequent requests.\n   * @param value - The callback to call during the first resolution.\n   * @returns The resolver.\n   */\n\n\n  cachedCallback(value) {\n    return this.registerResolver(3\n    /* callback */\n    , cacheCallbackResult(value));\n  }\n  /**\n   * Aliases the current key to a different key.\n   * @param destinationKey - The key to point the alias to.\n   * @returns The resolver.\n   */\n\n\n  aliasTo(destinationKey) {\n    return this.registerResolver(5\n    /* alias */\n    , destinationKey);\n  }\n\n  registerResolver(strategy, state) {\n    const {\n      container,\n      key\n    } = this;\n    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n\n    this.container = this.key = void 0;\n    return container.registerResolver(key, new ResolverImpl(key, strategy, state));\n  }\n\n}\n\nfunction cloneArrayWithPossibleProps(source) {\n  const clone = source.slice();\n  const keys = Object.keys(source);\n  const len = keys.length;\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n\n    if (!isArrayIndex(key)) {\n      clone[key] = source[key];\n    }\n  }\n\n  return clone;\n}\n/**\n * A set of default resolvers useful in configuring a container.\n * @public\n */\n\n\nexport const DefaultResolver = Object.freeze({\n  /**\n   * Disables auto-registration and throws for all un-registered dependencies.\n   * @param key - The key to create the resolver for.\n   */\n  none(key) {\n    throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);\n  },\n\n  /**\n   * Provides default singleton resolution behavior during auto-registration.\n   * @param key - The key to create the resolver for.\n   * @returns The resolver.\n   */\n  singleton(key) {\n    return new ResolverImpl(key, 1\n    /* singleton */\n    , key);\n  },\n\n  /**\n   * Provides default transient resolution behavior during auto-registration.\n   * @param key - The key to create the resolver for.\n   * @returns The resolver.\n   */\n  transient(key) {\n    return new ResolverImpl(key, 2\n    /* transient */\n    , key);\n  }\n\n});\n/**\n * Configuration for a dependency injection container.\n * @public\n */\n\nexport const ContainerConfiguration = Object.freeze({\n  /**\n   * The default configuration used when creating a DOM-disconnected container.\n   * @remarks\n   * The default creates a root container, with no parent container. It does not handle\n   * owner requests and it uses singleton resolution behavior for auto-registration.\n   */\n  default: Object.freeze({\n    parentLocator: () => null,\n    responsibleForOwnerRequests: false,\n    defaultResolver: DefaultResolver.singleton\n  })\n});\nconst dependencyLookup = new Map();\n\nfunction getParamTypes(key) {\n  return Type => {\n    return Reflect.getOwnMetadata(key, Type);\n  };\n}\n\nlet rootDOMContainer = null;\n/**\n * The gateway to dependency injection APIs.\n * @public\n */\n\nexport const DI = Object.freeze({\n  /**\n   * Creates a new dependency injection container.\n   * @param config - The configuration for the container.\n   * @returns A newly created dependency injection container.\n   */\n  createContainer(config) {\n    return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));\n  },\n\n  /**\n   * Finds the dependency injection container responsible for providing dependencies\n   * to the specified node.\n   * @param node - The node to find the responsible container for.\n   * @returns The container responsible for providing dependencies to the node.\n   * @remarks\n   * This will be the same as the parent container if the specified node\n   * does not itself host a container configured with responsibleForOwnerRequests.\n   */\n  findResponsibleContainer(node) {\n    const owned = node.$$container$$;\n\n    if (owned && owned.responsibleForOwnerRequests) {\n      return owned;\n    }\n\n    return DI.findParentContainer(node);\n  },\n\n  /**\n   * Find the dependency injection container up the DOM tree from this node.\n   * @param node - The node to find the parent container for.\n   * @returns The parent container of this node.\n   * @remarks\n   * This will be the same as the responsible container if the specified node\n   * does not itself host a container configured with responsibleForOwnerRequests.\n   */\n  findParentContainer(node) {\n    const event = new CustomEvent(DILocateParentEventType, {\n      bubbles: true,\n      composed: true,\n      cancelable: true,\n      detail: {\n        container: void 0\n      }\n    });\n    node.dispatchEvent(event);\n    return event.detail.container || DI.getOrCreateDOMContainer();\n  },\n\n  /**\n   * Returns a dependency injection container if one is explicitly owned by the specified\n   * node. If one is not owned, then a new container is created and assigned to the node.\n   * @param node - The node to find or create the container for.\n   * @param config - The configuration for the container if one needs to be created.\n   * @returns The located or created container.\n   * @remarks\n   * This API does not search for a responsible or parent container. It looks only for a container\n   * directly defined on the specified node and creates one at that location if one does not\n   * already exist.\n   */\n  getOrCreateDOMContainer(node, config) {\n    if (!node) {\n      return rootDOMContainer || (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {\n        parentLocator: () => null\n      })));\n    }\n\n    return node.$$container$$ || new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {\n      parentLocator: DI.findParentContainer\n    }));\n  },\n\n  /**\n   * Gets the \"design:paramtypes\" metadata for the specified type.\n   * @param Type - The type to get the metadata for.\n   * @returns The metadata array or undefined if no metadata is found.\n   */\n  getDesignParamtypes: getParamTypes(\"design:paramtypes\"),\n\n  /**\n   * Gets the \"di:paramtypes\" metadata for the specified type.\n   * @param Type - The type to get the metadata for.\n   * @returns The metadata array or undefined if no metadata is found.\n   */\n  getAnnotationParamtypes: getParamTypes(\"di:paramtypes\"),\n\n  /**\n   *\n   * @param Type - Gets the \"di:paramtypes\" metadata for the specified type. If none is found,\n   * an empty metadata array is created and added.\n   * @returns The metadata array.\n   */\n  getOrCreateAnnotationParamTypes(Type) {\n    let annotationParamtypes = this.getAnnotationParamtypes(Type);\n\n    if (annotationParamtypes === void 0) {\n      Reflect.defineMetadata(\"di:paramtypes\", annotationParamtypes = [], Type);\n    }\n\n    return annotationParamtypes;\n  },\n\n  /**\n   * Gets the dependency keys representing what is needed to instantiate the specified type.\n   * @param Type - The type to get the dependencies for.\n   * @returns An array of dependency keys.\n   */\n  getDependencies(Type) {\n    // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n    // so be careful with making changes here as it can have a huge impact on complex end user apps.\n    // Preferably, only make changes to the dependency resolution process via a RFC.\n    let dependencies = dependencyLookup.get(Type);\n\n    if (dependencies === void 0) {\n      // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n      // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n      // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n      // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n      const inject = Type.inject;\n\n      if (inject === void 0) {\n        // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n        const designParamtypes = DI.getDesignParamtypes(Type); // di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n\n        const annotationParamtypes = DI.getAnnotationParamtypes(Type);\n\n        if (designParamtypes === void 0) {\n          if (annotationParamtypes === void 0) {\n            // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n            // there is no sound way to merge a type's deps with its prototype's deps\n            const Proto = Object.getPrototypeOf(Type);\n\n            if (typeof Proto === \"function\" && Proto !== Function.prototype) {\n              dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));\n            } else {\n              dependencies = [];\n            }\n          } else {\n            // No design:paramtypes so just use the di:paramtypes\n            dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n          }\n        } else if (annotationParamtypes === void 0) {\n          // No di:paramtypes so just use the design:paramtypes\n          dependencies = cloneArrayWithPossibleProps(designParamtypes);\n        } else {\n          // We've got both, so merge them (in case of conflict on same index, di:paramtypes take precedence)\n          dependencies = cloneArrayWithPossibleProps(designParamtypes);\n          let len = annotationParamtypes.length;\n          let auAnnotationParamtype;\n\n          for (let i = 0; i < len; ++i) {\n            auAnnotationParamtype = annotationParamtypes[i];\n\n            if (auAnnotationParamtype !== void 0) {\n              dependencies[i] = auAnnotationParamtype;\n            }\n          }\n\n          const keys = Object.keys(annotationParamtypes);\n          len = keys.length;\n          let key;\n\n          for (let i = 0; i < len; ++i) {\n            key = keys[i];\n\n            if (!isArrayIndex(key)) {\n              dependencies[key] = annotationParamtypes[key];\n            }\n          }\n        }\n      } else {\n        // Ignore paramtypes if we have static inject\n        dependencies = cloneArrayWithPossibleProps(inject);\n      }\n\n      dependencyLookup.set(Type, dependencies);\n    }\n\n    return dependencies;\n  },\n\n  /**\n   * Defines a property on a web component class. The value of this property will\n   * be resolved from the dependency injection container responsible for the element\n   * instance, based on where it is connected in the DOM.\n   * @param target - The target to define the property on.\n   * @param propertyName - The name of the property to define.\n   * @param key - The dependency injection key.\n   * @param respectConnection - Indicates whether or not to update the property value if the\n   * hosting component is disconnected and then re-connected at a different location in the DOM.\n   * @remarks\n   * The respectConnection option is only applicable to elements that descend from FASTElement.\n   */\n  defineProperty(target, propertyName, key, respectConnection = false) {\n    const diPropertyKey = `$di_${propertyName}`;\n    Reflect.defineProperty(target, propertyName, {\n      get: function () {\n        let value = this[diPropertyKey];\n\n        if (value === void 0) {\n          const container = this instanceof HTMLElement ? DI.findResponsibleContainer(this) : DI.getOrCreateDOMContainer();\n          value = container.get(key);\n          this[diPropertyKey] = value;\n\n          if (respectConnection && this instanceof FASTElement) {\n            const notifier = this.$fastController;\n\n            const handleChange = () => {\n              const newContainer = DI.findResponsibleContainer(this);\n              const newValue = newContainer.get(key);\n              const oldValue = this[diPropertyKey];\n\n              if (newValue !== oldValue) {\n                this[diPropertyKey] = value;\n                notifier.notify(propertyName);\n              }\n            };\n\n            notifier.subscribe({\n              handleChange\n            }, \"isConnected\");\n          }\n        }\n\n        return value;\n      }\n    });\n  },\n\n  /**\n   * Creates a dependency injection key.\n   * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a\n   * default resolution for the dependency.\n   * @param configuror - If a friendly name was provided for the first parameter, then an optional\n   * lambda that configures a default resolution for the dependency can be provided second.\n   * @returns The created key.\n   * @remarks\n   * The created key can be used as a property decorator or constructor parameter decorator,\n   * in addition to its standard use in an inject array or through direct container APIs.\n   */\n  createInterface(nameConfigOrCallback, configuror) {\n    const configure = typeof nameConfigOrCallback === \"function\" ? nameConfigOrCallback : configuror;\n    const friendlyName = typeof nameConfigOrCallback === \"string\" ? nameConfigOrCallback : nameConfigOrCallback && \"friendlyName\" in nameConfigOrCallback ? nameConfigOrCallback.friendlyName || defaultFriendlyName : defaultFriendlyName;\n    const respectConnection = typeof nameConfigOrCallback === \"string\" ? false : nameConfigOrCallback && \"respectConnection\" in nameConfigOrCallback ? nameConfigOrCallback.respectConnection || false : false;\n\n    const Interface = function (target, property, index) {\n      if (target == null || new.target !== undefined) {\n        throw new Error(`No registration for interface: '${Interface.friendlyName}'`);\n      }\n\n      if (property) {\n        DI.defineProperty(target, property, Interface, respectConnection);\n      } else {\n        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n        annotationParamtypes[index] = Interface;\n      }\n    };\n\n    Interface.$isInterface = true;\n    Interface.friendlyName = friendlyName == null ? \"(anonymous)\" : friendlyName;\n\n    if (configure != null) {\n      Interface.register = function (container, key) {\n        return configure(new ResolverBuilder(container, key !== null && key !== void 0 ? key : Interface));\n      };\n    }\n\n    Interface.toString = function toString() {\n      return `InterfaceSymbol<${Interface.friendlyName}>`;\n    };\n\n    return Interface;\n  },\n\n  /**\n   * A decorator that specifies what to inject into its target.\n   * @param dependencies - The dependencies to inject.\n   * @returns The decorator to be applied to the target class.\n   * @remarks\n   * The decorator can be used to decorate a class, listing all of the classes dependencies.\n   * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n   * parameter.\n   * Or it can be used for a web component property, indicating what that property should resolve to.\n   */\n  inject(...dependencies) {\n    return function (target, key, descriptor) {\n      if (typeof descriptor === \"number\") {\n        // It's a parameter decorator.\n        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n        const dep = dependencies[0];\n\n        if (dep !== void 0) {\n          annotationParamtypes[descriptor] = dep;\n        }\n      } else if (key) {\n        DI.defineProperty(target, key, dependencies[0]);\n      } else {\n        const annotationParamtypes = descriptor ? DI.getOrCreateAnnotationParamTypes(descriptor.value) : DI.getOrCreateAnnotationParamTypes(target);\n        let dep;\n\n        for (let i = 0; i < dependencies.length; ++i) {\n          dep = dependencies[i];\n\n          if (dep !== void 0) {\n            annotationParamtypes[i] = dep;\n          }\n        }\n      }\n    };\n  },\n\n  /**\n   * Registers the `target` class as a transient dependency; each time the dependency is resolved\n   * a new instance will be created.\n   *\n   * @param target - The class / constructor function to register as transient.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   *\n   * @example\n   * On an existing class\n   * ```ts\n   * class Foo { }\n   * DI.transient(Foo);\n   * ```\n   *\n   * @example\n   * Inline declaration\n   *\n   * ```ts\n   * const Foo = DI.transient(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   *\n   * @public\n   */\n  transient(target) {\n    target.register = function register(container) {\n      const registration = Registration.transient(target, target);\n      return registration.register(container);\n    };\n\n    target.registerInRequestor = false;\n    return target;\n  },\n\n  /**\n   * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n   * consecutive time the dependency is resolved, the same instance will be returned.\n   *\n   * @param target - The class / constructor function to register as a singleton.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   * @example\n   * On an existing class\n   * ```ts\n   * class Foo { }\n   * DI.singleton(Foo);\n   * ```\n   *\n   * @example\n   * Inline declaration\n   * ```ts\n   * const Foo = DI.singleton(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   *\n   * @public\n   */\n  singleton(target, options = defaultSingletonOptions) {\n    target.register = function register(container) {\n      const registration = Registration.singleton(target, target);\n      return registration.register(container);\n    };\n\n    target.registerInRequestor = options.scoped;\n    return target;\n  }\n\n});\n/**\n * The interface key that resolves the dependency injection container itself.\n * @public\n */\n\nexport const Container = DI.createInterface(\"Container\");\n/**\n * The interface key that resolves the service locator itself.\n * @public\n */\n\nexport const ServiceLocator = Container;\n\nfunction createResolver(getter) {\n  return function (key) {\n    const resolver = function (target, property, descriptor) {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.$isResolver = true;\n\n    resolver.resolve = function (handler, requestor) {\n      return getter(key, handler, requestor);\n    };\n\n    return resolver;\n  };\n}\n/**\n * A decorator that specifies what to inject into its target.\n * @param dependencies - The dependencies to inject.\n * @returns The decorator to be applied to the target class.\n * @remarks\n * The decorator can be used to decorate a class, listing all of the classes dependencies.\n * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n * parameter.\n * Or it can be used for a web component property, indicating what that property should resolve to.\n *\n * @public\n */\n\n\nexport const inject = DI.inject;\n\nfunction transientDecorator(target) {\n  return DI.transient(target);\n}\n\nexport function transient(target) {\n  return target == null ? transientDecorator : transientDecorator(target);\n}\nconst defaultSingletonOptions = {\n  scoped: false\n};\n\nfunction singletonDecorator(target) {\n  return DI.singleton(target);\n}\n/**\n * @public\n */\n\n\nexport function singleton(targetOrOptions) {\n  if (typeof targetOrOptions === \"function\") {\n    return DI.singleton(targetOrOptions);\n  }\n\n  return function ($target) {\n    return DI.singleton($target, targetOrOptions);\n  };\n}\n\nfunction createAllResolver(getter) {\n  return function (key, searchAncestors) {\n    searchAncestors = !!searchAncestors;\n\n    const resolver = function (target, property, descriptor) {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.$isResolver = true;\n\n    resolver.resolve = function (handler, requestor) {\n      /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n      return getter(key, handler, requestor, searchAncestors);\n    };\n\n    return resolver;\n  };\n}\n/**\n * A decorator and DI resolver that will resolve an array of all dependencies\n * registered with the specified key.\n * @param key - The key to resolve all dependencies for.\n * @param searchAncestors - [optional] Indicates whether to search ancestor containers.\n * @public\n */\n\n\nexport const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));\n/**\n * A decorator that lazily injects a dependency depending on whether the `Key` is present at the time of function call.\n *\n * @example\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method.\n * @example\n * This, would give you a new 'Math.random()' number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n *\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * @param key - The key to lazily resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\n\nexport const lazy = createResolver((key, handler, requestor) => {\n  return () => requestor.get(key);\n});\n/**\n * A decorator that allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example:\n * @example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n *\n * @example\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so remember to mark your input type as\n * possibly `undefined`!\n *\n * @param key - The key to optionally resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\n\nexport const optional = createResolver((key, handler, requestor) => {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return undefined;\n  }\n});\n/**\n * A decorator that tells the container not to try to inject a dependency.\n *\n * @public\n */\n\nexport function ignore(target, property, descriptor) {\n  DI.inject(ignore)(target, property, descriptor);\n} // Hack: casting below used to prevent TS from generate a namespace which can't be commented\n// and results in documentation validation errors.\n\nignore.$isResolver = true;\n\nignore.resolve = () => undefined;\n/**\n * A decorator that indicates that a new instance should be injected scoped to the\n * container that requested the instance.\n * @param key - The dependency key for the new instance.\n * @remarks\n * This creates a resolver with an instance strategy pointing to the new instance, effectively\n * making this a singleton, scoped to the container or DOM's subtree.\n *\n * @public\n */\n\n\nexport const newInstanceForScope = createResolver((key, handler, requestor) => {\n  const instance = createNewInstance(key, handler);\n  const resolver = new ResolverImpl(key, 0\n  /* instance */\n  , instance);\n  requestor.registerResolver(key, resolver);\n  return instance;\n});\n/**\n * A decorator that indicates that a new instance should be injected.\n * @param key - The dependency key for the new instance.\n * @remarks\n * The instance is not internally cached with a resolver as newInstanceForScope does.\n *\n * @public\n */\n\nexport const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));\n\nfunction createNewInstance(key, handler) {\n  /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n  return handler.getFactory(key).construct(handler);\n}\n/** @internal */\n\n\nexport class ResolverImpl {\n  constructor(key, strategy, state) {\n    this.key = key;\n    this.strategy = strategy;\n    this.state = state;\n    this.resolving = false;\n  }\n\n  get $isResolver() {\n    return true;\n  }\n\n  register(container) {\n    return container.registerResolver(this.key, this);\n  }\n\n  resolve(handler, requestor) {\n    switch (this.strategy) {\n      case 0\n      /* instance */\n      :\n        return this.state;\n\n      case 1\n      /* singleton */\n      :\n        {\n          if (this.resolving) {\n            throw new Error(`Cyclic dependency found: ${this.state.name}`);\n          }\n\n          this.resolving = true;\n          this.state = handler.getFactory(this.state).construct(requestor);\n          this.strategy = 0\n          /* instance */\n          ;\n          this.resolving = false;\n          return this.state;\n        }\n\n      case 2\n      /* transient */\n      :\n        {\n          // Always create transients from the requesting container\n          const factory = handler.getFactory(this.state);\n\n          if (factory === null) {\n            throw new Error(`Resolver for ${String(this.key)} returned a null factory`);\n          }\n\n          return factory.construct(requestor);\n        }\n\n      case 3\n      /* callback */\n      :\n        return this.state(handler, requestor, this);\n\n      case 4\n      /* array */\n      :\n        return this.state[0].resolve(handler, requestor);\n\n      case 5\n      /* alias */\n      :\n        return requestor.get(this.state);\n\n      default:\n        throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);\n    }\n  }\n\n  getFactory(container) {\n    var _a, _b, _c;\n\n    switch (this.strategy) {\n      case 1\n      /* singleton */\n      :\n      case 2\n      /* transient */\n      :\n        return container.getFactory(this.state);\n\n      case 5\n      /* alias */\n      :\n        return (_c = (_b = (_a = container.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container)) !== null && _c !== void 0 ? _c : null;\n\n      default:\n        return null;\n    }\n  }\n\n}\n\nfunction containerGetKey(d) {\n  return this.get(d);\n}\n\nfunction transformInstance(inst, transform) {\n  return transform(inst);\n}\n/** @internal */\n\n\nexport class FactoryImpl {\n  constructor(Type, dependencies) {\n    this.Type = Type;\n    this.dependencies = dependencies;\n    this.transformers = null;\n  }\n\n  construct(container, dynamicDependencies) {\n    let instance;\n\n    if (dynamicDependencies === void 0) {\n      instance = new this.Type(...this.dependencies.map(containerGetKey, container));\n    } else {\n      instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);\n    }\n\n    if (this.transformers == null) {\n      return instance;\n    }\n\n    return this.transformers.reduce(transformInstance, instance);\n  }\n\n  registerTransformer(transformer) {\n    (this.transformers || (this.transformers = [])).push(transformer);\n  }\n\n}\nconst containerResolver = {\n  $isResolver: true,\n\n  resolve(handler, requestor) {\n    return requestor;\n  }\n\n};\n\nfunction isRegistry(obj) {\n  return typeof obj.register === \"function\";\n}\n\nfunction isSelfRegistry(obj) {\n  return isRegistry(obj) && typeof obj.registerInRequestor === \"boolean\";\n}\n\nfunction isRegisterInRequester(obj) {\n  return isSelfRegistry(obj) && obj.registerInRequestor;\n}\n\nfunction isClass(obj) {\n  return obj.prototype !== void 0;\n}\n\nconst InstrinsicTypeNames = new Set([\"Array\", \"ArrayBuffer\", \"Boolean\", \"DataView\", \"Date\", \"Error\", \"EvalError\", \"Float32Array\", \"Float64Array\", \"Function\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Map\", \"Number\", \"Object\", \"Promise\", \"RangeError\", \"ReferenceError\", \"RegExp\", \"Set\", \"SharedArrayBuffer\", \"String\", \"SyntaxError\", \"TypeError\", \"Uint8Array\", \"Uint8ClampedArray\", \"Uint16Array\", \"Uint32Array\", \"URIError\", \"WeakMap\", \"WeakSet\"]);\nconst DILocateParentEventType = \"__DI_LOCATE_PARENT__\";\nconst factories = new Map();\n/**\n * @internal\n */\n\nexport class ContainerImpl {\n  constructor(owner, config) {\n    this.owner = owner;\n    this.config = config;\n    this._parent = void 0;\n    this.registerDepth = 0;\n    this.context = null;\n\n    if (owner !== null) {\n      owner.$$container$$ = this;\n    }\n\n    this.resolvers = new Map();\n    this.resolvers.set(Container, containerResolver);\n\n    if (owner instanceof Node) {\n      owner.addEventListener(DILocateParentEventType, e => {\n        if (e.composedPath()[0] !== this.owner) {\n          e.detail.container = this;\n          e.stopImmediatePropagation();\n        }\n      });\n    }\n  }\n\n  get parent() {\n    if (this._parent === void 0) {\n      this._parent = this.config.parentLocator(this.owner);\n    }\n\n    return this._parent;\n  }\n\n  get depth() {\n    return this.parent === null ? 0 : this.parent.depth + 1;\n  }\n\n  get responsibleForOwnerRequests() {\n    return this.config.responsibleForOwnerRequests;\n  }\n\n  registerWithContext(context, ...params) {\n    this.context = context;\n    this.register(...params);\n    this.context = null;\n    return this;\n  }\n\n  register(...params) {\n    if (++this.registerDepth === 100) {\n      throw new Error(\"Unable to autoregister dependency\"); // Most likely cause is trying to register a plain object that does not have a\n      // register method and is not a class constructor\n    }\n\n    let current;\n    let keys;\n    let value;\n    let j;\n    let jj;\n    const context = this.context;\n\n    for (let i = 0, ii = params.length; i < ii; ++i) {\n      current = params[i];\n\n      if (!isObject(current)) {\n        continue;\n      }\n\n      if (isRegistry(current)) {\n        current.register(this, context);\n      } else if (isClass(current)) {\n        Registration.singleton(current, current).register(this);\n      } else {\n        keys = Object.keys(current);\n        j = 0;\n        jj = keys.length;\n\n        for (; j < jj; ++j) {\n          value = current[keys[j]];\n\n          if (!isObject(value)) {\n            continue;\n          } // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n\n\n          if (isRegistry(value)) {\n            value.register(this, context);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n\n    --this.registerDepth;\n    return this;\n  }\n\n  registerResolver(key, resolver) {\n    validateKey(key);\n    const resolvers = this.resolvers;\n    const result = resolvers.get(key);\n\n    if (result == null) {\n      resolvers.set(key, resolver);\n    } else if (result instanceof ResolverImpl && result.strategy === 4\n    /* array */\n    ) {\n      result.state.push(resolver);\n    } else {\n      resolvers.set(key, new ResolverImpl(key, 4\n      /* array */\n      , [result, resolver]));\n    }\n\n    return resolver;\n  }\n\n  registerTransformer(key, transformer) {\n    const resolver = this.getResolver(key);\n\n    if (resolver == null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const factory = resolver.getFactory(this);\n\n      if (factory == null) {\n        return false;\n      } // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n      // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n      // type Constructable. So the return type of that optional method has this additional constraint, which\n      // seems to confuse the type checker.\n\n\n      factory.registerTransformer(transformer);\n      return true;\n    }\n\n    return false;\n  }\n\n  getResolver(key, autoRegister = true) {\n    validateKey(key);\n\n    if (key.resolve !== void 0) {\n      return key;\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n\n    let current = this;\n    let resolver;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          const handler = isRegisterInRequester(key) ? this : current;\n          return autoRegister ? this.jitRegister(key, handler) : null;\n        }\n\n        current = current.parent;\n      } else {\n        return resolver;\n      }\n    }\n\n    return null;\n  }\n\n  has(key, searchAncestors = false) {\n    return this.resolvers.has(key) ? true : searchAncestors && this.parent != null ? this.parent.has(key, true) : false;\n  }\n\n  get(key) {\n    validateKey(key);\n\n    if (key.$isResolver) {\n      return key.resolve(this, this);\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n\n    let current = this;\n    let resolver;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          const handler = isRegisterInRequester(key) ? this : current;\n          resolver = this.jitRegister(key, handler);\n          return resolver.resolve(current, this);\n        }\n\n        current = current.parent;\n      } else {\n        return resolver.resolve(current, this);\n      }\n    }\n\n    throw new Error(`Unable to resolve key: ${key}`);\n  }\n\n  getAll(key, searchAncestors = false) {\n    validateKey(key);\n    /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\n    const requestor = this;\n    let current = requestor;\n    let resolver;\n\n    if (searchAncestors) {\n      let resolutions = emptyArray;\n\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n\n        if (resolver != null) {\n          resolutions = resolutions.concat(\n          /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n          buildAllResponse(resolver, current, requestor));\n        }\n\n        current = current.parent;\n      }\n\n      return resolutions;\n    } else {\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n\n        if (resolver == null) {\n          current = current.parent;\n\n          if (current == null) {\n            return emptyArray;\n          }\n        } else {\n          return buildAllResponse(resolver, current, requestor);\n        }\n      }\n    }\n\n    return emptyArray;\n  }\n\n  getFactory(Type) {\n    let factory = factories.get(Type);\n\n    if (factory === void 0) {\n      if (isNativeFunction(Type)) {\n        throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);\n      }\n\n      factories.set(Type, factory = new FactoryImpl(Type, DI.getDependencies(Type)));\n    }\n\n    return factory;\n  }\n\n  registerFactory(key, factory) {\n    factories.set(key, factory);\n  }\n\n  createChild(config) {\n    return new ContainerImpl(null, Object.assign({}, this.config, config, {\n      parentLocator: () => this\n    }));\n  }\n\n  jitRegister(keyAsValue, handler) {\n    if (typeof keyAsValue !== \"function\") {\n      throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);\n    }\n\n    if (InstrinsicTypeNames.has(keyAsValue.name)) {\n      throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);\n    }\n\n    if (isRegistry(keyAsValue)) {\n      const registrationResolver = keyAsValue.register(handler);\n\n      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {\n        const newResolver = handler.resolvers.get(keyAsValue);\n\n        if (newResolver != void 0) {\n          return newResolver;\n        }\n\n        throw new Error(\"A valid resolver was not returned from the static register method\");\n      }\n\n      return registrationResolver;\n    } else if (keyAsValue.$isInterface) {\n      throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);\n    } else {\n      const resolver = this.config.defaultResolver(keyAsValue, handler);\n      handler.resolvers.set(keyAsValue, resolver);\n      return resolver;\n    }\n  }\n\n}\nconst cache = new WeakMap();\n\nfunction cacheCallbackResult(fun) {\n  return function (handler, requestor, resolver) {\n    if (cache.has(resolver)) {\n      return cache.get(resolver);\n    }\n\n    const t = fun(handler, requestor, resolver);\n    cache.set(resolver, t);\n    return t;\n  };\n}\n/**\n * You can use the resulting Registration of any of the factory methods\n * to register with the container.\n *\n * @example\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n *\n * @public\n */\n\n\nexport const Registration = Object.freeze({\n  /**\n   * Allows you to pass an instance.\n   * Every time you request this {@link Key} you will get this instance back.\n   *\n   * @example\n   * ```\n   * Registration.instance(Foo, new Foo()));\n   * ```\n   *\n   * @param key - The key to register the instance under.\n   * @param value - The instance to return when the key is requested.\n   */\n  instance(key, value) {\n    return new ResolverImpl(key, 0\n    /* instance */\n    , value);\n  },\n\n  /**\n   * Creates an instance from the class.\n   * Every time you request this {@link Key} you will get the same one back.\n   *\n   * @example\n   * ```\n   * Registration.singleton(Foo, Foo);\n   * ```\n   *\n   * @param key - The key to register the singleton under.\n   * @param value - The class to instantiate as a singleton when first requested.\n   */\n  singleton(key, value) {\n    return new ResolverImpl(key, 1\n    /* singleton */\n    , value);\n  },\n\n  /**\n   * Creates an instance from a class.\n   * Every time you request this {@link Key} you will get a new instance.\n   *\n   * @example\n   * ```\n   * Registration.instance(Foo, Foo);\n   * ```\n   *\n   * @param key - The key to register the instance type under.\n   * @param value - The class to instantiate each time the key is requested.\n   */\n  transient(key, value) {\n    return new ResolverImpl(key, 2\n    /* transient */\n    , value);\n  },\n\n  /**\n   * Delegates to a callback function to provide the dependency.\n   * Every time you request this {@link Key} the callback will be invoked to provide\n   * the dependency.\n   *\n   * @example\n   * ```\n   * Registration.callback(Foo, () => new Foo());\n   * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - The key to register the callback for.\n   * @param callback - The function that is expected to return the dependency.\n   */\n  callback(key, callback) {\n    return new ResolverImpl(key, 3\n    /* callback */\n    , callback);\n  },\n\n  /**\n   * Delegates to a callback function to provide the dependency and then caches the\n   * dependency for future requests.\n   *\n   * @example\n   * ```\n   * Registration.cachedCallback(Foo, () => new Foo());\n   * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - The key to register the callback for.\n   * @param callback - The function that is expected to return the dependency.\n   * @remarks\n   * If you pass the same Registration to another container, the same cached value will be used.\n   * Should all references to the resolver returned be removed, the cache will expire.\n   */\n  cachedCallback(key, callback) {\n    return new ResolverImpl(key, 3\n    /* callback */\n    , cacheCallbackResult(callback));\n  },\n\n  /**\n   * Creates an alternate {@link Key} to retrieve an instance by.\n   *\n   * @example\n   * ```\n   * Register.singleton(Foo, Foo)\n   * Register.aliasTo(Foo, MyFoos);\n   *\n   * container.getAll(MyFoos) // contains an instance of Foo\n   * ```\n   *\n   * @param originalKey - The original key that has been registered.\n   * @param aliasKey - The alias to the original key.\n   */\n  aliasTo(originalKey, aliasKey) {\n    return new ResolverImpl(aliasKey, 5\n    /* alias */\n    , originalKey);\n  }\n\n});\n/** @internal */\n\nexport function validateKey(key) {\n  if (key === null || key === void 0) {\n    throw new Error(\"key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?\");\n  }\n}\n\nfunction buildAllResponse(resolver, handler, requestor) {\n  if (resolver instanceof ResolverImpl && resolver.strategy === 4\n  /* array */\n  ) {\n    const state = resolver.state;\n    let i = state.length;\n    const results = new Array(i);\n\n    while (i--) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n}\n\nconst defaultFriendlyName = \"(anonymous)\";\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\n\n\nconst isNativeFunction = function () {\n  const lookup = new WeakMap();\n  let isNative = false;\n  let sourceText = \"\";\n  let i = 0;\n  return function (fn) {\n    isNative = lookup.get(fn);\n\n    if (isNative === void 0) {\n      sourceText = fn.toString();\n      i = sourceText.length; // http://www.ecma-international.org/ecma-262/#prod-NativeFunction\n\n      isNative = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string\n      i >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.\n      i <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?\n      sourceText.charCodeAt(i - 1) === 0x7d && // }\n      // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.\n      sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace\n      sourceText.charCodeAt(i - 3) === 0x5d && // ]\n      sourceText.charCodeAt(i - 4) === 0x65 && // e\n      sourceText.charCodeAt(i - 5) === 0x64 && // d\n      sourceText.charCodeAt(i - 6) === 0x6f && // o\n      sourceText.charCodeAt(i - 7) === 0x63 && // c\n      sourceText.charCodeAt(i - 8) === 0x20 && //\n      sourceText.charCodeAt(i - 9) === 0x65 && // e\n      sourceText.charCodeAt(i - 10) === 0x76 && // v\n      sourceText.charCodeAt(i - 11) === 0x69 && // i\n      sourceText.charCodeAt(i - 12) === 0x74 && // t\n      sourceText.charCodeAt(i - 13) === 0x61 && // a\n      sourceText.charCodeAt(i - 14) === 0x6e && // n\n      sourceText.charCodeAt(i - 15) === 0x58; // [\n\n      lookup.set(fn, isNative);\n    }\n\n    return isNative;\n  };\n}();\n\nconst isNumericLookup = {};\n\nfunction isArrayIndex(value) {\n  switch (typeof value) {\n    case \"number\":\n      return value >= 0 && (value | 0) === value;\n\n    case \"string\":\n      {\n        const result = isNumericLookup[value];\n\n        if (result !== void 0) {\n          return result;\n        }\n\n        const length = value.length;\n\n        if (length === 0) {\n          return isNumericLookup[value] = false;\n        }\n\n        let ch = 0;\n\n        for (let i = 0; i < length; ++i) {\n          ch = value.charCodeAt(i);\n\n          if (i === 0 && ch === 0x30 && length > 1\n          /* must not start with 0 */\n          || ch < 0x30\n          /* 0 */\n          || ch > 0x39\n          /* 9 */\n          ) {\n            return isNumericLookup[value] = false;\n          }\n        }\n\n        return isNumericLookup[value] = true;\n      }\n\n    default:\n      return false;\n  }\n}","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/di/di.js"],"names":["emptyArray","FASTElement","metadataByTarget","Map","Reflect","metadata","key","value","target","defineMetadata","get","set","getOwnMetadata","ResolverBuilder","constructor","container","instance","registerResolver","singleton","transient","callback","cachedCallback","cacheCallbackResult","aliasTo","destinationKey","strategy","state","ResolverImpl","cloneArrayWithPossibleProps","source","clone","slice","keys","Object","len","length","i","isArrayIndex","DefaultResolver","freeze","none","Error","toString","ContainerConfiguration","default","parentLocator","responsibleForOwnerRequests","defaultResolver","dependencyLookup","getParamTypes","Type","rootDOMContainer","DI","createContainer","config","ContainerImpl","assign","findResponsibleContainer","node","owned","$$container$$","findParentContainer","event","CustomEvent","DILocateParentEventType","bubbles","composed","cancelable","detail","dispatchEvent","getOrCreateDOMContainer","getDesignParamtypes","getAnnotationParamtypes","getOrCreateAnnotationParamTypes","annotationParamtypes","getDependencies","dependencies","inject","designParamtypes","Proto","getPrototypeOf","Function","prototype","auAnnotationParamtype","defineProperty","propertyName","respectConnection","diPropertyKey","HTMLElement","notifier","$fastController","handleChange","newContainer","newValue","oldValue","notify","subscribe","createInterface","nameConfigOrCallback","configuror","configure","friendlyName","defaultFriendlyName","Interface","property","index","new","undefined","$isInterface","register","descriptor","dep","registration","Registration","registerInRequestor","options","defaultSingletonOptions","scoped","Container","ServiceLocator","createResolver","getter","resolver","$isResolver","resolve","handler","requestor","transientDecorator","singletonDecorator","targetOrOptions","$target","createAllResolver","searchAncestors","all","getAll","lazy","optional","has","ignore","newInstanceForScope","createNewInstance","newInstanceOf","_requestor","getFactory","construct","resolving","name","factory","String","_a","_b","_c","getResolver","call","containerGetKey","d","transformInstance","inst","transform","FactoryImpl","transformers","dynamicDependencies","map","reduce","registerTransformer","transformer","push","containerResolver","isRegistry","obj","isSelfRegistry","isRegisterInRequester","isClass","InstrinsicTypeNames","Set","factories","owner","_parent","registerDepth","context","resolvers","Node","addEventListener","e","composedPath","stopImmediatePropagation","parent","depth","registerWithContext","params","current","j","jj","ii","isObject","validateKey","result","autoRegister","jitRegister","resolutions","concat","buildAllResponse","isNativeFunction","registerFactory","createChild","keyAsValue","registrationResolver","newResolver","cache","WeakMap","fun","t","originalKey","aliasKey","results","Array","lookup","isNative","sourceText","fn","charCodeAt","isNumericLookup","ch"],"mappings":"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","sourcesContent":["/**\n * Big thanks to https://github.com/fkleuver and the https://github.com/aurelia/aurelia project\n * for the bulk of this code and many of the associated tests.\n */\nimport { emptyArray, FASTElement } from \"@microsoft/fast-element\";\n// Tiny polyfill for TypeScript's Reflect metadata API.\nconst metadataByTarget = new Map();\nif (!(\"metadata\" in Reflect)) {\n    Reflect.metadata = function (key, value) {\n        return function (target) {\n            Reflect.defineMetadata(key, value, target);\n        };\n    };\n    Reflect.defineMetadata = function (key, value, target) {\n        let metadata = metadataByTarget.get(target);\n        if (metadata === void 0) {\n            metadataByTarget.set(target, (metadata = new Map()));\n        }\n        metadata.set(key, value);\n    };\n    Reflect.getOwnMetadata = function (key, target) {\n        const metadata = metadataByTarget.get(target);\n        if (metadata !== void 0) {\n            return metadata.get(key);\n        }\n        return void 0;\n    };\n}\n/**\n * A utility class used that constructs and registers resolvers for a dependency\n * injection container. Supports a standard set of object lifetimes.\n * @public\n */\nexport class ResolverBuilder {\n    /**\n     *\n     * @param container - The container to create resolvers for.\n     * @param key - The key to register resolvers under.\n     */\n    constructor(container, key) {\n        this.container = container;\n        this.key = key;\n    }\n    /**\n     * Creates a resolver for an existing object instance.\n     * @param value - The instance to resolve.\n     * @returns The resolver.\n     */\n    instance(value) {\n        return this.registerResolver(0 /* instance */, value);\n    }\n    /**\n     * Creates a resolver that enforces a singleton lifetime.\n     * @param value - The type to create and cache the singleton for.\n     * @returns The resolver.\n     */\n    singleton(value) {\n        return this.registerResolver(1 /* singleton */, value);\n    }\n    /**\n     * Creates a resolver that creates a new instance for every dependency request.\n     * @param value - The type to create instances of.\n     * @returns - The resolver.\n     */\n    transient(value) {\n        return this.registerResolver(2 /* transient */, value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function for every dependency resolution\n     * request, allowing custom logic to return the dependency.\n     * @param value - The callback to call during resolution.\n     * @returns The resolver.\n     */\n    callback(value) {\n        return this.registerResolver(3 /* callback */, value);\n    }\n    /**\n     * Creates a resolver that invokes a callback function the first time that a dependency\n     * resolution is requested. The returned value is then cached and provided for all\n     * subsequent requests.\n     * @param value - The callback to call during the first resolution.\n     * @returns The resolver.\n     */\n    cachedCallback(value) {\n        return this.registerResolver(3 /* callback */, cacheCallbackResult(value));\n    }\n    /**\n     * Aliases the current key to a different key.\n     * @param destinationKey - The key to point the alias to.\n     * @returns The resolver.\n     */\n    aliasTo(destinationKey) {\n        return this.registerResolver(5 /* alias */, destinationKey);\n    }\n    registerResolver(strategy, state) {\n        const { container, key } = this;\n        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n        this.container = this.key = (void 0);\n        return container.registerResolver(key, new ResolverImpl(key, strategy, state));\n    }\n}\nfunction cloneArrayWithPossibleProps(source) {\n    const clone = source.slice();\n    const keys = Object.keys(source);\n    const len = keys.length;\n    let key;\n    for (let i = 0; i < len; ++i) {\n        key = keys[i];\n        if (!isArrayIndex(key)) {\n            clone[key] = source[key];\n        }\n    }\n    return clone;\n}\n/**\n * A set of default resolvers useful in configuring a container.\n * @public\n */\nexport const DefaultResolver = Object.freeze({\n    /**\n     * Disables auto-registration and throws for all un-registered dependencies.\n     * @param key - The key to create the resolver for.\n     */\n    none(key) {\n        throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);\n    },\n    /**\n     * Provides default singleton resolution behavior during auto-registration.\n     * @param key - The key to create the resolver for.\n     * @returns The resolver.\n     */\n    singleton(key) {\n        return new ResolverImpl(key, 1 /* singleton */, key);\n    },\n    /**\n     * Provides default transient resolution behavior during auto-registration.\n     * @param key - The key to create the resolver for.\n     * @returns The resolver.\n     */\n    transient(key) {\n        return new ResolverImpl(key, 2 /* transient */, key);\n    },\n});\n/**\n * Configuration for a dependency injection container.\n * @public\n */\nexport const ContainerConfiguration = Object.freeze({\n    /**\n     * The default configuration used when creating a DOM-disconnected container.\n     * @remarks\n     * The default creates a root container, with no parent container. It does not handle\n     * owner requests and it uses singleton resolution behavior for auto-registration.\n     */\n    default: Object.freeze({\n        parentLocator: () => null,\n        responsibleForOwnerRequests: false,\n        defaultResolver: DefaultResolver.singleton,\n    }),\n});\nconst dependencyLookup = new Map();\nfunction getParamTypes(key) {\n    return (Type) => {\n        return Reflect.getOwnMetadata(key, Type);\n    };\n}\nlet rootDOMContainer = null;\n/**\n * The gateway to dependency injection APIs.\n * @public\n */\nexport const DI = Object.freeze({\n    /**\n     * Creates a new dependency injection container.\n     * @param config - The configuration for the container.\n     * @returns A newly created dependency injection container.\n     */\n    createContainer(config) {\n        return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config));\n    },\n    /**\n     * Finds the dependency injection container responsible for providing dependencies\n     * to the specified node.\n     * @param node - The node to find the responsible container for.\n     * @returns The container responsible for providing dependencies to the node.\n     * @remarks\n     * This will be the same as the parent container if the specified node\n     * does not itself host a container configured with responsibleForOwnerRequests.\n     */\n    findResponsibleContainer(node) {\n        const owned = node.$$container$$;\n        if (owned && owned.responsibleForOwnerRequests) {\n            return owned;\n        }\n        return DI.findParentContainer(node);\n    },\n    /**\n     * Find the dependency injection container up the DOM tree from this node.\n     * @param node - The node to find the parent container for.\n     * @returns The parent container of this node.\n     * @remarks\n     * This will be the same as the responsible container if the specified node\n     * does not itself host a container configured with responsibleForOwnerRequests.\n     */\n    findParentContainer(node) {\n        const event = new CustomEvent(DILocateParentEventType, {\n            bubbles: true,\n            composed: true,\n            cancelable: true,\n            detail: { container: void 0 },\n        });\n        node.dispatchEvent(event);\n        return event.detail.container || DI.getOrCreateDOMContainer();\n    },\n    /**\n     * Returns a dependency injection container if one is explicitly owned by the specified\n     * node. If one is not owned, then a new container is created and assigned to the node.\n     * @param node - The node to find or create the container for.\n     * @param config - The configuration for the container if one needs to be created.\n     * @returns The located or created container.\n     * @remarks\n     * This API does not search for a responsible or parent container. It looks only for a container\n     * directly defined on the specified node and creates one at that location if one does not\n     * already exist.\n     */\n    getOrCreateDOMContainer(node, config) {\n        if (!node) {\n            return (rootDOMContainer ||\n                (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config, {\n                    parentLocator: () => null,\n                }))));\n        }\n        return (node.$$container$$ ||\n            new ContainerImpl(node, Object.assign({}, ContainerConfiguration.default, config, {\n                parentLocator: DI.findParentContainer,\n            })));\n    },\n    /**\n     * Gets the \"design:paramtypes\" metadata for the specified type.\n     * @param Type - The type to get the metadata for.\n     * @returns The metadata array or undefined if no metadata is found.\n     */\n    getDesignParamtypes: getParamTypes(\"design:paramtypes\"),\n    /**\n     * Gets the \"di:paramtypes\" metadata for the specified type.\n     * @param Type - The type to get the metadata for.\n     * @returns The metadata array or undefined if no metadata is found.\n     */\n    getAnnotationParamtypes: getParamTypes(\"di:paramtypes\"),\n    /**\n     *\n     * @param Type - Gets the \"di:paramtypes\" metadata for the specified type. If none is found,\n     * an empty metadata array is created and added.\n     * @returns The metadata array.\n     */\n    getOrCreateAnnotationParamTypes(Type) {\n        let annotationParamtypes = this.getAnnotationParamtypes(Type);\n        if (annotationParamtypes === void 0) {\n            Reflect.defineMetadata(\"di:paramtypes\", (annotationParamtypes = []), Type);\n        }\n        return annotationParamtypes;\n    },\n    /**\n     * Gets the dependency keys representing what is needed to instantiate the specified type.\n     * @param Type - The type to get the dependencies for.\n     * @returns An array of dependency keys.\n     */\n    getDependencies(Type) {\n        // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n        // so be careful with making changes here as it can have a huge impact on complex end user apps.\n        // Preferably, only make changes to the dependency resolution process via a RFC.\n        let dependencies = dependencyLookup.get(Type);\n        if (dependencies === void 0) {\n            // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n            // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n            // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n            // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n            const inject = Type.inject;\n            if (inject === void 0) {\n                // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n                const designParamtypes = DI.getDesignParamtypes(Type);\n                // di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n                const annotationParamtypes = DI.getAnnotationParamtypes(Type);\n                if (designParamtypes === void 0) {\n                    if (annotationParamtypes === void 0) {\n                        // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n                        // there is no sound way to merge a type's deps with its prototype's deps\n                        const Proto = Object.getPrototypeOf(Type);\n                        if (typeof Proto === \"function\" && Proto !== Function.prototype) {\n                            dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));\n                        }\n                        else {\n                            dependencies = [];\n                        }\n                    }\n                    else {\n                        // No design:paramtypes so just use the di:paramtypes\n                        dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n                    }\n                }\n                else if (annotationParamtypes === void 0) {\n                    // No di:paramtypes so just use the design:paramtypes\n                    dependencies = cloneArrayWithPossibleProps(designParamtypes);\n                }\n                else {\n                    // We've got both, so merge them (in case of conflict on same index, di:paramtypes take precedence)\n                    dependencies = cloneArrayWithPossibleProps(designParamtypes);\n                    let len = annotationParamtypes.length;\n                    let auAnnotationParamtype;\n                    for (let i = 0; i < len; ++i) {\n                        auAnnotationParamtype = annotationParamtypes[i];\n                        if (auAnnotationParamtype !== void 0) {\n                            dependencies[i] = auAnnotationParamtype;\n                        }\n                    }\n                    const keys = Object.keys(annotationParamtypes);\n                    len = keys.length;\n                    let key;\n                    for (let i = 0; i < len; ++i) {\n                        key = keys[i];\n                        if (!isArrayIndex(key)) {\n                            dependencies[key] = annotationParamtypes[key];\n                        }\n                    }\n                }\n            }\n            else {\n                // Ignore paramtypes if we have static inject\n                dependencies = cloneArrayWithPossibleProps(inject);\n            }\n            dependencyLookup.set(Type, dependencies);\n        }\n        return dependencies;\n    },\n    /**\n     * Defines a property on a web component class. The value of this property will\n     * be resolved from the dependency injection container responsible for the element\n     * instance, based on where it is connected in the DOM.\n     * @param target - The target to define the property on.\n     * @param propertyName - The name of the property to define.\n     * @param key - The dependency injection key.\n     * @param respectConnection - Indicates whether or not to update the property value if the\n     * hosting component is disconnected and then re-connected at a different location in the DOM.\n     * @remarks\n     * The respectConnection option is only applicable to elements that descend from FASTElement.\n     */\n    defineProperty(target, propertyName, key, respectConnection = false) {\n        const diPropertyKey = `$di_${propertyName}`;\n        Reflect.defineProperty(target, propertyName, {\n            get: function () {\n                let value = this[diPropertyKey];\n                if (value === void 0) {\n                    const container = this instanceof HTMLElement\n                        ? DI.findResponsibleContainer(this)\n                        : DI.getOrCreateDOMContainer();\n                    value = container.get(key);\n                    this[diPropertyKey] = value;\n                    if (respectConnection && this instanceof FASTElement) {\n                        const notifier = this.$fastController;\n                        const handleChange = () => {\n                            const newContainer = DI.findResponsibleContainer(this);\n                            const newValue = newContainer.get(key);\n                            const oldValue = this[diPropertyKey];\n                            if (newValue !== oldValue) {\n                                this[diPropertyKey] = value;\n                                notifier.notify(propertyName);\n                            }\n                        };\n                        notifier.subscribe({ handleChange }, \"isConnected\");\n                    }\n                }\n                return value;\n            },\n        });\n    },\n    /**\n     * Creates a dependency injection key.\n     * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a\n     * default resolution for the dependency.\n     * @param configuror - If a friendly name was provided for the first parameter, then an optional\n     * lambda that configures a default resolution for the dependency can be provided second.\n     * @returns The created key.\n     * @remarks\n     * The created key can be used as a property decorator or constructor parameter decorator,\n     * in addition to its standard use in an inject array or through direct container APIs.\n     */\n    createInterface(nameConfigOrCallback, configuror) {\n        const configure = typeof nameConfigOrCallback === \"function\"\n            ? nameConfigOrCallback\n            : configuror;\n        const friendlyName = typeof nameConfigOrCallback === \"string\"\n            ? nameConfigOrCallback\n            : nameConfigOrCallback && \"friendlyName\" in nameConfigOrCallback\n                ? nameConfigOrCallback.friendlyName || defaultFriendlyName\n                : defaultFriendlyName;\n        const respectConnection = typeof nameConfigOrCallback === \"string\"\n            ? false\n            : nameConfigOrCallback && \"respectConnection\" in nameConfigOrCallback\n                ? nameConfigOrCallback.respectConnection || false\n                : false;\n        const Interface = function (target, property, index) {\n            if (target == null || new.target !== undefined) {\n                throw new Error(`No registration for interface: '${Interface.friendlyName}'`);\n            }\n            if (property) {\n                DI.defineProperty(target, property, Interface, respectConnection);\n            }\n            else {\n                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n                annotationParamtypes[index] = Interface;\n            }\n        };\n        Interface.$isInterface = true;\n        Interface.friendlyName = friendlyName == null ? \"(anonymous)\" : friendlyName;\n        if (configure != null) {\n            Interface.register = function (container, key) {\n                return configure(new ResolverBuilder(container, key !== null && key !== void 0 ? key : Interface));\n            };\n        }\n        Interface.toString = function toString() {\n            return `InterfaceSymbol<${Interface.friendlyName}>`;\n        };\n        return Interface;\n    },\n    /**\n     * A decorator that specifies what to inject into its target.\n     * @param dependencies - The dependencies to inject.\n     * @returns The decorator to be applied to the target class.\n     * @remarks\n     * The decorator can be used to decorate a class, listing all of the classes dependencies.\n     * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n     * parameter.\n     * Or it can be used for a web component property, indicating what that property should resolve to.\n     */\n    inject(...dependencies) {\n        return function (target, key, descriptor) {\n            if (typeof descriptor === \"number\") {\n                // It's a parameter decorator.\n                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);\n                const dep = dependencies[0];\n                if (dep !== void 0) {\n                    annotationParamtypes[descriptor] = dep;\n                }\n            }\n            else if (key) {\n                DI.defineProperty(target, key, dependencies[0]);\n            }\n            else {\n                const annotationParamtypes = descriptor\n                    ? DI.getOrCreateAnnotationParamTypes(descriptor.value)\n                    : DI.getOrCreateAnnotationParamTypes(target);\n                let dep;\n                for (let i = 0; i < dependencies.length; ++i) {\n                    dep = dependencies[i];\n                    if (dep !== void 0) {\n                        annotationParamtypes[i] = dep;\n                    }\n                }\n            }\n        };\n    },\n    /**\n     * Registers the `target` class as a transient dependency; each time the dependency is resolved\n     * a new instance will be created.\n     *\n     * @param target - The class / constructor function to register as transient.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     *\n     * @example\n     * On an existing class\n     * ```ts\n     * class Foo { }\n     * DI.transient(Foo);\n     * ```\n     *\n     * @example\n     * Inline declaration\n     *\n     * ```ts\n     * const Foo = DI.transient(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     *\n     * @public\n     */\n    transient(target) {\n        target.register = function register(container) {\n            const registration = Registration.transient(target, target);\n            return registration.register(container);\n        };\n        target.registerInRequestor = false;\n        return target;\n    },\n    /**\n     * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n     * consecutive time the dependency is resolved, the same instance will be returned.\n     *\n     * @param target - The class / constructor function to register as a singleton.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     * @example\n     * On an existing class\n     * ```ts\n     * class Foo { }\n     * DI.singleton(Foo);\n     * ```\n     *\n     * @example\n     * Inline declaration\n     * ```ts\n     * const Foo = DI.singleton(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     *\n     * @public\n     */\n    singleton(target, options = defaultSingletonOptions) {\n        target.register = function register(container) {\n            const registration = Registration.singleton(target, target);\n            return registration.register(container);\n        };\n        target.registerInRequestor = options.scoped;\n        return target;\n    },\n});\n/**\n * The interface key that resolves the dependency injection container itself.\n * @public\n */\nexport const Container = DI.createInterface(\"Container\");\n/**\n * The interface key that resolves the service locator itself.\n * @public\n */\nexport const ServiceLocator = Container;\nfunction createResolver(getter) {\n    return function (key) {\n        const resolver = function (target, property, descriptor) {\n            DI.inject(resolver)(target, property, descriptor);\n        };\n        resolver.$isResolver = true;\n        resolver.resolve = function (handler, requestor) {\n            return getter(key, handler, requestor);\n        };\n        return resolver;\n    };\n}\n/**\n * A decorator that specifies what to inject into its target.\n * @param dependencies - The dependencies to inject.\n * @returns The decorator to be applied to the target class.\n * @remarks\n * The decorator can be used to decorate a class, listing all of the classes dependencies.\n * Or it can be used to decorate a constructor paramter, indicating what to inject for that\n * parameter.\n * Or it can be used for a web component property, indicating what that property should resolve to.\n *\n * @public\n */\nexport const inject = DI.inject;\nfunction transientDecorator(target) {\n    return DI.transient(target);\n}\nexport function transient(target) {\n    return target == null ? transientDecorator : transientDecorator(target);\n}\nconst defaultSingletonOptions = { scoped: false };\nfunction singletonDecorator(target) {\n    return DI.singleton(target);\n}\n/**\n * @public\n */\nexport function singleton(targetOrOptions) {\n    if (typeof targetOrOptions === \"function\") {\n        return DI.singleton(targetOrOptions);\n    }\n    return function ($target) {\n        return DI.singleton($target, targetOrOptions);\n    };\n}\nfunction createAllResolver(getter) {\n    return function (key, searchAncestors) {\n        searchAncestors = !!searchAncestors;\n        const resolver = function (target, property, descriptor) {\n            DI.inject(resolver)(target, property, descriptor);\n        };\n        resolver.$isResolver = true;\n        resolver.resolve = function (handler, requestor) {\n            /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n            return getter(key, handler, requestor, searchAncestors);\n        };\n        return resolver;\n    };\n}\n/**\n * A decorator and DI resolver that will resolve an array of all dependencies\n * registered with the specified key.\n * @param key - The key to resolve all dependencies for.\n * @param searchAncestors - [optional] Indicates whether to search ancestor containers.\n * @public\n */\nexport const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));\n/**\n * A decorator that lazily injects a dependency depending on whether the `Key` is present at the time of function call.\n *\n * @example\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method.\n * @example\n * This, would give you a new 'Math.random()' number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n *\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * @param key - The key to lazily resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\nexport const lazy = createResolver((key, handler, requestor) => {\n    return () => requestor.get(key);\n});\n/**\n * A decorator that allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example:\n * @example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n *\n * @example\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so remember to mark your input type as\n * possibly `undefined`!\n *\n * @param key - The key to optionally resolve.\n * see {@link DI.createInterface} on interactions with interfaces\n *\n * @public\n */\nexport const optional = createResolver((key, handler, requestor) => {\n    if (requestor.has(key, true)) {\n        return requestor.get(key);\n    }\n    else {\n        return undefined;\n    }\n});\n/**\n * A decorator that tells the container not to try to inject a dependency.\n *\n * @public\n */\nexport function ignore(target, property, descriptor) {\n    DI.inject(ignore)(target, property, descriptor);\n}\n// Hack: casting below used to prevent TS from generate a namespace which can't be commented\n// and results in documentation validation errors.\nignore.$isResolver = true;\nignore.resolve = () => undefined;\n/**\n * A decorator that indicates that a new instance should be injected scoped to the\n * container that requested the instance.\n * @param key - The dependency key for the new instance.\n * @remarks\n * This creates a resolver with an instance strategy pointing to the new instance, effectively\n * making this a singleton, scoped to the container or DOM's subtree.\n *\n * @public\n */\nexport const newInstanceForScope = createResolver((key, handler, requestor) => {\n    const instance = createNewInstance(key, handler);\n    const resolver = new ResolverImpl(key, 0 /* instance */, instance);\n    requestor.registerResolver(key, resolver);\n    return instance;\n});\n/**\n * A decorator that indicates that a new instance should be injected.\n * @param key - The dependency key for the new instance.\n * @remarks\n * The instance is not internally cached with a resolver as newInstanceForScope does.\n *\n * @public\n */\nexport const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));\nfunction createNewInstance(key, handler) {\n    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n    return handler.getFactory(key).construct(handler);\n}\n/** @internal */\nexport class ResolverImpl {\n    constructor(key, strategy, state) {\n        this.key = key;\n        this.strategy = strategy;\n        this.state = state;\n        this.resolving = false;\n    }\n    get $isResolver() {\n        return true;\n    }\n    register(container) {\n        return container.registerResolver(this.key, this);\n    }\n    resolve(handler, requestor) {\n        switch (this.strategy) {\n            case 0 /* instance */:\n                return this.state;\n            case 1 /* singleton */: {\n                if (this.resolving) {\n                    throw new Error(`Cyclic dependency found: ${this.state.name}`);\n                }\n                this.resolving = true;\n                this.state = handler\n                    .getFactory(this.state)\n                    .construct(requestor);\n                this.strategy = 0 /* instance */;\n                this.resolving = false;\n                return this.state;\n            }\n            case 2 /* transient */: {\n                // Always create transients from the requesting container\n                const factory = handler.getFactory(this.state);\n                if (factory === null) {\n                    throw new Error(`Resolver for ${String(this.key)} returned a null factory`);\n                }\n                return factory.construct(requestor);\n            }\n            case 3 /* callback */:\n                return this.state(handler, requestor, this);\n            case 4 /* array */:\n                return this.state[0].resolve(handler, requestor);\n            case 5 /* alias */:\n                return requestor.get(this.state);\n            default:\n                throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);\n        }\n    }\n    getFactory(container) {\n        var _a, _b, _c;\n        switch (this.strategy) {\n            case 1 /* singleton */:\n            case 2 /* transient */:\n                return container.getFactory(this.state);\n            case 5 /* alias */:\n                return (_c = (_b = (_a = container.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container)) !== null && _c !== void 0 ? _c : null;\n            default:\n                return null;\n        }\n    }\n}\nfunction containerGetKey(d) {\n    return this.get(d);\n}\nfunction transformInstance(inst, transform) {\n    return transform(inst);\n}\n/** @internal */\nexport class FactoryImpl {\n    constructor(Type, dependencies) {\n        this.Type = Type;\n        this.dependencies = dependencies;\n        this.transformers = null;\n    }\n    construct(container, dynamicDependencies) {\n        let instance;\n        if (dynamicDependencies === void 0) {\n            instance = new this.Type(...this.dependencies.map(containerGetKey, container));\n        }\n        else {\n            instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);\n        }\n        if (this.transformers == null) {\n            return instance;\n        }\n        return this.transformers.reduce(transformInstance, instance);\n    }\n    registerTransformer(transformer) {\n        (this.transformers || (this.transformers = [])).push(transformer);\n    }\n}\nconst containerResolver = {\n    $isResolver: true,\n    resolve(handler, requestor) {\n        return requestor;\n    },\n};\nfunction isRegistry(obj) {\n    return typeof obj.register === \"function\";\n}\nfunction isSelfRegistry(obj) {\n    return isRegistry(obj) && typeof obj.registerInRequestor === \"boolean\";\n}\nfunction isRegisterInRequester(obj) {\n    return isSelfRegistry(obj) && obj.registerInRequestor;\n}\nfunction isClass(obj) {\n    return obj.prototype !== void 0;\n}\nconst InstrinsicTypeNames = new Set([\n    \"Array\",\n    \"ArrayBuffer\",\n    \"Boolean\",\n    \"DataView\",\n    \"Date\",\n    \"Error\",\n    \"EvalError\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Function\",\n    \"Int8Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Map\",\n    \"Number\",\n    \"Object\",\n    \"Promise\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"RegExp\",\n    \"Set\",\n    \"SharedArrayBuffer\",\n    \"String\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"URIError\",\n    \"WeakMap\",\n    \"WeakSet\",\n]);\nconst DILocateParentEventType = \"__DI_LOCATE_PARENT__\";\nconst factories = new Map();\n/**\n * @internal\n */\nexport class ContainerImpl {\n    constructor(owner, config) {\n        this.owner = owner;\n        this.config = config;\n        this._parent = void 0;\n        this.registerDepth = 0;\n        this.context = null;\n        if (owner !== null) {\n            owner.$$container$$ = this;\n        }\n        this.resolvers = new Map();\n        this.resolvers.set(Container, containerResolver);\n        if (owner instanceof Node) {\n            owner.addEventListener(DILocateParentEventType, (e) => {\n                if (e.composedPath()[0] !== this.owner) {\n                    e.detail.container = this;\n                    e.stopImmediatePropagation();\n                }\n            });\n        }\n    }\n    get parent() {\n        if (this._parent === void 0) {\n            this._parent = this.config.parentLocator(this.owner);\n        }\n        return this._parent;\n    }\n    get depth() {\n        return this.parent === null ? 0 : this.parent.depth + 1;\n    }\n    get responsibleForOwnerRequests() {\n        return this.config.responsibleForOwnerRequests;\n    }\n    registerWithContext(context, ...params) {\n        this.context = context;\n        this.register(...params);\n        this.context = null;\n        return this;\n    }\n    register(...params) {\n        if (++this.registerDepth === 100) {\n            throw new Error(\"Unable to autoregister dependency\");\n            // Most likely cause is trying to register a plain object that does not have a\n            // register method and is not a class constructor\n        }\n        let current;\n        let keys;\n        let value;\n        let j;\n        let jj;\n        const context = this.context;\n        for (let i = 0, ii = params.length; i < ii; ++i) {\n            current = params[i];\n            if (!isObject(current)) {\n                continue;\n            }\n            if (isRegistry(current)) {\n                current.register(this, context);\n            }\n            else if (isClass(current)) {\n                Registration.singleton(current, current).register(this);\n            }\n            else {\n                keys = Object.keys(current);\n                j = 0;\n                jj = keys.length;\n                for (; j < jj; ++j) {\n                    value = current[keys[j]];\n                    if (!isObject(value)) {\n                        continue;\n                    }\n                    // note: we could remove this if-branch and call this.register directly\n                    // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n                    if (isRegistry(value)) {\n                        value.register(this, context);\n                    }\n                    else {\n                        this.register(value);\n                    }\n                }\n            }\n        }\n        --this.registerDepth;\n        return this;\n    }\n    registerResolver(key, resolver) {\n        validateKey(key);\n        const resolvers = this.resolvers;\n        const result = resolvers.get(key);\n        if (result == null) {\n            resolvers.set(key, resolver);\n        }\n        else if (result instanceof ResolverImpl &&\n            result.strategy === 4 /* array */) {\n            result.state.push(resolver);\n        }\n        else {\n            resolvers.set(key, new ResolverImpl(key, 4 /* array */, [result, resolver]));\n        }\n        return resolver;\n    }\n    registerTransformer(key, transformer) {\n        const resolver = this.getResolver(key);\n        if (resolver == null) {\n            return false;\n        }\n        if (resolver.getFactory) {\n            const factory = resolver.getFactory(this);\n            if (factory == null) {\n                return false;\n            }\n            // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n            // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n            // type Constructable. So the return type of that optional method has this additional constraint, which\n            // seems to confuse the type checker.\n            factory.registerTransformer(transformer);\n            return true;\n        }\n        return false;\n    }\n    getResolver(key, autoRegister = true) {\n        validateKey(key);\n        if (key.resolve !== void 0) {\n            return key;\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        let current = this;\n        let resolver;\n        while (current != null) {\n            resolver = current.resolvers.get(key);\n            if (resolver == null) {\n                if (current.parent == null) {\n                    const handler = isRegisterInRequester(key)\n                        ? this\n                        : current;\n                    return autoRegister ? this.jitRegister(key, handler) : null;\n                }\n                current = current.parent;\n            }\n            else {\n                return resolver;\n            }\n        }\n        return null;\n    }\n    has(key, searchAncestors = false) {\n        return this.resolvers.has(key)\n            ? true\n            : searchAncestors && this.parent != null\n                ? this.parent.has(key, true)\n                : false;\n    }\n    get(key) {\n        validateKey(key);\n        if (key.$isResolver) {\n            return key.resolve(this, this);\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        let current = this;\n        let resolver;\n        while (current != null) {\n            resolver = current.resolvers.get(key);\n            if (resolver == null) {\n                if (current.parent == null) {\n                    const handler = isRegisterInRequester(key)\n                        ? this\n                        : current;\n                    resolver = this.jitRegister(key, handler);\n                    return resolver.resolve(current, this);\n                }\n                current = current.parent;\n            }\n            else {\n                return resolver.resolve(current, this);\n            }\n        }\n        throw new Error(`Unable to resolve key: ${key}`);\n    }\n    getAll(key, searchAncestors = false) {\n        validateKey(key);\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */\n        const requestor = this;\n        let current = requestor;\n        let resolver;\n        if (searchAncestors) {\n            let resolutions = emptyArray;\n            while (current != null) {\n                resolver = current.resolvers.get(key);\n                if (resolver != null) {\n                    resolutions = resolutions.concat(\n                    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n                    buildAllResponse(resolver, current, requestor));\n                }\n                current = current.parent;\n            }\n            return resolutions;\n        }\n        else {\n            while (current != null) {\n                resolver = current.resolvers.get(key);\n                if (resolver == null) {\n                    current = current.parent;\n                    if (current == null) {\n                        return emptyArray;\n                    }\n                }\n                else {\n                    return buildAllResponse(resolver, current, requestor);\n                }\n            }\n        }\n        return emptyArray;\n    }\n    getFactory(Type) {\n        let factory = factories.get(Type);\n        if (factory === void 0) {\n            if (isNativeFunction(Type)) {\n                throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);\n            }\n            factories.set(Type, (factory = new FactoryImpl(Type, DI.getDependencies(Type))));\n        }\n        return factory;\n    }\n    registerFactory(key, factory) {\n        factories.set(key, factory);\n    }\n    createChild(config) {\n        return new ContainerImpl(null, Object.assign({}, this.config, config, { parentLocator: () => this }));\n    }\n    jitRegister(keyAsValue, handler) {\n        if (typeof keyAsValue !== \"function\") {\n            throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);\n        }\n        if (InstrinsicTypeNames.has(keyAsValue.name)) {\n            throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);\n        }\n        if (isRegistry(keyAsValue)) {\n            const registrationResolver = keyAsValue.register(handler);\n            if (!(registrationResolver instanceof Object) ||\n                registrationResolver.resolve == null) {\n                const newResolver = handler.resolvers.get(keyAsValue);\n                if (newResolver != void 0) {\n                    return newResolver;\n                }\n                throw new Error(\"A valid resolver was not returned from the static register method\");\n            }\n            return registrationResolver;\n        }\n        else if (keyAsValue.$isInterface) {\n            throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);\n        }\n        else {\n            const resolver = this.config.defaultResolver(keyAsValue, handler);\n            handler.resolvers.set(keyAsValue, resolver);\n            return resolver;\n        }\n    }\n}\nconst cache = new WeakMap();\nfunction cacheCallbackResult(fun) {\n    return function (handler, requestor, resolver) {\n        if (cache.has(resolver)) {\n            return cache.get(resolver);\n        }\n        const t = fun(handler, requestor, resolver);\n        cache.set(resolver, t);\n        return t;\n    };\n}\n/**\n * You can use the resulting Registration of any of the factory methods\n * to register with the container.\n *\n * @example\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n *\n * @public\n */\nexport const Registration = Object.freeze({\n    /**\n     * Allows you to pass an instance.\n     * Every time you request this {@link Key} you will get this instance back.\n     *\n     * @example\n     * ```\n     * Registration.instance(Foo, new Foo()));\n     * ```\n     *\n     * @param key - The key to register the instance under.\n     * @param value - The instance to return when the key is requested.\n     */\n    instance(key, value) {\n        return new ResolverImpl(key, 0 /* instance */, value);\n    },\n    /**\n     * Creates an instance from the class.\n     * Every time you request this {@link Key} you will get the same one back.\n     *\n     * @example\n     * ```\n     * Registration.singleton(Foo, Foo);\n     * ```\n     *\n     * @param key - The key to register the singleton under.\n     * @param value - The class to instantiate as a singleton when first requested.\n     */\n    singleton(key, value) {\n        return new ResolverImpl(key, 1 /* singleton */, value);\n    },\n    /**\n     * Creates an instance from a class.\n     * Every time you request this {@link Key} you will get a new instance.\n     *\n     * @example\n     * ```\n     * Registration.instance(Foo, Foo);\n     * ```\n     *\n     * @param key - The key to register the instance type under.\n     * @param value - The class to instantiate each time the key is requested.\n     */\n    transient(key, value) {\n        return new ResolverImpl(key, 2 /* transient */, value);\n    },\n    /**\n     * Delegates to a callback function to provide the dependency.\n     * Every time you request this {@link Key} the callback will be invoked to provide\n     * the dependency.\n     *\n     * @example\n     * ```\n     * Registration.callback(Foo, () => new Foo());\n     * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));\n     * ```\n     *\n     * @param key - The key to register the callback for.\n     * @param callback - The function that is expected to return the dependency.\n     */\n    callback(key, callback) {\n        return new ResolverImpl(key, 3 /* callback */, callback);\n    },\n    /**\n     * Delegates to a callback function to provide the dependency and then caches the\n     * dependency for future requests.\n     *\n     * @example\n     * ```\n     * Registration.cachedCallback(Foo, () => new Foo());\n     * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));\n     * ```\n     *\n     * @param key - The key to register the callback for.\n     * @param callback - The function that is expected to return the dependency.\n     * @remarks\n     * If you pass the same Registration to another container, the same cached value will be used.\n     * Should all references to the resolver returned be removed, the cache will expire.\n     */\n    cachedCallback(key, callback) {\n        return new ResolverImpl(key, 3 /* callback */, cacheCallbackResult(callback));\n    },\n    /**\n     * Creates an alternate {@link Key} to retrieve an instance by.\n     *\n     * @example\n     * ```\n     * Register.singleton(Foo, Foo)\n     * Register.aliasTo(Foo, MyFoos);\n     *\n     * container.getAll(MyFoos) // contains an instance of Foo\n     * ```\n     *\n     * @param originalKey - The original key that has been registered.\n     * @param aliasKey - The alias to the original key.\n     */\n    aliasTo(originalKey, aliasKey) {\n        return new ResolverImpl(aliasKey, 5 /* alias */, originalKey);\n    },\n});\n/** @internal */\nexport function validateKey(key) {\n    if (key === null || key === void 0) {\n        throw new Error(\"key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?\");\n    }\n}\nfunction buildAllResponse(resolver, handler, requestor) {\n    if (resolver instanceof ResolverImpl &&\n        resolver.strategy === 4 /* array */) {\n        const state = resolver.state;\n        let i = state.length;\n        const results = new Array(i);\n        while (i--) {\n            results[i] = state[i].resolve(handler, requestor);\n        }\n        return results;\n    }\n    return [resolver.resolve(handler, requestor)];\n}\nconst defaultFriendlyName = \"(anonymous)\";\nfunction isObject(value) {\n    return (typeof value === \"object\" && value !== null) || typeof value === \"function\";\n}\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\nconst isNativeFunction = (function () {\n    const lookup = new WeakMap();\n    let isNative = false;\n    let sourceText = \"\";\n    let i = 0;\n    return function (fn) {\n        isNative = lookup.get(fn);\n        if (isNative === void 0) {\n            sourceText = fn.toString();\n            i = sourceText.length;\n            // http://www.ecma-international.org/ecma-262/#prod-NativeFunction\n            isNative =\n                // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string\n                i >= 29 &&\n                    // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.\n                    i <= 100 &&\n                    // This whole heuristic *could* be tricked by a comment. Do we need to care about that?\n                    sourceText.charCodeAt(i - 1) === 0x7d && // }\n                    // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.\n                    sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace\n                    sourceText.charCodeAt(i - 3) === 0x5d && // ]\n                    sourceText.charCodeAt(i - 4) === 0x65 && // e\n                    sourceText.charCodeAt(i - 5) === 0x64 && // d\n                    sourceText.charCodeAt(i - 6) === 0x6f && // o\n                    sourceText.charCodeAt(i - 7) === 0x63 && // c\n                    sourceText.charCodeAt(i - 8) === 0x20 && //\n                    sourceText.charCodeAt(i - 9) === 0x65 && // e\n                    sourceText.charCodeAt(i - 10) === 0x76 && // v\n                    sourceText.charCodeAt(i - 11) === 0x69 && // i\n                    sourceText.charCodeAt(i - 12) === 0x74 && // t\n                    sourceText.charCodeAt(i - 13) === 0x61 && // a\n                    sourceText.charCodeAt(i - 14) === 0x6e && // n\n                    sourceText.charCodeAt(i - 15) === 0x58; // [\n            lookup.set(fn, isNative);\n        }\n        return isNative;\n    };\n})();\nconst isNumericLookup = {};\nfunction isArrayIndex(value) {\n    switch (typeof value) {\n        case \"number\":\n            return value >= 0 && (value | 0) === value;\n        case \"string\": {\n            const result = isNumericLookup[value];\n            if (result !== void 0) {\n                return result;\n            }\n            const length = value.length;\n            if (length === 0) {\n                return (isNumericLookup[value] = false);\n            }\n            let ch = 0;\n            for (let i = 0; i < length; ++i) {\n                ch = value.charCodeAt(i);\n                if ((i === 0 && ch === 0x30 && length > 1) /* must not start with 0 */ ||\n                    ch < 0x30 /* 0 */ ||\n                    ch > 0x39 /* 9 */) {\n                    return (isNumericLookup[value] = false);\n                }\n            }\n            return (isNumericLookup[value] = true);\n        }\n        default:\n            return false;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}