{"ast":null,"code":"/**\n * Ensures that an input number does not exceed a max value and is not less than a min value.\n * @param i - the number to clamp\n * @param min - the maximum (inclusive) value\n * @param max - the minimum (inclusive) value\n * @public\n */\nexport function clamp(i, min, max) {\n  if (isNaN(i) || i <= min) {\n    return min;\n  } else if (i >= max) {\n    return max;\n  }\n\n  return i;\n}\n/**\n * Scales an input to a number between 0 and 1\n * @param i - a number between min and max\n * @param min - the max value\n * @param max - the min value\n * @public\n */\n\nexport function normalize(i, min, max) {\n  if (isNaN(i) || i <= min) {\n    return 0.0;\n  } else if (i >= max) {\n    return 1.0;\n  }\n\n  return i / (max - min);\n}\n/**\n * Scales a number between 0 and 1\n * @param i - the number to denormalize\n * @param min - the min value\n * @param max - the max value\n * @public\n */\n\nexport function denormalize(i, min, max) {\n  if (isNaN(i)) {\n    return min;\n  }\n\n  return min + i * (max - min);\n}\n/**\n * Converts degrees to radians.\n * @param i - degrees\n * @public\n */\n\nexport function degreesToRadians(i) {\n  return i * (Math.PI / 180.0);\n}\n/**\n * Converts radians to degrees.\n * @param i - radians\n * @public\n */\n\nexport function radiansToDegrees(i) {\n  return i * (180.0 / Math.PI);\n}\n/**\n * Converts a number between 0 and 255 to a hex string.\n * @param i - the number to convert to a hex string\n * @public\n */\n\nexport function getHexStringForByte(i) {\n  const s = Math.round(clamp(i, 0.0, 255.0)).toString(16);\n\n  if (s.length === 1) {\n    return \"0\" + s;\n  }\n\n  return s;\n}\n/**\n * Linearly interpolate\n * @public\n */\n\nexport function lerp(i, min, max) {\n  if (isNaN(i) || i <= 0.0) {\n    return min;\n  } else if (i >= 1.0) {\n    return max;\n  }\n\n  return min + i * (max - min);\n}\n/**\n * Linearly interpolate angles in degrees\n * @public\n */\n\nexport function lerpAnglesInDegrees(i, min, max) {\n  if (i <= 0.0) {\n    return min % 360.0;\n  } else if (i >= 1.0) {\n    return max % 360.0;\n  }\n\n  const a = (min - max + 360.0) % 360.0;\n  const b = (max - min + 360.0) % 360.0;\n\n  if (a <= b) {\n    return (min - a * i + 360.0) % 360.0;\n  }\n\n  return (min + a * i + 360.0) % 360.0;\n}\nconst TwoPI = Math.PI * 2;\n/**\n * Linearly interpolate angles in radians\n * @public\n */\n\nexport function lerpAnglesInRadians(i, min, max) {\n  if (isNaN(i) || i <= 0.0) {\n    return min % TwoPI;\n  } else if (i >= 1.0) {\n    return max % TwoPI;\n  }\n\n  const a = (min - max + TwoPI) % TwoPI;\n  const b = (max - min + TwoPI) % TwoPI;\n\n  if (a <= b) {\n    return (min - a * i + TwoPI) % TwoPI;\n  }\n\n  return (min + a * i + TwoPI) % TwoPI;\n}\n/**\n *\n * Will return infinity if i*10^(precision) overflows number\n * note that floating point rounding rules come into play here\n * so values that end up rounding on a .5 round to the nearest\n * even not always up so 2.5 rounds to 2\n * @param i - the number to round\n * @param precision - the precision to round to\n *\n * @public\n */\n\nexport function roundToPrecisionSmall(i, precision) {\n  const factor = Math.pow(10, precision);\n  return Math.round(i * factor) / factor;\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-colors/dist/math-utilities.js"],"names":["clamp","i","min","max","isNaN","normalize","denormalize","degreesToRadians","Math","PI","radiansToDegrees","getHexStringForByte","s","round","toString","length","lerp","lerpAnglesInDegrees","a","b","TwoPI","lerpAnglesInRadians","roundToPrecisionSmall","precision","factor","pow"],"mappings":"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","sourcesContent":["/**\n * Ensures that an input number does not exceed a max value and is not less than a min value.\n * @param i - the number to clamp\n * @param min - the maximum (inclusive) value\n * @param max - the minimum (inclusive) value\n * @public\n */\nexport function clamp(i, min, max) {\n    if (isNaN(i) || i <= min) {\n        return min;\n    }\n    else if (i >= max) {\n        return max;\n    }\n    return i;\n}\n/**\n * Scales an input to a number between 0 and 1\n * @param i - a number between min and max\n * @param min - the max value\n * @param max - the min value\n * @public\n */\nexport function normalize(i, min, max) {\n    if (isNaN(i) || i <= min) {\n        return 0.0;\n    }\n    else if (i >= max) {\n        return 1.0;\n    }\n    return i / (max - min);\n}\n/**\n * Scales a number between 0 and 1\n * @param i - the number to denormalize\n * @param min - the min value\n * @param max - the max value\n * @public\n */\nexport function denormalize(i, min, max) {\n    if (isNaN(i)) {\n        return min;\n    }\n    return min + i * (max - min);\n}\n/**\n * Converts degrees to radians.\n * @param i - degrees\n * @public\n */\nexport function degreesToRadians(i) {\n    return i * (Math.PI / 180.0);\n}\n/**\n * Converts radians to degrees.\n * @param i - radians\n * @public\n */\nexport function radiansToDegrees(i) {\n    return i * (180.0 / Math.PI);\n}\n/**\n * Converts a number between 0 and 255 to a hex string.\n * @param i - the number to convert to a hex string\n * @public\n */\nexport function getHexStringForByte(i) {\n    const s = Math.round(clamp(i, 0.0, 255.0)).toString(16);\n    if (s.length === 1) {\n        return \"0\" + s;\n    }\n    return s;\n}\n/**\n * Linearly interpolate\n * @public\n */\nexport function lerp(i, min, max) {\n    if (isNaN(i) || i <= 0.0) {\n        return min;\n    }\n    else if (i >= 1.0) {\n        return max;\n    }\n    return min + i * (max - min);\n}\n/**\n * Linearly interpolate angles in degrees\n * @public\n */\nexport function lerpAnglesInDegrees(i, min, max) {\n    if (i <= 0.0) {\n        return min % 360.0;\n    }\n    else if (i >= 1.0) {\n        return max % 360.0;\n    }\n    const a = (min - max + 360.0) % 360.0;\n    const b = (max - min + 360.0) % 360.0;\n    if (a <= b) {\n        return (min - a * i + 360.0) % 360.0;\n    }\n    return (min + a * i + 360.0) % 360.0;\n}\nconst TwoPI = Math.PI * 2;\n/**\n * Linearly interpolate angles in radians\n * @public\n */\nexport function lerpAnglesInRadians(i, min, max) {\n    if (isNaN(i) || i <= 0.0) {\n        return min % TwoPI;\n    }\n    else if (i >= 1.0) {\n        return max % TwoPI;\n    }\n    const a = (min - max + TwoPI) % TwoPI;\n    const b = (max - min + TwoPI) % TwoPI;\n    if (a <= b) {\n        return (min - a * i + TwoPI) % TwoPI;\n    }\n    return (min + a * i + TwoPI) % TwoPI;\n}\n/**\n *\n * Will return infinity if i*10^(precision) overflows number\n * note that floating point rounding rules come into play here\n * so values that end up rounding on a .5 round to the nearest\n * even not always up so 2.5 rounds to 2\n * @param i - the number to round\n * @param precision - the precision to round to\n *\n * @public\n */\nexport function roundToPrecisionSmall(i, precision) {\n    const factor = Math.pow(10, precision);\n    return Math.round(i * factor) / factor;\n}\n"]},"metadata":{},"sourceType":"module"}