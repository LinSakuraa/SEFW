{"ast":null,"code":"export function getKey(option) {\n  if (getIsGroup(option)) {\n    return option.name || option.key || 'key-required';\n  }\n\n  return option.value;\n}\nexport function getIsGroup(option) {\n  return option.type === 'group';\n}\nexport function getIgnored(option) {\n  return option.type === 'ignored';\n}\nexport const tmOptions = {\n  getKey,\n  getIsGroup,\n  getIgnored\n};\nexport function patternMatched(pattern, value) {\n  try {\n    return !!(1 + value.toString().toLowerCase().indexOf(pattern.trim().toLowerCase()));\n  } catch (err) {\n    return false;\n  }\n}\nexport function filterOptions(originalOpts, filter, pattern) {\n  if (!filter) return originalOpts;\n\n  function traverse(options) {\n    if (!Array.isArray(options)) return [];\n    const filteredOptions = [];\n\n    for (const option of options) {\n      if (getIsGroup(option)) {\n        const children = traverse(option.children);\n\n        if (children.length) {\n          filteredOptions.push(Object.assign({}, option, {\n            children\n          }));\n        }\n      } else if (getIgnored(option)) {\n        continue;\n      } else if (filter(pattern, option)) {\n        filteredOptions.push(option);\n      }\n    }\n\n    return filteredOptions;\n  }\n\n  return traverse(originalOpts);\n}\nexport function createValOptMap(options) {\n  const valOptMap = new Map();\n  options.forEach(option => {\n    if (getIsGroup(option)) {\n      ;\n      option.children.forEach(SelectGroupOption => {\n        valOptMap.set(SelectGroupOption.value, SelectGroupOption);\n      });\n    } else {\n      valOptMap.set(option.value, option);\n    }\n  });\n  return valOptMap;\n}\nexport function defaultFilter(pattern, option) {\n  if (!option) return false;\n\n  if (typeof option.label === 'string') {\n    return patternMatched(pattern, option.label);\n  } else if (option.value !== undefined) {\n    return patternMatched(pattern, String(option.value));\n  }\n\n  return false;\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/select/src/utils.js"],"names":["getKey","option","getIsGroup","name","key","value","type","getIgnored","tmOptions","patternMatched","pattern","toString","toLowerCase","indexOf","trim","err","filterOptions","originalOpts","filter","traverse","options","Array","isArray","filteredOptions","children","length","push","Object","assign","createValOptMap","valOptMap","Map","forEach","SelectGroupOption","set","defaultFilter","label","undefined","String"],"mappings":"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","sourcesContent":["export function getKey(option) {\n    if (getIsGroup(option)) {\n        return (option.name ||\n            option.key ||\n            'key-required');\n    }\n    return option.value;\n}\nexport function getIsGroup(option) {\n    return option.type === 'group';\n}\nexport function getIgnored(option) {\n    return option.type === 'ignored';\n}\nexport const tmOptions = {\n    getKey,\n    getIsGroup,\n    getIgnored\n};\nexport function patternMatched(pattern, value) {\n    try {\n        return !!(1 + value.toString().toLowerCase().indexOf(pattern.trim().toLowerCase()));\n    }\n    catch (err) {\n        return false;\n    }\n}\nexport function filterOptions(originalOpts, filter, pattern) {\n    if (!filter)\n        return originalOpts;\n    function traverse(options) {\n        if (!Array.isArray(options))\n            return [];\n        const filteredOptions = [];\n        for (const option of options) {\n            if (getIsGroup(option)) {\n                const children = traverse(option.children);\n                if (children.length) {\n                    filteredOptions.push(Object.assign({}, option, {\n                        children\n                    }));\n                }\n            }\n            else if (getIgnored(option)) {\n                continue;\n            }\n            else if (filter(pattern, option)) {\n                filteredOptions.push(option);\n            }\n        }\n        return filteredOptions;\n    }\n    return traverse(originalOpts);\n}\nexport function createValOptMap(options) {\n    const valOptMap = new Map();\n    options.forEach((option) => {\n        if (getIsGroup(option)) {\n            ;\n            option.children.forEach((SelectGroupOption) => {\n                valOptMap.set(SelectGroupOption.value, SelectGroupOption);\n            });\n        }\n        else {\n            valOptMap.set(option.value, option);\n        }\n    });\n    return valOptMap;\n}\nexport function defaultFilter(pattern, option) {\n    if (!option)\n        return false;\n    if (typeof option.label === 'string') {\n        return patternMatched(pattern, option.label);\n    }\n    else if (option.value !== undefined) {\n        return patternMatched(pattern, String(option.value));\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"module"}