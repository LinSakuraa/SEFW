{"ast":null,"code":"import { trapOn, trapOff } from './traps'; // currently `once` and `passive` is not supported\n\nfunction createDelegate() {\n  if (typeof window === 'undefined') {\n    return {\n      on: () => {},\n      off: () => {}\n    };\n  }\n\n  const propagationStopped = new WeakMap();\n  const immediatePropagationStopped = new WeakMap();\n\n  function trackPropagation() {\n    propagationStopped.set(this, true);\n  }\n\n  function trackImmediate() {\n    propagationStopped.set(this, true);\n    immediatePropagationStopped.set(this, true);\n  }\n\n  function spy(event, propName, fn) {\n    const source = event[propName];\n\n    event[propName] = function () {\n      fn.apply(event, arguments);\n      return source.apply(event, arguments);\n    };\n\n    return event;\n  }\n\n  function unspy(event, propName) {\n    event[propName] = Event.prototype[propName];\n  }\n\n  const currentTargets = new WeakMap();\n  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');\n\n  function getCurrentTarget() {\n    var _a;\n\n    return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;\n  }\n\n  function defineCurrentTarget(event, getter) {\n    if (currentTargetDescriptor === undefined) return;\n    Object.defineProperty(event, 'currentTarget', {\n      configurable: true,\n      enumerable: true,\n      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get\n    });\n  }\n\n  const phaseToTypeToElToHandlers = {\n    bubble: {},\n    capture: {}\n  };\n  const typeToWindowEventHandlers = {};\n\n  function createUnifiedHandler() {\n    const delegeteHandler = function (e) {\n      const {\n        type,\n        eventPhase,\n        target,\n        bubbles\n      } = e;\n      if (eventPhase === 2) return;\n      const phase = eventPhase === 1 ? 'capture' : 'bubble';\n      let cursor = target;\n      const path = []; // collecting bubble path\n\n      while (true) {\n        if (cursor === null) cursor = window;\n        path.push(cursor);\n\n        if (cursor === window) {\n          break;\n        } // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n\n        cursor = cursor.parentNode || null;\n      }\n\n      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];\n      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];\n      spy(e, 'stopPropagation', trackPropagation);\n      spy(e, 'stopImmediatePropagation', trackImmediate);\n      defineCurrentTarget(e, getCurrentTarget);\n\n      if (phase === 'capture') {\n        if (captureElToHandlers === undefined) return; // capture\n\n        for (let i = path.length - 1; i >= 0; --i) {\n          if (propagationStopped.has(e)) break;\n          const target = path[i];\n          const handlers = captureElToHandlers.get(target);\n\n          if (handlers !== undefined) {\n            currentTargets.set(e, target);\n\n            for (const handler of handlers) {\n              if (immediatePropagationStopped.has(e)) break;\n              handler(e);\n            }\n          }\n\n          if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {\n            const bubbleHandlers = bubbleElToHandlers.get(target);\n\n            if (bubbleHandlers !== undefined) {\n              for (const handler of bubbleHandlers) {\n                if (immediatePropagationStopped.has(e)) break;\n                handler(e);\n              }\n            }\n          }\n        }\n      } else if (phase === 'bubble') {\n        if (bubbleElToHandlers === undefined) return; // bubble\n\n        for (let i = 0; i < path.length; ++i) {\n          if (propagationStopped.has(e)) break;\n          const target = path[i];\n          const handlers = bubbleElToHandlers.get(target);\n\n          if (handlers !== undefined) {\n            currentTargets.set(e, target);\n\n            for (const handler of handlers) {\n              if (immediatePropagationStopped.has(e)) break;\n              handler(e);\n            }\n          }\n        }\n      }\n\n      unspy(e, 'stopPropagation');\n      unspy(e, 'stopImmediatePropagation');\n      defineCurrentTarget(e);\n    };\n\n    delegeteHandler.displayName = 'evtdUnifiedHandler';\n    return delegeteHandler;\n  }\n\n  function createUnifiedWindowEventHandler() {\n    const delegateHandler = function (e) {\n      const {\n        type,\n        eventPhase\n      } = e;\n      if (eventPhase !== 2) return;\n      const handlers = typeToWindowEventHandlers[type];\n      if (handlers === undefined) return;\n      handlers.forEach(handler => handler(e));\n    };\n\n    delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';\n    return delegateHandler;\n  }\n\n  const unifiedHandler = createUnifiedHandler();\n  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();\n\n  function ensureElToHandlers(phase, type) {\n    const phaseHandlers = phaseToTypeToElToHandlers[phase];\n\n    if (phaseHandlers[type] === undefined) {\n      phaseHandlers[type] = new Map();\n      window.addEventListener(type, unifiedHandler, phase === 'capture');\n    }\n\n    return phaseHandlers[type];\n  }\n\n  function ensureWindowEventHandlers(type) {\n    const windowEventHandlers = typeToWindowEventHandlers[type];\n\n    if (windowEventHandlers === undefined) {\n      typeToWindowEventHandlers[type] = new Set();\n      window.addEventListener(type, unfiendWindowEventHandler);\n    }\n\n    return typeToWindowEventHandlers[type];\n  }\n\n  function ensureHandlers(elToHandlers, el) {\n    let elHandlers = elToHandlers.get(el);\n\n    if (elHandlers === undefined) {\n      elToHandlers.set(el, elHandlers = new Set());\n    }\n\n    return elHandlers;\n  }\n\n  function handlerExist(el, phase, type, handler) {\n    const elToHandlers = phaseToTypeToElToHandlers[phase][type]; // phase ${type} event has handlers\n\n    if (elToHandlers !== undefined) {\n      const handlers = elToHandlers.get(el); // phase using el with ${type} event has handlers\n\n      if (handlers !== undefined) {\n        if (handlers.has(handler)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  function windowEventHandlerExist(type, handler) {\n    const handlers = typeToWindowEventHandlers[type];\n\n    if (handlers !== undefined) {\n      if (handlers.has(handler)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function on(type, el, handler, options) {\n    let mergedHandler;\n\n    if (typeof options === 'object' && options.once === true) {\n      mergedHandler = e => {\n        off(type, el, mergedHandler, options);\n        handler(e);\n      };\n    } else {\n      mergedHandler = handler;\n    }\n\n    const trapped = trapOn(type, el, mergedHandler, options);\n    if (trapped) return;\n    const phase = options === true || typeof options === 'object' && options.capture === true ? 'capture' : 'bubble';\n    const elToHandlers = ensureElToHandlers(phase, type);\n    const handlers = ensureHandlers(elToHandlers, el);\n    if (!handlers.has(mergedHandler)) handlers.add(mergedHandler);\n\n    if (el === window) {\n      const windowEventHandlers = ensureWindowEventHandlers(type);\n\n      if (!windowEventHandlers.has(mergedHandler)) {\n        windowEventHandlers.add(mergedHandler);\n      }\n    }\n  }\n\n  function off(type, el, handler, options) {\n    const trapped = trapOff(type, el, handler, options);\n    if (trapped) return;\n    const capture = options === true || typeof options === 'object' && options.capture === true;\n    const phase = capture ? 'capture' : 'bubble';\n    const elToHandlers = ensureElToHandlers(phase, type);\n    const handlers = ensureHandlers(elToHandlers, el);\n\n    if (el === window) {\n      const mirrorPhase = capture ? 'bubble' : 'capture';\n\n      if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const windowEventHandlers = typeToWindowEventHandlers[type];\n        windowEventHandlers.delete(handler);\n\n        if (windowEventHandlers.size === 0) {\n          window.removeEventListener(type, unfiendWindowEventHandler);\n          typeToWindowEventHandlers[type] = undefined;\n        }\n      }\n    }\n\n    if (handlers.has(handler)) handlers.delete(handler);\n\n    if (handlers.size === 0) {\n      elToHandlers.delete(el);\n    }\n\n    if (elToHandlers.size === 0) {\n      window.removeEventListener(type, unifiedHandler, phase === 'capture');\n      phaseToTypeToElToHandlers[phase][type] = undefined;\n    }\n  }\n\n  return {\n    on: on,\n    off: off\n  };\n}\n\nconst {\n  on,\n  off\n} = createDelegate();\nexport { on, off };","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/evtd/es/delegate.js"],"names":["trapOn","trapOff","createDelegate","window","on","off","propagationStopped","WeakMap","immediatePropagationStopped","trackPropagation","set","trackImmediate","spy","event","propName","fn","source","apply","arguments","unspy","Event","prototype","currentTargets","currentTargetDescriptor","Object","getOwnPropertyDescriptor","getCurrentTarget","_a","get","defineCurrentTarget","getter","undefined","defineProperty","configurable","enumerable","phaseToTypeToElToHandlers","bubble","capture","typeToWindowEventHandlers","createUnifiedHandler","delegeteHandler","e","type","eventPhase","target","bubbles","phase","cursor","path","push","parentNode","captureElToHandlers","bubbleElToHandlers","i","length","has","handlers","handler","bubbleHandlers","displayName","createUnifiedWindowEventHandler","delegateHandler","forEach","unifiedHandler","unfiendWindowEventHandler","ensureElToHandlers","phaseHandlers","Map","addEventListener","ensureWindowEventHandlers","windowEventHandlers","Set","ensureHandlers","elToHandlers","el","elHandlers","handlerExist","windowEventHandlerExist","options","mergedHandler","once","trapped","add","mirrorPhase","delete","size","removeEventListener"],"mappings":"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","sourcesContent":["import { trapOn, trapOff } from './traps';\n// currently `once` and `passive` is not supported\nfunction createDelegate() {\n    if (typeof window === 'undefined') {\n        return {\n            on: () => { },\n            off: () => { }\n        };\n    }\n    const propagationStopped = new WeakMap();\n    const immediatePropagationStopped = new WeakMap();\n    function trackPropagation() {\n        propagationStopped.set(this, true);\n    }\n    function trackImmediate() {\n        propagationStopped.set(this, true);\n        immediatePropagationStopped.set(this, true);\n    }\n    function spy(event, propName, fn) {\n        const source = event[propName];\n        event[propName] = function () {\n            fn.apply(event, arguments);\n            return source.apply(event, arguments);\n        };\n        return event;\n    }\n    function unspy(event, propName) {\n        event[propName] = Event.prototype[propName];\n    }\n    const currentTargets = new WeakMap();\n    const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');\n    function getCurrentTarget() {\n        var _a;\n        return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;\n    }\n    function defineCurrentTarget(event, getter) {\n        if (currentTargetDescriptor === undefined)\n            return;\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            enumerable: true,\n            get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get\n        });\n    }\n    const phaseToTypeToElToHandlers = {\n        bubble: {},\n        capture: {}\n    };\n    const typeToWindowEventHandlers = {};\n    function createUnifiedHandler() {\n        const delegeteHandler = function (e) {\n            const { type, eventPhase, target, bubbles } = e;\n            if (eventPhase === 2)\n                return;\n            const phase = eventPhase === 1 ? 'capture' : 'bubble';\n            let cursor = target;\n            const path = [];\n            // collecting bubble path\n            while (true) {\n                if (cursor === null)\n                    cursor = window;\n                path.push(cursor);\n                if (cursor === window) {\n                    break;\n                }\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                cursor = (cursor.parentNode || null);\n            }\n            const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];\n            const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];\n            spy(e, 'stopPropagation', trackPropagation);\n            spy(e, 'stopImmediatePropagation', trackImmediate);\n            defineCurrentTarget(e, getCurrentTarget);\n            if (phase === 'capture') {\n                if (captureElToHandlers === undefined)\n                    return;\n                // capture\n                for (let i = path.length - 1; i >= 0; --i) {\n                    if (propagationStopped.has(e))\n                        break;\n                    const target = path[i];\n                    const handlers = captureElToHandlers.get(target);\n                    if (handlers !== undefined) {\n                        currentTargets.set(e, target);\n                        for (const handler of handlers) {\n                            if (immediatePropagationStopped.has(e))\n                                break;\n                            handler(e);\n                        }\n                    }\n                    if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {\n                        const bubbleHandlers = bubbleElToHandlers.get(target);\n                        if (bubbleHandlers !== undefined) {\n                            for (const handler of bubbleHandlers) {\n                                if (immediatePropagationStopped.has(e))\n                                    break;\n                                handler(e);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (phase === 'bubble') {\n                if (bubbleElToHandlers === undefined)\n                    return;\n                // bubble\n                for (let i = 0; i < path.length; ++i) {\n                    if (propagationStopped.has(e))\n                        break;\n                    const target = path[i];\n                    const handlers = bubbleElToHandlers.get(target);\n                    if (handlers !== undefined) {\n                        currentTargets.set(e, target);\n                        for (const handler of handlers) {\n                            if (immediatePropagationStopped.has(e))\n                                break;\n                            handler(e);\n                        }\n                    }\n                }\n            }\n            unspy(e, 'stopPropagation');\n            unspy(e, 'stopImmediatePropagation');\n            defineCurrentTarget(e);\n        };\n        delegeteHandler.displayName = 'evtdUnifiedHandler';\n        return delegeteHandler;\n    }\n    function createUnifiedWindowEventHandler() {\n        const delegateHandler = function (e) {\n            const { type, eventPhase } = e;\n            if (eventPhase !== 2)\n                return;\n            const handlers = typeToWindowEventHandlers[type];\n            if (handlers === undefined)\n                return;\n            handlers.forEach((handler) => handler(e));\n        };\n        delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';\n        return delegateHandler;\n    }\n    const unifiedHandler = createUnifiedHandler();\n    const unfiendWindowEventHandler = createUnifiedWindowEventHandler();\n    function ensureElToHandlers(phase, type) {\n        const phaseHandlers = phaseToTypeToElToHandlers[phase];\n        if (phaseHandlers[type] === undefined) {\n            phaseHandlers[type] = new Map();\n            window.addEventListener(type, unifiedHandler, phase === 'capture');\n        }\n        return phaseHandlers[type];\n    }\n    function ensureWindowEventHandlers(type) {\n        const windowEventHandlers = typeToWindowEventHandlers[type];\n        if (windowEventHandlers === undefined) {\n            typeToWindowEventHandlers[type] = new Set();\n            window.addEventListener(type, unfiendWindowEventHandler);\n        }\n        return typeToWindowEventHandlers[type];\n    }\n    function ensureHandlers(elToHandlers, el) {\n        let elHandlers = elToHandlers.get(el);\n        if (elHandlers === undefined) {\n            elToHandlers.set(el, (elHandlers = new Set()));\n        }\n        return elHandlers;\n    }\n    function handlerExist(el, phase, type, handler) {\n        const elToHandlers = phaseToTypeToElToHandlers[phase][type];\n        // phase ${type} event has handlers\n        if (elToHandlers !== undefined) {\n            const handlers = elToHandlers.get(el);\n            // phase using el with ${type} event has handlers\n            if (handlers !== undefined) {\n                if (handlers.has(handler))\n                    return true;\n            }\n        }\n        return false;\n    }\n    function windowEventHandlerExist(type, handler) {\n        const handlers = typeToWindowEventHandlers[type];\n        if (handlers !== undefined) {\n            if (handlers.has(handler)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function on(type, el, handler, options) {\n        let mergedHandler;\n        if (typeof options === 'object' && options.once === true) {\n            mergedHandler = (e) => {\n                off(type, el, mergedHandler, options);\n                handler(e);\n            };\n        }\n        else {\n            mergedHandler = handler;\n        }\n        const trapped = trapOn(type, el, mergedHandler, options);\n        if (trapped)\n            return;\n        const phase = options === true ||\n            (typeof options === 'object' && options.capture === true)\n            ? 'capture'\n            : 'bubble';\n        const elToHandlers = ensureElToHandlers(phase, type);\n        const handlers = ensureHandlers(elToHandlers, el);\n        if (!handlers.has(mergedHandler))\n            handlers.add(mergedHandler);\n        if (el === window) {\n            const windowEventHandlers = ensureWindowEventHandlers(type);\n            if (!windowEventHandlers.has(mergedHandler)) {\n                windowEventHandlers.add(mergedHandler);\n            }\n        }\n    }\n    function off(type, el, handler, options) {\n        const trapped = trapOff(type, el, handler, options);\n        if (trapped)\n            return;\n        const capture = options === true ||\n            (typeof options === 'object' && options.capture === true);\n        const phase = capture ? 'capture' : 'bubble';\n        const elToHandlers = ensureElToHandlers(phase, type);\n        const handlers = ensureHandlers(elToHandlers, el);\n        if (el === window) {\n            const mirrorPhase = capture ? 'bubble' : 'capture';\n            if (!handlerExist(el, mirrorPhase, type, handler) &&\n                windowEventHandlerExist(type, handler)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const windowEventHandlers = typeToWindowEventHandlers[type];\n                windowEventHandlers.delete(handler);\n                if (windowEventHandlers.size === 0) {\n                    window.removeEventListener(type, unfiendWindowEventHandler);\n                    typeToWindowEventHandlers[type] = undefined;\n                }\n            }\n        }\n        if (handlers.has(handler))\n            handlers.delete(handler);\n        if (handlers.size === 0) {\n            elToHandlers.delete(el);\n        }\n        if (elToHandlers.size === 0) {\n            window.removeEventListener(type, unifiedHandler, phase === 'capture');\n            phaseToTypeToElToHandlers[phase][type] = undefined;\n        }\n    }\n    return {\n        on: on,\n        off: off\n    };\n}\nconst { on, off } = createDelegate();\nexport { on, off };\n"]},"metadata":{},"sourceType":"module"}