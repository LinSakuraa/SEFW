{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { attr, booleanConverter, DOM, nullableNumberConverter, observable } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A HorizontalScroll Custom HTML Element\n * @public\n */\n\nexport class HorizontalScroll extends FoundationElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * @internal\n     */\n\n    this.framesPerSecond = 60;\n    /**\n     * Flag indicating that the items are being updated\n     *\n     * @internal\n     */\n\n    this.updatingItems = false;\n    /**\n     * Speed of scroll in pixels per second\n     * @public\n     */\n\n    this.speed = 600;\n    /**\n     * Attribute used for easing, defaults to ease-in-out\n     * @public\n     */\n\n    this.easing = \"ease-in-out\";\n    /**\n     * Attribute to hide flippers from assistive technology\n     * @public\n     */\n\n    this.flippersHiddenFromAT = false;\n    /**\n     * Scrolling state\n     * @internal\n     */\n\n    this.scrolling = false;\n    /**\n     * Detects if the component has been resized\n     * @internal\n     */\n\n    this.resizeDetector = null;\n  }\n  /**\n   * The calculated duration for a frame.\n   *\n   * @internal\n   */\n\n\n  get frameTime() {\n    return 1000 / this.framesPerSecond;\n  }\n  /**\n   * Firing scrollstart and scrollend events\n   * @internal\n   */\n\n\n  scrollingChanged(prev, next) {\n    if (this.scrollContainer) {\n      const event = this.scrolling == true ? \"scrollstart\" : \"scrollend\";\n      this.$emit(event, this.scrollContainer.scrollLeft);\n    }\n  }\n  /**\n   * In RTL mode\n   * @internal\n   */\n\n\n  get isRtl() {\n    return this.scrollItems.length > 1 && this.scrollItems[0].offsetLeft > this.scrollItems[1].offsetLeft;\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.initializeResizeDetector();\n  }\n\n  disconnectedCallback() {\n    this.disconnectResizeDetector();\n    super.disconnectedCallback();\n  }\n  /**\n   * Updates scroll stops and flippers when scroll items change\n   * @param previous - current scroll items\n   * @param next - new updated scroll items\n   * @public\n   */\n\n\n  scrollItemsChanged(previous, next) {\n    if (next && !this.updatingItems) {\n      DOM.queueUpdate(() => this.setStops());\n    }\n  }\n  /**\n   * destroys the instance's resize observer\n   * @internal\n   */\n\n\n  disconnectResizeDetector() {\n    if (this.resizeDetector) {\n      this.resizeDetector.disconnect();\n      this.resizeDetector = null;\n    }\n  }\n  /**\n   * initializes the instance's resize observer\n   * @internal\n   */\n\n\n  initializeResizeDetector() {\n    this.disconnectResizeDetector();\n    this.resizeDetector = new window.ResizeObserver(this.resized.bind(this));\n    this.resizeDetector.observe(this);\n  }\n  /**\n   * Looks for slots and uses child nodes instead\n   * @internal\n   */\n\n\n  updateScrollStops() {\n    this.updatingItems = true;\n    const updatedItems = this.scrollItems.reduce((scrollItems, scrollItem) => {\n      if (scrollItem instanceof HTMLSlotElement) {\n        return scrollItems.concat(scrollItem.assignedElements());\n      }\n\n      scrollItems.push(scrollItem);\n      return scrollItems;\n    }, []);\n    this.scrollItems = updatedItems;\n    this.updatingItems = false;\n  }\n  /**\n   * Finds all of the scroll stops between elements\n   * @internal\n   */\n\n\n  setStops() {\n    this.updateScrollStops();\n    this.width = this.offsetWidth;\n    let lastStop = 0;\n    let stops = this.scrollItems.map(({\n      offsetLeft: left,\n      offsetWidth: width\n    }, index) => {\n      const right = left + width;\n\n      if (this.isRtl) {\n        return -right;\n      }\n\n      lastStop = right;\n      return index === 0 ? 0 : left;\n    }).concat(lastStop);\n    /* Fixes a FireFox bug where it doesn't scroll to the start */\n\n    stops = this.fixScrollMisalign(stops);\n    /* Sort to zero */\n\n    stops.sort((a, b) => Math.abs(a) - Math.abs(b));\n    this.scrollStops = stops;\n    this.setFlippers();\n  }\n  /**\n   *\n   */\n\n\n  fixScrollMisalign(stops) {\n    if (this.isRtl && stops.some(stop => stop > 0)) {\n      stops.sort((a, b) => b - a);\n      const offset = stops[0];\n      stops = stops.map(stop => stop - offset);\n    }\n\n    return stops;\n  }\n  /**\n   * Sets the controls view if enabled\n   * @internal\n   */\n\n\n  setFlippers() {\n    var _a, _b;\n\n    const position = this.scrollContainer.scrollLeft;\n    (_a = this.previousFlipperContainer) === null || _a === void 0 ? void 0 : _a.classList.toggle(\"disabled\", position === 0);\n\n    if (this.scrollStops) {\n      const lastStop = Math.abs(this.scrollStops[this.scrollStops.length - 1]);\n      (_b = this.nextFlipperContainer) === null || _b === void 0 ? void 0 : _b.classList.toggle(\"disabled\", Math.abs(position) + this.width >= lastStop);\n    }\n  }\n  /**\n   * Lets the user arrow left and right through the horizontal scroll\n   * @param e - Keyboard event\n   * @public\n   */\n\n\n  keyupHandler(e) {\n    const key = e.key;\n\n    switch (key) {\n      case \"ArrowLeft\":\n        this.scrollToPrevious();\n        break;\n\n      case \"ArrowRight\":\n        this.scrollToNext();\n        break;\n    }\n  }\n  /**\n   * Scrolls items to the left\n   * @public\n   */\n\n\n  scrollToPrevious() {\n    const scrollPosition = this.scrollContainer.scrollLeft;\n    const current = this.scrollStops.findIndex((stop, index) => stop <= scrollPosition && (this.isRtl || index === this.scrollStops.length - 1 || this.scrollStops[index + 1] > scrollPosition));\n    const right = Math.abs(this.scrollStops[current + 1]);\n    let nextIndex = this.scrollStops.findIndex(stop => Math.abs(stop) + this.width > right);\n\n    if (nextIndex >= current || nextIndex === -1) {\n      nextIndex = current > 0 ? current - 1 : 0;\n    }\n\n    this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n  }\n  /**\n   * Scrolls items to the right\n   * @public\n   */\n\n\n  scrollToNext() {\n    const scrollPosition = this.scrollContainer.scrollLeft;\n    const current = this.scrollStops.findIndex(stop => Math.abs(stop) >= Math.abs(scrollPosition));\n    const outOfView = this.scrollStops.findIndex(stop => Math.abs(scrollPosition) + this.width <= Math.abs(stop));\n    let nextIndex = current;\n\n    if (outOfView > current + 2) {\n      nextIndex = outOfView - 2;\n    } else if (current < this.scrollStops.length - 2) {\n      nextIndex = current + 1;\n    }\n\n    this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n  }\n  /**\n   * Handles scrolling with easing\n   * @param position - starting position\n   * @param newPosition - position to scroll to\n   * @public\n   */\n\n\n  scrollToPosition(newPosition, position = this.scrollContainer.scrollLeft) {\n    var _a;\n\n    if (this.scrolling) {\n      return;\n    }\n\n    this.scrolling = true;\n    const seconds = (_a = this.duration) !== null && _a !== void 0 ? _a : `${Math.abs(newPosition - position) / this.speed}s`;\n    this.content.style.setProperty(\"transition-duration\", seconds);\n    const computedDuration = parseFloat(getComputedStyle(this.content).getPropertyValue(\"transition-duration\"));\n\n    const transitionendHandler = e => {\n      if (e && e.target !== e.currentTarget) {\n        return;\n      }\n\n      this.content.style.setProperty(\"transition-duration\", \"0s\");\n      this.content.style.removeProperty(\"transform\");\n      this.scrollContainer.style.setProperty(\"scroll-behavior\", \"auto\");\n      this.scrollContainer.scrollLeft = newPosition;\n      this.setFlippers();\n      this.content.removeEventListener(\"transitionend\", transitionendHandler);\n      this.scrolling = false;\n    };\n\n    if (computedDuration === 0) {\n      transitionendHandler();\n      return;\n    }\n\n    this.content.addEventListener(\"transitionend\", transitionendHandler);\n    const maxScrollValue = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;\n    let transitionStop = this.scrollContainer.scrollLeft - Math.min(newPosition, maxScrollValue);\n\n    if (this.isRtl) {\n      transitionStop = this.scrollContainer.scrollLeft + Math.min(Math.abs(newPosition), maxScrollValue);\n    }\n\n    this.content.style.setProperty(\"transition-property\", \"transform\");\n    this.content.style.setProperty(\"transition-timing-function\", this.easing);\n    this.content.style.setProperty(\"transform\", `translateX(${transitionStop}px)`);\n  }\n  /**\n   * Monitors resize event on the horizontal-scroll element\n   * @public\n   */\n\n\n  resized() {\n    if (this.resizeTimeout) {\n      this.resizeTimeout = clearTimeout(this.resizeTimeout);\n    }\n\n    this.resizeTimeout = setTimeout(() => {\n      this.width = this.offsetWidth;\n      this.setFlippers();\n    }, this.frameTime);\n  }\n  /**\n   * Monitors scrolled event on the content container\n   * @public\n   */\n\n\n  scrolled() {\n    if (this.scrollTimeout) {\n      this.scrollTimeout = clearTimeout(this.scrollTimeout);\n    }\n\n    this.scrollTimeout = setTimeout(() => {\n      this.setFlippers();\n    }, this.frameTime);\n  }\n\n}\n\n__decorate([attr({\n  converter: nullableNumberConverter\n})], HorizontalScroll.prototype, \"speed\", void 0);\n\n__decorate([attr], HorizontalScroll.prototype, \"duration\", void 0);\n\n__decorate([attr], HorizontalScroll.prototype, \"easing\", void 0);\n\n__decorate([attr({\n  attribute: \"flippers-hidden-from-at\",\n  converter: booleanConverter\n})], HorizontalScroll.prototype, \"flippersHiddenFromAT\", void 0);\n\n__decorate([observable], HorizontalScroll.prototype, \"scrolling\", void 0);\n\n__decorate([observable], HorizontalScroll.prototype, \"scrollItems\", void 0);\n\n__decorate([attr({\n  attribute: \"view\"\n})], HorizontalScroll.prototype, \"view\", void 0);","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/horizontal-scroll/horizontal-scroll.js"],"names":["__decorate","attr","booleanConverter","DOM","nullableNumberConverter","observable","FoundationElement","HorizontalScroll","constructor","arguments","framesPerSecond","updatingItems","speed","easing","flippersHiddenFromAT","scrolling","resizeDetector","frameTime","scrollingChanged","prev","next","scrollContainer","event","$emit","scrollLeft","isRtl","scrollItems","length","offsetLeft","connectedCallback","initializeResizeDetector","disconnectedCallback","disconnectResizeDetector","scrollItemsChanged","previous","queueUpdate","setStops","disconnect","window","ResizeObserver","resized","bind","observe","updateScrollStops","updatedItems","reduce","scrollItem","HTMLSlotElement","concat","assignedElements","push","width","offsetWidth","lastStop","stops","map","left","index","right","fixScrollMisalign","sort","a","b","Math","abs","scrollStops","setFlippers","some","stop","offset","_a","_b","position","previousFlipperContainer","classList","toggle","nextFlipperContainer","keyupHandler","e","key","scrollToPrevious","scrollToNext","scrollPosition","current","findIndex","nextIndex","scrollToPosition","outOfView","newPosition","seconds","duration","content","style","setProperty","computedDuration","parseFloat","getComputedStyle","getPropertyValue","transitionendHandler","target","currentTarget","removeProperty","removeEventListener","addEventListener","maxScrollValue","scrollWidth","clientWidth","transitionStop","min","resizeTimeout","clearTimeout","setTimeout","scrolled","scrollTimeout","converter","prototype","attribute"],"mappings":"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","sourcesContent":["import { __decorate } from \"tslib\";\nimport { attr, booleanConverter, DOM, nullableNumberConverter, observable, } from \"@microsoft/fast-element\";\nimport { FoundationElement } from \"../foundation-element\";\n/**\n * A HorizontalScroll Custom HTML Element\n * @public\n */\nexport class HorizontalScroll extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @internal\n         */\n        this.framesPerSecond = 60;\n        /**\n         * Flag indicating that the items are being updated\n         *\n         * @internal\n         */\n        this.updatingItems = false;\n        /**\n         * Speed of scroll in pixels per second\n         * @public\n         */\n        this.speed = 600;\n        /**\n         * Attribute used for easing, defaults to ease-in-out\n         * @public\n         */\n        this.easing = \"ease-in-out\";\n        /**\n         * Attribute to hide flippers from assistive technology\n         * @public\n         */\n        this.flippersHiddenFromAT = false;\n        /**\n         * Scrolling state\n         * @internal\n         */\n        this.scrolling = false;\n        /**\n         * Detects if the component has been resized\n         * @internal\n         */\n        this.resizeDetector = null;\n    }\n    /**\n     * The calculated duration for a frame.\n     *\n     * @internal\n     */\n    get frameTime() {\n        return 1000 / this.framesPerSecond;\n    }\n    /**\n     * Firing scrollstart and scrollend events\n     * @internal\n     */\n    scrollingChanged(prev, next) {\n        if (this.scrollContainer) {\n            const event = this.scrolling == true ? \"scrollstart\" : \"scrollend\";\n            this.$emit(event, this.scrollContainer.scrollLeft);\n        }\n    }\n    /**\n     * In RTL mode\n     * @internal\n     */\n    get isRtl() {\n        return (this.scrollItems.length > 1 &&\n            this.scrollItems[0].offsetLeft > this.scrollItems[1].offsetLeft);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.initializeResizeDetector();\n    }\n    disconnectedCallback() {\n        this.disconnectResizeDetector();\n        super.disconnectedCallback();\n    }\n    /**\n     * Updates scroll stops and flippers when scroll items change\n     * @param previous - current scroll items\n     * @param next - new updated scroll items\n     * @public\n     */\n    scrollItemsChanged(previous, next) {\n        if (next && !this.updatingItems) {\n            DOM.queueUpdate(() => this.setStops());\n        }\n    }\n    /**\n     * destroys the instance's resize observer\n     * @internal\n     */\n    disconnectResizeDetector() {\n        if (this.resizeDetector) {\n            this.resizeDetector.disconnect();\n            this.resizeDetector = null;\n        }\n    }\n    /**\n     * initializes the instance's resize observer\n     * @internal\n     */\n    initializeResizeDetector() {\n        this.disconnectResizeDetector();\n        this.resizeDetector = new window.ResizeObserver(this.resized.bind(this));\n        this.resizeDetector.observe(this);\n    }\n    /**\n     * Looks for slots and uses child nodes instead\n     * @internal\n     */\n    updateScrollStops() {\n        this.updatingItems = true;\n        const updatedItems = this.scrollItems.reduce((scrollItems, scrollItem) => {\n            if (scrollItem instanceof HTMLSlotElement) {\n                return scrollItems.concat(scrollItem.assignedElements());\n            }\n            scrollItems.push(scrollItem);\n            return scrollItems;\n        }, []);\n        this.scrollItems = updatedItems;\n        this.updatingItems = false;\n    }\n    /**\n     * Finds all of the scroll stops between elements\n     * @internal\n     */\n    setStops() {\n        this.updateScrollStops();\n        this.width = this.offsetWidth;\n        let lastStop = 0;\n        let stops = this.scrollItems\n            .map(({ offsetLeft: left, offsetWidth: width }, index) => {\n            const right = left + width;\n            if (this.isRtl) {\n                return -right;\n            }\n            lastStop = right;\n            return index === 0 ? 0 : left;\n        })\n            .concat(lastStop);\n        /* Fixes a FireFox bug where it doesn't scroll to the start */\n        stops = this.fixScrollMisalign(stops);\n        /* Sort to zero */\n        stops.sort((a, b) => Math.abs(a) - Math.abs(b));\n        this.scrollStops = stops;\n        this.setFlippers();\n    }\n    /**\n     *\n     */\n    fixScrollMisalign(stops) {\n        if (this.isRtl && stops.some(stop => stop > 0)) {\n            stops.sort((a, b) => b - a);\n            const offset = stops[0];\n            stops = stops.map(stop => stop - offset);\n        }\n        return stops;\n    }\n    /**\n     * Sets the controls view if enabled\n     * @internal\n     */\n    setFlippers() {\n        var _a, _b;\n        const position = this.scrollContainer.scrollLeft;\n        (_a = this.previousFlipperContainer) === null || _a === void 0 ? void 0 : _a.classList.toggle(\"disabled\", position === 0);\n        if (this.scrollStops) {\n            const lastStop = Math.abs(this.scrollStops[this.scrollStops.length - 1]);\n            (_b = this.nextFlipperContainer) === null || _b === void 0 ? void 0 : _b.classList.toggle(\"disabled\", Math.abs(position) + this.width >= lastStop);\n        }\n    }\n    /**\n     * Lets the user arrow left and right through the horizontal scroll\n     * @param e - Keyboard event\n     * @public\n     */\n    keyupHandler(e) {\n        const key = e.key;\n        switch (key) {\n            case \"ArrowLeft\":\n                this.scrollToPrevious();\n                break;\n            case \"ArrowRight\":\n                this.scrollToNext();\n                break;\n        }\n    }\n    /**\n     * Scrolls items to the left\n     * @public\n     */\n    scrollToPrevious() {\n        const scrollPosition = this.scrollContainer.scrollLeft;\n        const current = this.scrollStops.findIndex((stop, index) => stop <= scrollPosition &&\n            (this.isRtl ||\n                index === this.scrollStops.length - 1 ||\n                this.scrollStops[index + 1] > scrollPosition));\n        const right = Math.abs(this.scrollStops[current + 1]);\n        let nextIndex = this.scrollStops.findIndex(stop => Math.abs(stop) + this.width > right);\n        if (nextIndex >= current || nextIndex === -1) {\n            nextIndex = current > 0 ? current - 1 : 0;\n        }\n        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n    }\n    /**\n     * Scrolls items to the right\n     * @public\n     */\n    scrollToNext() {\n        const scrollPosition = this.scrollContainer.scrollLeft;\n        const current = this.scrollStops.findIndex(stop => Math.abs(stop) >= Math.abs(scrollPosition));\n        const outOfView = this.scrollStops.findIndex(stop => Math.abs(scrollPosition) + this.width <= Math.abs(stop));\n        let nextIndex = current;\n        if (outOfView > current + 2) {\n            nextIndex = outOfView - 2;\n        }\n        else if (current < this.scrollStops.length - 2) {\n            nextIndex = current + 1;\n        }\n        this.scrollToPosition(this.scrollStops[nextIndex], scrollPosition);\n    }\n    /**\n     * Handles scrolling with easing\n     * @param position - starting position\n     * @param newPosition - position to scroll to\n     * @public\n     */\n    scrollToPosition(newPosition, position = this.scrollContainer.scrollLeft) {\n        var _a;\n        if (this.scrolling) {\n            return;\n        }\n        this.scrolling = true;\n        const seconds = (_a = this.duration) !== null && _a !== void 0 ? _a : `${Math.abs(newPosition - position) / this.speed}s`;\n        this.content.style.setProperty(\"transition-duration\", seconds);\n        const computedDuration = parseFloat(getComputedStyle(this.content).getPropertyValue(\"transition-duration\"));\n        const transitionendHandler = (e) => {\n            if (e && e.target !== e.currentTarget) {\n                return;\n            }\n            this.content.style.setProperty(\"transition-duration\", \"0s\");\n            this.content.style.removeProperty(\"transform\");\n            this.scrollContainer.style.setProperty(\"scroll-behavior\", \"auto\");\n            this.scrollContainer.scrollLeft = newPosition;\n            this.setFlippers();\n            this.content.removeEventListener(\"transitionend\", transitionendHandler);\n            this.scrolling = false;\n        };\n        if (computedDuration === 0) {\n            transitionendHandler();\n            return;\n        }\n        this.content.addEventListener(\"transitionend\", transitionendHandler);\n        const maxScrollValue = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;\n        let transitionStop = this.scrollContainer.scrollLeft - Math.min(newPosition, maxScrollValue);\n        if (this.isRtl) {\n            transitionStop =\n                this.scrollContainer.scrollLeft +\n                    Math.min(Math.abs(newPosition), maxScrollValue);\n        }\n        this.content.style.setProperty(\"transition-property\", \"transform\");\n        this.content.style.setProperty(\"transition-timing-function\", this.easing);\n        this.content.style.setProperty(\"transform\", `translateX(${transitionStop}px)`);\n    }\n    /**\n     * Monitors resize event on the horizontal-scroll element\n     * @public\n     */\n    resized() {\n        if (this.resizeTimeout) {\n            this.resizeTimeout = clearTimeout(this.resizeTimeout);\n        }\n        this.resizeTimeout = setTimeout(() => {\n            this.width = this.offsetWidth;\n            this.setFlippers();\n        }, this.frameTime);\n    }\n    /**\n     * Monitors scrolled event on the content container\n     * @public\n     */\n    scrolled() {\n        if (this.scrollTimeout) {\n            this.scrollTimeout = clearTimeout(this.scrollTimeout);\n        }\n        this.scrollTimeout = setTimeout(() => {\n            this.setFlippers();\n        }, this.frameTime);\n    }\n}\n__decorate([\n    attr({ converter: nullableNumberConverter })\n], HorizontalScroll.prototype, \"speed\", void 0);\n__decorate([\n    attr\n], HorizontalScroll.prototype, \"duration\", void 0);\n__decorate([\n    attr\n], HorizontalScroll.prototype, \"easing\", void 0);\n__decorate([\n    attr({ attribute: \"flippers-hidden-from-at\", converter: booleanConverter })\n], HorizontalScroll.prototype, \"flippersHiddenFromAT\", void 0);\n__decorate([\n    observable\n], HorizontalScroll.prototype, \"scrolling\", void 0);\n__decorate([\n    observable\n], HorizontalScroll.prototype, \"scrollItems\", void 0);\n__decorate([\n    attr({ attribute: \"view\" })\n], HorizontalScroll.prototype, \"view\", void 0);\n"]},"metadata":{},"sourceType":"module"}