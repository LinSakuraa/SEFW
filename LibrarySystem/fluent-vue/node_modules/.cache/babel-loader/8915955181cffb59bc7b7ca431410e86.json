{"ast":null,"code":"import { attr, booleanConverter, DOM, emptyArray, observable } from \"@microsoft/fast-element\";\nimport { keyEnter } from \"@microsoft/fast-web-utilities\";\nconst proxySlotName = \"form-associated-proxy\";\nconst ElementInternalsKey = \"ElementInternals\";\n/**\n * @alpha\n */\n\nexport const supportsElementInternals = ElementInternalsKey in window && \"setFormValue\" in window[ElementInternalsKey].prototype;\nconst InternalsMap = new WeakMap();\n/**\n * Base function for providing Custom Element Form Association.\n *\n * @alpha\n */\n\nexport function FormAssociated(BaseCtor) {\n  const C = class extends BaseCtor {\n    constructor(...args) {\n      super(...args);\n      /**\n       * Track whether the value has been changed from the initial value\n       */\n\n      this.dirtyValue = false;\n      /**\n       * Sets the element's disabled state. A disabled element will not be included during form submission.\n       *\n       * @remarks\n       * HTML Attribute: disabled\n       */\n\n      this.disabled = false;\n      /**\n       * These are events that are still fired by the proxy\n       * element based on user / programmatic interaction.\n       *\n       * The proxy implementation should be transparent to\n       * the app author, so block these events from emitting.\n       */\n\n      this.proxyEventsToBlock = [\"change\", \"click\"];\n      this.proxyInitialized = false;\n      this.required = false;\n      this.initialValue = this.initialValue || \"\";\n\n      if (!this.elementInternals) {\n        // When elementInternals is not supported, formResetCallback is\n        // bound to an event listener, so ensure the handler's `this`\n        // context is correct.\n        this.formResetCallback = this.formResetCallback.bind(this);\n      }\n    }\n    /**\n     * Must evaluate to true to enable elementInternals.\n     * Feature detects API support and resolve respectively\n     *\n     * @internal\n     */\n\n\n    static get formAssociated() {\n      return supportsElementInternals;\n    }\n    /**\n     * Returns the validity state of the element\n     *\n     * @alpha\n     */\n\n\n    get validity() {\n      return this.elementInternals ? this.elementInternals.validity : this.proxy.validity;\n    }\n    /**\n     * Retrieve a reference to the associated form.\n     * Returns null if not associated to any form.\n     *\n     * @alpha\n     */\n\n\n    get form() {\n      return this.elementInternals ? this.elementInternals.form : this.proxy.form;\n    }\n    /**\n     * Retrieve the localized validation message,\n     * or custom validation message if set.\n     *\n     * @alpha\n     */\n\n\n    get validationMessage() {\n      return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage;\n    }\n    /**\n     * Whether the element will be validated when the\n     * form is submitted\n     */\n\n\n    get willValidate() {\n      return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate;\n    }\n    /**\n     * A reference to all associated label elements\n     */\n\n\n    get labels() {\n      if (this.elementInternals) {\n        return Object.freeze(Array.from(this.elementInternals.labels));\n      } else if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) {\n        // Labels associated by wrapping the element: <label><custom-element></custom-element></label>\n        const parentLabels = this.proxy.labels; // Labels associated using the `for` attribute\n\n        const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));\n        const labels = parentLabels ? forLabels.concat(Array.from(parentLabels)) : forLabels;\n        return Object.freeze(labels);\n      } else {\n        return emptyArray;\n      }\n    }\n    /**\n     * Invoked when the `value` property changes\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `valueChanged` method\n     * They must be sure to invoke `super.valueChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    valueChanged(previous, next) {\n      this.dirtyValue = true;\n\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.value = this.value;\n      }\n\n      this.currentValue = this.value;\n      this.setFormValue(this.value);\n      this.validate();\n    }\n\n    currentValueChanged() {\n      this.value = this.currentValue;\n    }\n    /**\n     * Invoked when the `initialValue` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `initialValueChanged` method\n     * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    initialValueChanged(previous, next) {\n      // If the value is clean and the component is connected to the DOM\n      // then set value equal to the attribute value.\n      if (!this.dirtyValue) {\n        this.value = this.initialValue;\n        this.dirtyValue = false;\n      }\n    }\n    /**\n     * Invoked when the `disabled` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `disabledChanged` method\n     * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    disabledChanged(previous, next) {\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.disabled = this.disabled;\n      }\n\n      DOM.queueUpdate(() => this.classList.toggle(\"disabled\", this.disabled));\n    }\n    /**\n     * Invoked when the `name` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `nameChanged` method\n     * They must be sure to invoke `super.nameChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    nameChanged(previous, next) {\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.name = this.name;\n      }\n    }\n    /**\n     * Invoked when the `required` property changes\n     *\n     * @param previous - the previous value\n     * @param next - the new value\n     *\n     * @remarks\n     * If elements extending `FormAssociated` implement a `requiredChanged` method\n     * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure\n     * proper functioning of `FormAssociated`\n     */\n\n\n    requiredChanged(prev, next) {\n      if (this.proxy instanceof HTMLElement) {\n        this.proxy.required = this.required;\n      }\n\n      DOM.queueUpdate(() => this.classList.toggle(\"required\", this.required));\n      this.validate();\n    }\n    /**\n     * The element internals object. Will only exist\n     * in browsers supporting the attachInternals API\n     */\n\n\n    get elementInternals() {\n      if (!supportsElementInternals) {\n        return null;\n      }\n\n      let internals = InternalsMap.get(this);\n\n      if (!internals) {\n        internals = this.attachInternals();\n        InternalsMap.set(this, internals);\n      }\n\n      return internals;\n    }\n    /**\n     * @internal\n     */\n\n\n    connectedCallback() {\n      super.connectedCallback();\n      this.addEventListener(\"keypress\", this._keypressHandler);\n\n      if (!this.value) {\n        this.value = this.initialValue;\n        this.dirtyValue = false;\n      }\n\n      if (!this.elementInternals) {\n        this.attachProxy();\n\n        if (this.form) {\n          this.form.addEventListener(\"reset\", this.formResetCallback);\n        }\n      }\n    }\n    /**\n     * @internal\n     */\n\n\n    disconnectedCallback() {\n      this.proxyEventsToBlock.forEach(name => this.proxy.removeEventListener(name, this.stopPropagation));\n\n      if (!this.elementInternals && this.form) {\n        this.form.removeEventListener(\"reset\", this.formResetCallback);\n      }\n    }\n    /**\n     * Return the current validity of the element.\n     */\n\n\n    checkValidity() {\n      return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity();\n    }\n    /**\n     * Return the current validity of the element.\n     * If false, fires an invalid event at the element.\n     */\n\n\n    reportValidity() {\n      return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity();\n    }\n    /**\n     * Set the validity of the control. In cases when the elementInternals object is not\n     * available (and the proxy element is used to report validity), this function will\n     * do nothing unless a message is provided, at which point the setCustomValidity method\n     * of the proxy element will be invoked with the provided message.\n     * @param flags - Validity flags\n     * @param message - Optional message to supply\n     * @param anchor - Optional element used by UA to display an interactive validation UI\n     */\n\n\n    setValidity(flags, message, anchor) {\n      if (this.elementInternals) {\n        this.elementInternals.setValidity(flags, message, anchor);\n      } else if (typeof message === \"string\") {\n        this.proxy.setCustomValidity(message);\n      }\n    }\n    /**\n     * Invoked when a connected component's form or fieldset has its disabled\n     * state changed.\n     * @param disabled - the disabled value of the form / fieldset\n     */\n\n\n    formDisabledCallback(disabled) {\n      this.disabled = disabled;\n    }\n\n    formResetCallback() {\n      this.value = this.initialValue;\n      this.dirtyValue = false;\n    }\n    /**\n     * Attach the proxy element to the DOM\n     */\n\n\n    attachProxy() {\n      var _a;\n\n      if (!this.proxyInitialized) {\n        this.proxyInitialized = true;\n        this.proxy.style.display = \"none\";\n        this.proxyEventsToBlock.forEach(name => this.proxy.addEventListener(name, this.stopPropagation)); // These are typically mapped to the proxy during\n        // property change callbacks, but during initialization\n        // on the initial call of the callback, the proxy is\n        // still undefined. We should find a better way to address this.\n\n        this.proxy.disabled = this.disabled;\n        this.proxy.required = this.required;\n\n        if (typeof this.name === \"string\") {\n          this.proxy.name = this.name;\n        }\n\n        if (typeof this.value === \"string\") {\n          this.proxy.value = this.value;\n        }\n\n        this.proxy.setAttribute(\"slot\", proxySlotName);\n        this.proxySlot = document.createElement(\"slot\");\n        this.proxySlot.setAttribute(\"name\", proxySlotName);\n      }\n\n      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);\n      this.appendChild(this.proxy);\n    }\n    /**\n     * Detach the proxy element from the DOM\n     */\n\n\n    detachProxy() {\n      var _a;\n\n      this.removeChild(this.proxy);\n      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);\n    }\n    /**\n     * Sets the validity of the custom element. By default this uses the proxy element to determine\n     * validity, but this can be extended or replaced in implementation.\n     */\n\n\n    validate() {\n      if (this.proxy instanceof HTMLElement) {\n        this.setValidity(this.proxy.validity, this.proxy.validationMessage);\n      }\n    }\n    /**\n     * Associates the provided value (and optional state) with the parent form.\n     * @param value - The value to set\n     * @param state - The state object provided to during session restores and when autofilling.\n     */\n\n\n    setFormValue(value, state) {\n      if (this.elementInternals) {\n        this.elementInternals.setFormValue(value, state || value);\n      }\n    }\n\n    _keypressHandler(e) {\n      switch (e.key) {\n        case keyEnter:\n          if (this.form instanceof HTMLFormElement) {\n            // Implicit submission\n            const defaultButton = this.form.querySelector(\"[type=submit]\");\n            defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();\n          }\n\n          break;\n      }\n    }\n    /**\n     * Used to stop propagation of proxy element events\n     * @param e - Event object\n     */\n\n\n    stopPropagation(e) {\n      e.stopPropagation();\n    }\n\n  };\n  attr({\n    mode: \"boolean\"\n  })(C.prototype, \"disabled\");\n  attr({\n    mode: \"fromView\",\n    attribute: \"value\"\n  })(C.prototype, \"initialValue\");\n  attr({\n    attribute: \"current-value\"\n  })(C.prototype, \"currentValue\");\n  attr(C.prototype, \"name\");\n  attr({\n    mode: \"boolean\"\n  })(C.prototype, \"required\");\n  observable(C.prototype, \"value\");\n  return C;\n}\n/**\n * @alpha\n */\n\nexport function CheckableFormAssociated(BaseCtor) {\n  class C extends FormAssociated(BaseCtor) {}\n\n  class D extends C {\n    constructor(...args) {\n      super(args);\n      /**\n       * Tracks whether the \"checked\" property has been changed.\n       * This is necessary to provide consistent behavior with\n       * normal input checkboxes\n       */\n\n      this.dirtyChecked = false;\n      /**\n       * Provides the default checkedness of the input element\n       * Passed down to proxy\n       *\n       * @public\n       * @remarks\n       * HTML Attribute: checked\n       */\n\n      this.checkedAttribute = false;\n      /**\n       * The checked state of the control.\n       *\n       * @public\n       */\n\n      this.checked = false; // Re-initialize dirtyChecked because initialization of other values\n      // causes it to become true\n\n      this.dirtyChecked = false;\n    }\n\n    checkedAttributeChanged() {\n      this.defaultChecked = this.checkedAttribute;\n    }\n    /**\n     * @internal\n     */\n\n\n    defaultCheckedChanged() {\n      if (!this.dirtyChecked) {\n        // Setting this.checked will cause us to enter a dirty state,\n        // but if we are clean when defaultChecked is changed, we want to stay\n        // in a clean state, so reset this.dirtyChecked\n        this.checked = this.defaultChecked;\n        this.dirtyChecked = false;\n      }\n    }\n\n    checkedChanged(prev, next) {\n      if (!this.dirtyChecked) {\n        this.dirtyChecked = true;\n      }\n\n      this.currentChecked = this.checked;\n      this.updateForm();\n\n      if (this.proxy instanceof HTMLInputElement) {\n        this.proxy.checked = this.checked;\n      }\n\n      if (prev !== undefined) {\n        this.$emit(\"change\");\n      }\n\n      this.validate();\n    }\n\n    currentCheckedChanged(prev, next) {\n      this.checked = this.currentChecked;\n    }\n\n    updateForm() {\n      const value = this.checked ? this.value : null;\n      this.setFormValue(value, value);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this.updateForm();\n    }\n\n    formResetCallback() {\n      super.formResetCallback();\n      this.checked = !!this.checkedAttribute;\n      this.dirtyChecked = false;\n    }\n\n  }\n\n  attr({\n    attribute: \"checked\",\n    mode: \"boolean\"\n  })(D.prototype, \"checkedAttribute\");\n  attr({\n    attribute: \"current-checked\",\n    converter: booleanConverter\n  })(D.prototype, \"currentChecked\");\n  observable(D.prototype, \"defaultChecked\");\n  observable(D.prototype, \"checked\");\n  return D;\n}","map":{"version":3,"sources":["D:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-foundation/dist/esm/form-associated/form-associated.js"],"names":["attr","booleanConverter","DOM","emptyArray","observable","keyEnter","proxySlotName","ElementInternalsKey","supportsElementInternals","window","prototype","InternalsMap","WeakMap","FormAssociated","BaseCtor","C","constructor","args","dirtyValue","disabled","proxyEventsToBlock","proxyInitialized","required","initialValue","elementInternals","formResetCallback","bind","formAssociated","validity","proxy","form","validationMessage","willValidate","labels","Object","freeze","Array","from","HTMLElement","ownerDocument","id","parentLabels","forLabels","getRootNode","querySelectorAll","concat","valueChanged","previous","next","value","currentValue","setFormValue","validate","currentValueChanged","initialValueChanged","disabledChanged","queueUpdate","classList","toggle","nameChanged","name","requiredChanged","prev","internals","get","attachInternals","set","connectedCallback","addEventListener","_keypressHandler","attachProxy","disconnectedCallback","forEach","removeEventListener","stopPropagation","checkValidity","reportValidity","setValidity","flags","message","anchor","setCustomValidity","formDisabledCallback","_a","style","display","setAttribute","proxySlot","document","createElement","shadowRoot","appendChild","detachProxy","removeChild","state","e","key","HTMLFormElement","defaultButton","querySelector","click","mode","attribute","CheckableFormAssociated","D","dirtyChecked","checkedAttribute","checked","checkedAttributeChanged","defaultChecked","defaultCheckedChanged","checkedChanged","currentChecked","updateForm","HTMLInputElement","undefined","$emit","currentCheckedChanged","converter"],"mappings":"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","sourcesContent":["import { attr, booleanConverter, DOM, emptyArray, observable, } from \"@microsoft/fast-element\";\nimport { keyEnter } from \"@microsoft/fast-web-utilities\";\nconst proxySlotName = \"form-associated-proxy\";\nconst ElementInternalsKey = \"ElementInternals\";\n/**\n * @alpha\n */\nexport const supportsElementInternals = ElementInternalsKey in window &&\n    \"setFormValue\" in window[ElementInternalsKey].prototype;\nconst InternalsMap = new WeakMap();\n/**\n * Base function for providing Custom Element Form Association.\n *\n * @alpha\n */\nexport function FormAssociated(BaseCtor) {\n    const C = class extends BaseCtor {\n        constructor(...args) {\n            super(...args);\n            /**\n             * Track whether the value has been changed from the initial value\n             */\n            this.dirtyValue = false;\n            /**\n             * Sets the element's disabled state. A disabled element will not be included during form submission.\n             *\n             * @remarks\n             * HTML Attribute: disabled\n             */\n            this.disabled = false;\n            /**\n             * These are events that are still fired by the proxy\n             * element based on user / programmatic interaction.\n             *\n             * The proxy implementation should be transparent to\n             * the app author, so block these events from emitting.\n             */\n            this.proxyEventsToBlock = [\"change\", \"click\"];\n            this.proxyInitialized = false;\n            this.required = false;\n            this.initialValue = this.initialValue || \"\";\n            if (!this.elementInternals) {\n                // When elementInternals is not supported, formResetCallback is\n                // bound to an event listener, so ensure the handler's `this`\n                // context is correct.\n                this.formResetCallback = this.formResetCallback.bind(this);\n            }\n        }\n        /**\n         * Must evaluate to true to enable elementInternals.\n         * Feature detects API support and resolve respectively\n         *\n         * @internal\n         */\n        static get formAssociated() {\n            return supportsElementInternals;\n        }\n        /**\n         * Returns the validity state of the element\n         *\n         * @alpha\n         */\n        get validity() {\n            return this.elementInternals\n                ? this.elementInternals.validity\n                : this.proxy.validity;\n        }\n        /**\n         * Retrieve a reference to the associated form.\n         * Returns null if not associated to any form.\n         *\n         * @alpha\n         */\n        get form() {\n            return this.elementInternals ? this.elementInternals.form : this.proxy.form;\n        }\n        /**\n         * Retrieve the localized validation message,\n         * or custom validation message if set.\n         *\n         * @alpha\n         */\n        get validationMessage() {\n            return this.elementInternals\n                ? this.elementInternals.validationMessage\n                : this.proxy.validationMessage;\n        }\n        /**\n         * Whether the element will be validated when the\n         * form is submitted\n         */\n        get willValidate() {\n            return this.elementInternals\n                ? this.elementInternals.willValidate\n                : this.proxy.willValidate;\n        }\n        /**\n         * A reference to all associated label elements\n         */\n        get labels() {\n            if (this.elementInternals) {\n                return Object.freeze(Array.from(this.elementInternals.labels));\n            }\n            else if (this.proxy instanceof HTMLElement &&\n                this.proxy.ownerDocument &&\n                this.id) {\n                // Labels associated by wrapping the element: <label><custom-element></custom-element></label>\n                const parentLabels = this.proxy.labels;\n                // Labels associated using the `for` attribute\n                const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));\n                const labels = parentLabels\n                    ? forLabels.concat(Array.from(parentLabels))\n                    : forLabels;\n                return Object.freeze(labels);\n            }\n            else {\n                return emptyArray;\n            }\n        }\n        /**\n         * Invoked when the `value` property changes\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `valueChanged` method\n         * They must be sure to invoke `super.valueChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        valueChanged(previous, next) {\n            this.dirtyValue = true;\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.value = this.value;\n            }\n            this.currentValue = this.value;\n            this.setFormValue(this.value);\n            this.validate();\n        }\n        currentValueChanged() {\n            this.value = this.currentValue;\n        }\n        /**\n         * Invoked when the `initialValue` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `initialValueChanged` method\n         * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        initialValueChanged(previous, next) {\n            // If the value is clean and the component is connected to the DOM\n            // then set value equal to the attribute value.\n            if (!this.dirtyValue) {\n                this.value = this.initialValue;\n                this.dirtyValue = false;\n            }\n        }\n        /**\n         * Invoked when the `disabled` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `disabledChanged` method\n         * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        disabledChanged(previous, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.disabled = this.disabled;\n            }\n            DOM.queueUpdate(() => this.classList.toggle(\"disabled\", this.disabled));\n        }\n        /**\n         * Invoked when the `name` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `nameChanged` method\n         * They must be sure to invoke `super.nameChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        nameChanged(previous, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.name = this.name;\n            }\n        }\n        /**\n         * Invoked when the `required` property changes\n         *\n         * @param previous - the previous value\n         * @param next - the new value\n         *\n         * @remarks\n         * If elements extending `FormAssociated` implement a `requiredChanged` method\n         * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure\n         * proper functioning of `FormAssociated`\n         */\n        requiredChanged(prev, next) {\n            if (this.proxy instanceof HTMLElement) {\n                this.proxy.required = this.required;\n            }\n            DOM.queueUpdate(() => this.classList.toggle(\"required\", this.required));\n            this.validate();\n        }\n        /**\n         * The element internals object. Will only exist\n         * in browsers supporting the attachInternals API\n         */\n        get elementInternals() {\n            if (!supportsElementInternals) {\n                return null;\n            }\n            let internals = InternalsMap.get(this);\n            if (!internals) {\n                internals = this.attachInternals();\n                InternalsMap.set(this, internals);\n            }\n            return internals;\n        }\n        /**\n         * @internal\n         */\n        connectedCallback() {\n            super.connectedCallback();\n            this.addEventListener(\"keypress\", this._keypressHandler);\n            if (!this.value) {\n                this.value = this.initialValue;\n                this.dirtyValue = false;\n            }\n            if (!this.elementInternals) {\n                this.attachProxy();\n                if (this.form) {\n                    this.form.addEventListener(\"reset\", this.formResetCallback);\n                }\n            }\n        }\n        /**\n         * @internal\n         */\n        disconnectedCallback() {\n            this.proxyEventsToBlock.forEach(name => this.proxy.removeEventListener(name, this.stopPropagation));\n            if (!this.elementInternals && this.form) {\n                this.form.removeEventListener(\"reset\", this.formResetCallback);\n            }\n        }\n        /**\n         * Return the current validity of the element.\n         */\n        checkValidity() {\n            return this.elementInternals\n                ? this.elementInternals.checkValidity()\n                : this.proxy.checkValidity();\n        }\n        /**\n         * Return the current validity of the element.\n         * If false, fires an invalid event at the element.\n         */\n        reportValidity() {\n            return this.elementInternals\n                ? this.elementInternals.reportValidity()\n                : this.proxy.reportValidity();\n        }\n        /**\n         * Set the validity of the control. In cases when the elementInternals object is not\n         * available (and the proxy element is used to report validity), this function will\n         * do nothing unless a message is provided, at which point the setCustomValidity method\n         * of the proxy element will be invoked with the provided message.\n         * @param flags - Validity flags\n         * @param message - Optional message to supply\n         * @param anchor - Optional element used by UA to display an interactive validation UI\n         */\n        setValidity(flags, message, anchor) {\n            if (this.elementInternals) {\n                this.elementInternals.setValidity(flags, message, anchor);\n            }\n            else if (typeof message === \"string\") {\n                this.proxy.setCustomValidity(message);\n            }\n        }\n        /**\n         * Invoked when a connected component's form or fieldset has its disabled\n         * state changed.\n         * @param disabled - the disabled value of the form / fieldset\n         */\n        formDisabledCallback(disabled) {\n            this.disabled = disabled;\n        }\n        formResetCallback() {\n            this.value = this.initialValue;\n            this.dirtyValue = false;\n        }\n        /**\n         * Attach the proxy element to the DOM\n         */\n        attachProxy() {\n            var _a;\n            if (!this.proxyInitialized) {\n                this.proxyInitialized = true;\n                this.proxy.style.display = \"none\";\n                this.proxyEventsToBlock.forEach(name => this.proxy.addEventListener(name, this.stopPropagation));\n                // These are typically mapped to the proxy during\n                // property change callbacks, but during initialization\n                // on the initial call of the callback, the proxy is\n                // still undefined. We should find a better way to address this.\n                this.proxy.disabled = this.disabled;\n                this.proxy.required = this.required;\n                if (typeof this.name === \"string\") {\n                    this.proxy.name = this.name;\n                }\n                if (typeof this.value === \"string\") {\n                    this.proxy.value = this.value;\n                }\n                this.proxy.setAttribute(\"slot\", proxySlotName);\n                this.proxySlot = document.createElement(\"slot\");\n                this.proxySlot.setAttribute(\"name\", proxySlotName);\n            }\n            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);\n            this.appendChild(this.proxy);\n        }\n        /**\n         * Detach the proxy element from the DOM\n         */\n        detachProxy() {\n            var _a;\n            this.removeChild(this.proxy);\n            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);\n        }\n        /**\n         * Sets the validity of the custom element. By default this uses the proxy element to determine\n         * validity, but this can be extended or replaced in implementation.\n         */\n        validate() {\n            if (this.proxy instanceof HTMLElement) {\n                this.setValidity(this.proxy.validity, this.proxy.validationMessage);\n            }\n        }\n        /**\n         * Associates the provided value (and optional state) with the parent form.\n         * @param value - The value to set\n         * @param state - The state object provided to during session restores and when autofilling.\n         */\n        setFormValue(value, state) {\n            if (this.elementInternals) {\n                this.elementInternals.setFormValue(value, state || value);\n            }\n        }\n        _keypressHandler(e) {\n            switch (e.key) {\n                case keyEnter:\n                    if (this.form instanceof HTMLFormElement) {\n                        // Implicit submission\n                        const defaultButton = this.form.querySelector(\"[type=submit]\");\n                        defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();\n                    }\n                    break;\n            }\n        }\n        /**\n         * Used to stop propagation of proxy element events\n         * @param e - Event object\n         */\n        stopPropagation(e) {\n            e.stopPropagation();\n        }\n    };\n    attr({ mode: \"boolean\" })(C.prototype, \"disabled\");\n    attr({ mode: \"fromView\", attribute: \"value\" })(C.prototype, \"initialValue\");\n    attr({ attribute: \"current-value\" })(C.prototype, \"currentValue\");\n    attr(C.prototype, \"name\");\n    attr({ mode: \"boolean\" })(C.prototype, \"required\");\n    observable(C.prototype, \"value\");\n    return C;\n}\n/**\n * @alpha\n */\nexport function CheckableFormAssociated(BaseCtor) {\n    class C extends FormAssociated(BaseCtor) {\n    }\n    class D extends C {\n        constructor(...args) {\n            super(args);\n            /**\n             * Tracks whether the \"checked\" property has been changed.\n             * This is necessary to provide consistent behavior with\n             * normal input checkboxes\n             */\n            this.dirtyChecked = false;\n            /**\n             * Provides the default checkedness of the input element\n             * Passed down to proxy\n             *\n             * @public\n             * @remarks\n             * HTML Attribute: checked\n             */\n            this.checkedAttribute = false;\n            /**\n             * The checked state of the control.\n             *\n             * @public\n             */\n            this.checked = false;\n            // Re-initialize dirtyChecked because initialization of other values\n            // causes it to become true\n            this.dirtyChecked = false;\n        }\n        checkedAttributeChanged() {\n            this.defaultChecked = this.checkedAttribute;\n        }\n        /**\n         * @internal\n         */\n        defaultCheckedChanged() {\n            if (!this.dirtyChecked) {\n                // Setting this.checked will cause us to enter a dirty state,\n                // but if we are clean when defaultChecked is changed, we want to stay\n                // in a clean state, so reset this.dirtyChecked\n                this.checked = this.defaultChecked;\n                this.dirtyChecked = false;\n            }\n        }\n        checkedChanged(prev, next) {\n            if (!this.dirtyChecked) {\n                this.dirtyChecked = true;\n            }\n            this.currentChecked = this.checked;\n            this.updateForm();\n            if (this.proxy instanceof HTMLInputElement) {\n                this.proxy.checked = this.checked;\n            }\n            if (prev !== undefined) {\n                this.$emit(\"change\");\n            }\n            this.validate();\n        }\n        currentCheckedChanged(prev, next) {\n            this.checked = this.currentChecked;\n        }\n        updateForm() {\n            const value = this.checked ? this.value : null;\n            this.setFormValue(value, value);\n        }\n        connectedCallback() {\n            super.connectedCallback();\n            this.updateForm();\n        }\n        formResetCallback() {\n            super.formResetCallback();\n            this.checked = !!this.checkedAttribute;\n            this.dirtyChecked = false;\n        }\n    }\n    attr({ attribute: \"checked\", mode: \"boolean\" })(D.prototype, \"checkedAttribute\");\n    attr({ attribute: \"current-checked\", converter: booleanConverter })(D.prototype, \"currentChecked\");\n    observable(D.prototype, \"defaultChecked\");\n    observable(D.prototype, \"checked\");\n    return D;\n}\n"]},"metadata":{},"sourceType":"module"}