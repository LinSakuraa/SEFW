{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/**\n * The original package is https://www.npmjs.com/package/textarea-caret-ts\n * The original file is https://github.com/TheRealSyler/textarea-caret-position/blob/master/index.ts\n *\n * Here I modified it to make it works when input is scrolled.\n */\n\n/**\n * Returns the Absolute (relative to the inner window size) position of the caret in the given element.\n * @param element Input (has to be type='text') or Text Area.\n */\nexport function getAbsolutePosition(element) {\n  const caretRelPost = getRelativePosition(element);\n  return {\n    left: window.scrollX + element.getBoundingClientRect().left + caretRelPost.left,\n    top: window.scrollY + element.getBoundingClientRect().top + caretRelPost.top,\n    absolute: true,\n    height: caretRelPost.height\n  };\n}\n/**\n * Returns the relative position of the caret in the given element.\n * @param element Input (has to be type='text') or Text Area.\n */\n\nexport function getRelativePosition(element, options = {\n  debug: false,\n  useSelectionEnd: false,\n  checkWidthOverflow: true\n}) {\n  const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;\n  const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;\n  const position = options.useSelectionEnd ? selectionEnd : selectionStart; // We'll copy the properties below into the mirror div.\n  // Note that some browsers, such as Firefox, do not concatenate properties\n  // into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n  // so we have to list every single property explicitly.\n\n  const properties = ['direction', 'boxSizing', 'width', 'height', 'overflowX', 'overflowY', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderStyle', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'fontSizeAdjust', 'lineHeight', 'fontFamily', 'textAlign', 'textTransform', 'textIndent', 'textDecoration', 'letterSpacing', 'wordSpacing', 'tabSize', 'MozTabSize']; // Firefox 1.0+\n\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const isBrowser = typeof window !== 'undefined';\n\n  if (!isBrowser) {\n    throw new Error('textarea-caret-position#getCaretPosition should only be called in a browser');\n  }\n\n  const debug = options === null || options === void 0 ? void 0 : options.debug;\n\n  if (debug) {\n    const el = document.querySelector('#input-textarea-caret-position-mirror-div');\n    if (el === null || el === void 0 ? void 0 : el.parentNode) el.parentNode.removeChild(el);\n  } // The mirror div will replicate the textareas style\n\n\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n  const style = div.style;\n  const computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle; // currentStyle for IE < 9\n\n  const isInput = element.nodeName === 'INPUT'; // Default textarea styles\n\n  style.whiteSpace = isInput ? 'nowrap' : 'pre-wrap';\n  if (!isInput) style.wordWrap = 'break-word'; // only for textarea-s\n  // Position off-screen\n\n  style.position = 'absolute'; // required to return coordinates properly\n\n  if (!debug) style.visibility = 'hidden'; // not 'display: none' because we want rendering\n  // Transfer the element's properties to the div\n\n  properties.forEach(prop => {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height);\n        const outerHeight = parseInt(computed.paddingTop) + parseInt(computed.paddingBottom) + parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth);\n        const targetHeight = outerHeight + parseInt(computed.lineHeight);\n\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = '0';\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height)) {\n      style.overflowY = 'scroll';\n    }\n  } else {\n    style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, position); // The second special handling for input type=\"text\" vs textarea:\n  // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n\n  if (isInput && div.textContent) {\n    div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n  }\n\n  const span = document.createElement('span'); // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textareas content into the <span> created at the caret position.\n  // For inputs, just '.' would be enough, but no need to bother.\n\n  span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all\n\n  span.style.position = 'relative';\n  span.style.left = `${-element.scrollLeft}px`;\n  span.style.top = `${-element.scrollTop}px`;\n  div.appendChild(span);\n  const relativePosition = {\n    top: span.offsetTop + parseInt(computed.borderTopWidth),\n    left: span.offsetLeft + parseInt(computed.borderLeftWidth),\n    absolute: false,\n    // We don't use line-height since it may be too large for position. Eg. 34px\n    // for input\n    height: parseInt(computed.fontSize) * 1.5\n  };\n\n  if (debug) {\n    span.style.backgroundColor = '#aaa';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  if (relativePosition.left >= element.clientWidth && options.checkWidthOverflow) {\n    relativePosition.left = element.clientWidth;\n  }\n\n  return relativePosition;\n}\n/**\n * sets the top and left css style of the element based on the absolute position of the caretElements caret,\n * @param offset offsets the position.\n * @param detectBoundary offsets the position if the position would be outside the window.\n * @param returnOnly if true the element position wont be set.\n */\n\nexport function setElementPositionBasedOnCaret(element, caretElement, offset = {\n  top: 0,\n  left: 0\n}, margin = 2, detectBoundary = true, returnOnly = false) {\n  const pos = getAbsolutePosition(caretElement);\n\n  if (detectBoundary) {\n    pos.left = pos.left + (element.clientWidth + margin) + offset.left > window.scrollX + window.innerWidth ? pos.left = window.scrollX + window.innerWidth - (element.clientWidth + margin) : pos.left += offset.left;\n    pos.top = pos.top + (element.clientWidth + margin) + offset.top > window.scrollY + window.innerHeight ? pos.top -= element.clientWidth + margin : pos.top += offset.top;\n  } else {\n    pos.top += offset.top;\n    pos.left += offset.left;\n  }\n\n  if (!returnOnly) {\n    element.style.top = `${pos.top}px`;\n    element.style.left = `${pos.left}px`;\n  }\n\n  return pos;\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/mention/src/utils.js"],"names":["getAbsolutePosition","element","caretRelPost","getRelativePosition","left","window","scrollX","getBoundingClientRect","top","scrollY","absolute","height","options","debug","useSelectionEnd","checkWidthOverflow","selectionStart","selectionEnd","position","properties","isFirefox","navigator","userAgent","toLowerCase","includes","isBrowser","Error","el","document","querySelector","parentNode","removeChild","div","createElement","id","body","appendChild","style","computed","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","visibility","forEach","prop","boxSizing","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","scrollHeight","overflowY","overflow","textContent","value","substring","replace","span","scrollLeft","scrollTop","relativePosition","offsetTop","offsetLeft","borderLeftWidth","fontSize","backgroundColor","clientWidth","setElementPositionBasedOnCaret","caretElement","offset","margin","detectBoundary","returnOnly","pos","innerWidth","innerHeight"],"mappings":"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","sourcesContent":["/**\n * The original package is https://www.npmjs.com/package/textarea-caret-ts\n * The original file is https://github.com/TheRealSyler/textarea-caret-position/blob/master/index.ts\n *\n * Here I modified it to make it works when input is scrolled.\n */\n/**\n * Returns the Absolute (relative to the inner window size) position of the caret in the given element.\n * @param element Input (has to be type='text') or Text Area.\n */\nexport function getAbsolutePosition(element) {\n    const caretRelPost = getRelativePosition(element);\n    return {\n        left: window.scrollX + element.getBoundingClientRect().left + caretRelPost.left,\n        top: window.scrollY + element.getBoundingClientRect().top + caretRelPost.top,\n        absolute: true,\n        height: caretRelPost.height\n    };\n}\n/**\n * Returns the relative position of the caret in the given element.\n * @param element Input (has to be type='text') or Text Area.\n */\nexport function getRelativePosition(element, options = {\n    debug: false,\n    useSelectionEnd: false,\n    checkWidthOverflow: true\n}) {\n    const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;\n    const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;\n    const position = options.useSelectionEnd ? selectionEnd : selectionStart;\n    // We'll copy the properties below into the mirror div.\n    // Note that some browsers, such as Firefox, do not concatenate properties\n    // into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n    // so we have to list every single property explicitly.\n    const properties = [\n        'direction',\n        'boxSizing',\n        'width',\n        'height',\n        'overflowX',\n        'overflowY',\n        'borderTopWidth',\n        'borderRightWidth',\n        'borderBottomWidth',\n        'borderLeftWidth',\n        'borderStyle',\n        'paddingTop',\n        'paddingRight',\n        'paddingBottom',\n        'paddingLeft',\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n        'fontStyle',\n        'fontVariant',\n        'fontWeight',\n        'fontStretch',\n        'fontSize',\n        'fontSizeAdjust',\n        'lineHeight',\n        'fontFamily',\n        'textAlign',\n        'textTransform',\n        'textIndent',\n        'textDecoration',\n        'letterSpacing',\n        'wordSpacing',\n        'tabSize',\n        'MozTabSize'\n    ];\n    // Firefox 1.0+\n    const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n    const isBrowser = typeof window !== 'undefined';\n    if (!isBrowser) {\n        throw new Error('textarea-caret-position#getCaretPosition should only be called in a browser');\n    }\n    const debug = options === null || options === void 0 ? void 0 : options.debug;\n    if (debug) {\n        const el = document.querySelector('#input-textarea-caret-position-mirror-div');\n        if (el === null || el === void 0 ? void 0 : el.parentNode)\n            el.parentNode.removeChild(el);\n    }\n    // The mirror div will replicate the textareas style\n    const div = document.createElement('div');\n    div.id = 'input-textarea-caret-position-mirror-div';\n    document.body.appendChild(div);\n    const style = div.style;\n    const computed = window.getComputedStyle\n        ? window.getComputedStyle(element)\n        : element.currentStyle; // currentStyle for IE < 9\n    const isInput = element.nodeName === 'INPUT';\n    // Default textarea styles\n    style.whiteSpace = isInput ? 'nowrap' : 'pre-wrap';\n    if (!isInput)\n        style.wordWrap = 'break-word'; // only for textarea-s\n    // Position off-screen\n    style.position = 'absolute'; // required to return coordinates properly\n    if (!debug)\n        style.visibility = 'hidden'; // not 'display: none' because we want rendering\n    // Transfer the element's properties to the div\n    properties.forEach((prop) => {\n        if (isInput && prop === 'lineHeight') {\n            // Special case for <input>s because text is rendered centered and line height may be != height\n            if (computed.boxSizing === 'border-box') {\n                const height = parseInt(computed.height);\n                const outerHeight = parseInt(computed.paddingTop) +\n                    parseInt(computed.paddingBottom) +\n                    parseInt(computed.borderTopWidth) +\n                    parseInt(computed.borderBottomWidth);\n                const targetHeight = outerHeight + parseInt(computed.lineHeight);\n                if (height > targetHeight) {\n                    style.lineHeight = `${height - outerHeight}px`;\n                }\n                else if (height === targetHeight) {\n                    style.lineHeight = computed.lineHeight;\n                }\n                else {\n                    style.lineHeight = '0';\n                }\n            }\n            else {\n                style.lineHeight = computed.height;\n            }\n        }\n        else {\n            style[prop] = computed[prop];\n        }\n    });\n    if (isFirefox) {\n        // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n        if (element.scrollHeight > parseInt(computed.height)) {\n            style.overflowY = 'scroll';\n        }\n    }\n    else {\n        style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n    }\n    div.textContent = element.value.substring(0, position);\n    // The second special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput && div.textContent) {\n        div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n    }\n    const span = document.createElement('span');\n    // Wrapping must be replicated *exactly*, including when a long word gets\n    // onto the next line, with whitespace at the end of the line before (#7).\n    // The  *only* reliable way to do that is to copy the *entire* rest of the\n    // textareas content into the <span> created at the caret position.\n    // For inputs, just '.' would be enough, but no need to bother.\n    span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all\n    span.style.position = 'relative';\n    span.style.left = `${-element.scrollLeft}px`;\n    span.style.top = `${-element.scrollTop}px`;\n    div.appendChild(span);\n    const relativePosition = {\n        top: span.offsetTop + parseInt(computed.borderTopWidth),\n        left: span.offsetLeft + parseInt(computed.borderLeftWidth),\n        absolute: false,\n        // We don't use line-height since it may be too large for position. Eg. 34px\n        // for input\n        height: parseInt(computed.fontSize) * 1.5\n    };\n    if (debug) {\n        span.style.backgroundColor = '#aaa';\n    }\n    else {\n        document.body.removeChild(div);\n    }\n    if (relativePosition.left >= element.clientWidth &&\n        options.checkWidthOverflow) {\n        relativePosition.left = element.clientWidth;\n    }\n    return relativePosition;\n}\n/**\n * sets the top and left css style of the element based on the absolute position of the caretElements caret,\n * @param offset offsets the position.\n * @param detectBoundary offsets the position if the position would be outside the window.\n * @param returnOnly if true the element position wont be set.\n */\nexport function setElementPositionBasedOnCaret(element, caretElement, offset = { top: 0, left: 0 }, margin = 2, detectBoundary = true, returnOnly = false) {\n    const pos = getAbsolutePosition(caretElement);\n    if (detectBoundary) {\n        pos.left =\n            pos.left + (element.clientWidth + margin) + offset.left >\n                window.scrollX + window.innerWidth\n                ? (pos.left =\n                    window.scrollX + window.innerWidth - (element.clientWidth + margin))\n                : (pos.left += offset.left);\n        pos.top =\n            pos.top + (element.clientWidth + margin) + offset.top >\n                window.scrollY + window.innerHeight\n                ? (pos.top -= element.clientWidth + margin)\n                : (pos.top += offset.top);\n    }\n    else {\n        pos.top += offset.top;\n        pos.left += offset.left;\n    }\n    if (!returnOnly) {\n        element.style.top = `${pos.top}px`;\n        element.style.left = `${pos.left}px`;\n    }\n    return pos;\n}\n"]},"metadata":{},"sourceType":"module"}