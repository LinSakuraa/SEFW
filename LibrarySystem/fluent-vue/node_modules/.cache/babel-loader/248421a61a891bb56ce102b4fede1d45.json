{"ast":null,"code":"import { computed, ref } from 'vue';\nimport { getFlagOfOrder } from './utils';\nimport { call } from '../../_utils';\n\nfunction getMultiplePriority(sorter) {\n  if (typeof sorter === 'object' && typeof sorter.multiple === 'number') {\n    return sorter.multiple;\n  }\n\n  return false;\n}\n\nfunction getSortFunction(sorter, columnKey) {\n  if (columnKey && (sorter === undefined || sorter === 'default' || typeof sorter === 'object' && sorter.compare === 'default')) {\n    return getDefaultSorterFn(columnKey);\n  }\n\n  if (typeof sorter === 'function') {\n    return sorter;\n  }\n\n  if (sorter && typeof sorter === 'object' && sorter.compare && sorter.compare !== 'default') {\n    return sorter.compare;\n  }\n\n  return false;\n}\n\nfunction getDefaultSorterFn(columnKey) {\n  return (row1, row2) => {\n    const value1 = row1[columnKey];\n    const value2 = row2[columnKey];\n\n    if (typeof value1 === 'number' && typeof value2 === 'number') {\n      return value1 - value2;\n    } else if (typeof value1 === 'string' && typeof value2 === 'string') {\n      return value1.localeCompare(value2);\n    }\n\n    return 0;\n  };\n} // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nexport function useSorter(props, {\n  dataRelatedColsRef,\n  filteredDataRef\n}) {\n  const defaultSortState = []; // initialize\n\n  dataRelatedColsRef.value.forEach(column => {\n    var _a;\n\n    if (column.sorter !== undefined) {\n      updateSortStatesByNewSortState(defaultSortState, {\n        columnKey: column.key,\n        sorter: column.sorter,\n        order: (_a = column.defaultSortOrder) !== null && _a !== void 0 ? _a : false\n      });\n    }\n  });\n  const uncontrolledSortStateRef = ref(defaultSortState);\n  const mergedSortStateRef = computed(() => {\n    // If one of the columns's sort order is false or 'ascend' or 'descend',\n    // the table's controll functionality should work in controlled manner.\n    const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter(column => column.type !== 'selection' && column.sorter !== undefined && (column.sortOrder === 'ascend' || column.sortOrder === 'descend' || column.sortOrder === false)); // if multiple columns are controlled sortable, then we need to find columns with active sortOrder\n\n    const columnToSort = columnsWithControlledSortOrder.filter(col => col.sortOrder !== false);\n\n    if (columnToSort.length) {\n      return columnToSort.map(column => {\n        return {\n          columnKey: column.key,\n          // column to sort has controlled sorter\n          // sorter && sort order won't be undefined\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          order: column.sortOrder,\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          sorter: column.sorter\n        };\n      });\n    } // If any column is in controlled mode, the sorting state of the table is\n    // in controlled mode\n\n\n    if (columnsWithControlledSortOrder.length) return [];\n    const {\n      value: uncontrolledSortState\n    } = uncontrolledSortStateRef;\n\n    if (Array.isArray(uncontrolledSortState)) {\n      return uncontrolledSortState;\n    } else if (uncontrolledSortState) {\n      return [uncontrolledSortState];\n    } else {\n      return [];\n    }\n  });\n  const sortedDataRef = computed(() => {\n    const activeSorters = mergedSortStateRef.value.slice().sort((a, b) => {\n      const item1Priority = getMultiplePriority(a.sorter) || 0;\n      const item2Priority = getMultiplePriority(b.sorter) || 0;\n      return item2Priority - item1Priority;\n    });\n\n    if (activeSorters.length) {\n      const filteredData = filteredDataRef.value.slice();\n      return filteredData.sort((tmNode1, tmNode2) => {\n        let compareResult = 0;\n        activeSorters.some(sorterState => {\n          const {\n            columnKey,\n            sorter,\n            order\n          } = sorterState;\n          const compareFn = getSortFunction(sorter, columnKey);\n\n          if (compareFn && order) {\n            compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);\n\n            if (compareResult !== 0) {\n              compareResult = compareResult * getFlagOfOrder(order);\n              return true;\n            }\n          }\n\n          return false;\n        });\n        return compareResult;\n      });\n    }\n\n    return filteredDataRef.value;\n  });\n\n  function getUpdatedSorterState(sortState) {\n    let currentSortState = mergedSortStateRef.value.slice(); // Multiple sorter (if you clicked on a multiple sort column)\n\n    if (sortState && getMultiplePriority(sortState.sorter) !== false) {\n      // clear column is not multiple sort\n      currentSortState = currentSortState.filter(sortState => getMultiplePriority(sortState.sorter) !== false);\n      updateSortStatesByNewSortState(currentSortState, sortState);\n      return currentSortState;\n    } else if (sortState) {\n      // single sorter\n      return sortState;\n    } // no sorter\n\n\n    return null;\n  }\n\n  function deriveNextSorter(sortState) {\n    const nextSorterState = getUpdatedSorterState(sortState);\n    doUpdateSorter(nextSorterState);\n  }\n\n  function doUpdateSorter(sortState) {\n    const {\n      'onUpdate:sorter': _onUpdateSorter,\n      onUpdateSorter,\n      onSorterChange\n    } = props;\n\n    if (_onUpdateSorter) {\n      call(_onUpdateSorter, sortState);\n    }\n\n    if (onUpdateSorter) {\n      call(onUpdateSorter, sortState);\n    }\n\n    if (onSorterChange) {\n      call(onSorterChange, sortState);\n    }\n\n    uncontrolledSortStateRef.value = sortState;\n  }\n\n  function sort(columnKey, order = 'ascend') {\n    if (!columnKey) {\n      clearSorter();\n    } else {\n      const columnToSort = dataRelatedColsRef.value.find(column => column.type !== 'selection' && column.type !== 'expand' && column.key === columnKey);\n      if (!columnToSort || !columnToSort.sorter) return;\n      const sorter = columnToSort.sorter;\n      deriveNextSorter({\n        columnKey,\n        sorter,\n        order: order\n      });\n    }\n  }\n\n  function clearSorter() {\n    doUpdateSorter(null);\n  }\n\n  function updateSortStatesByNewSortState(sortStates, sortState) {\n    const index = sortStates.findIndex(state => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);\n\n    if (index !== undefined && index >= 0) {\n      sortStates[index] = sortState;\n    } else {\n      sortStates.push(sortState);\n    }\n  }\n\n  return {\n    clearSorter,\n    sort,\n    sortedDataRef,\n    mergedSortStateRef,\n    deriveNextSorter\n  };\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/naive-ui/es/data-table/src/use-sorter.js"],"names":["computed","ref","getFlagOfOrder","call","getMultiplePriority","sorter","multiple","getSortFunction","columnKey","undefined","compare","getDefaultSorterFn","row1","row2","value1","value2","localeCompare","useSorter","props","dataRelatedColsRef","filteredDataRef","defaultSortState","value","forEach","column","_a","updateSortStatesByNewSortState","key","order","defaultSortOrder","uncontrolledSortStateRef","mergedSortStateRef","columnsWithControlledSortOrder","filter","type","sortOrder","columnToSort","col","length","map","uncontrolledSortState","Array","isArray","sortedDataRef","activeSorters","slice","sort","a","b","item1Priority","item2Priority","filteredData","tmNode1","tmNode2","compareResult","some","sorterState","compareFn","rawNode","getUpdatedSorterState","sortState","currentSortState","deriveNextSorter","nextSorterState","doUpdateSorter","_onUpdateSorter","onUpdateSorter","onSorterChange","clearSorter","find","sortStates","index","findIndex","state","push"],"mappings":"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","sourcesContent":["import { computed, ref } from 'vue';\nimport { getFlagOfOrder } from './utils';\nimport { call } from '../../_utils';\nfunction getMultiplePriority(sorter) {\n    if (typeof sorter === 'object' && typeof sorter.multiple === 'number') {\n        return sorter.multiple;\n    }\n    return false;\n}\nfunction getSortFunction(sorter, columnKey) {\n    if (columnKey &&\n        (sorter === undefined ||\n            sorter === 'default' ||\n            (typeof sorter === 'object' && sorter.compare === 'default'))) {\n        return getDefaultSorterFn(columnKey);\n    }\n    if (typeof sorter === 'function') {\n        return sorter;\n    }\n    if (sorter &&\n        typeof sorter === 'object' &&\n        sorter.compare &&\n        sorter.compare !== 'default') {\n        return sorter.compare;\n    }\n    return false;\n}\nfunction getDefaultSorterFn(columnKey) {\n    return (row1, row2) => {\n        const value1 = row1[columnKey];\n        const value2 = row2[columnKey];\n        if (typeof value1 === 'number' && typeof value2 === 'number') {\n            return value1 - value2;\n        }\n        else if (typeof value1 === 'string' && typeof value2 === 'string') {\n            return value1.localeCompare(value2);\n        }\n        return 0;\n    };\n}\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function useSorter(props, { dataRelatedColsRef, filteredDataRef }) {\n    const defaultSortState = [];\n    // initialize\n    dataRelatedColsRef.value.forEach((column) => {\n        var _a;\n        if (column.sorter !== undefined) {\n            updateSortStatesByNewSortState(defaultSortState, {\n                columnKey: column.key,\n                sorter: column.sorter,\n                order: (_a = column.defaultSortOrder) !== null && _a !== void 0 ? _a : false\n            });\n        }\n    });\n    const uncontrolledSortStateRef = ref(defaultSortState);\n    const mergedSortStateRef = computed(() => {\n        // If one of the columns's sort order is false or 'ascend' or 'descend',\n        // the table's controll functionality should work in controlled manner.\n        const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter((column) => column.type !== 'selection' &&\n            column.sorter !== undefined &&\n            (column.sortOrder === 'ascend' ||\n                column.sortOrder === 'descend' ||\n                column.sortOrder === false));\n        // if multiple columns are controlled sortable, then we need to find columns with active sortOrder\n        const columnToSort = columnsWithControlledSortOrder.filter((col) => col.sortOrder !== false);\n        if (columnToSort.length) {\n            return columnToSort.map((column) => {\n                return {\n                    columnKey: column.key,\n                    // column to sort has controlled sorter\n                    // sorter && sort order won't be undefined\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    order: column.sortOrder,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    sorter: column.sorter\n                };\n            });\n        }\n        // If any column is in controlled mode, the sorting state of the table is\n        // in controlled mode\n        if (columnsWithControlledSortOrder.length)\n            return [];\n        const { value: uncontrolledSortState } = uncontrolledSortStateRef;\n        if (Array.isArray(uncontrolledSortState)) {\n            return uncontrolledSortState;\n        }\n        else if (uncontrolledSortState) {\n            return [uncontrolledSortState];\n        }\n        else {\n            return [];\n        }\n    });\n    const sortedDataRef = computed(() => {\n        const activeSorters = mergedSortStateRef.value.slice().sort((a, b) => {\n            const item1Priority = getMultiplePriority(a.sorter) || 0;\n            const item2Priority = getMultiplePriority(b.sorter) || 0;\n            return item2Priority - item1Priority;\n        });\n        if (activeSorters.length) {\n            const filteredData = filteredDataRef.value.slice();\n            return filteredData.sort((tmNode1, tmNode2) => {\n                let compareResult = 0;\n                activeSorters.some((sorterState) => {\n                    const { columnKey, sorter, order } = sorterState;\n                    const compareFn = getSortFunction(sorter, columnKey);\n                    if (compareFn && order) {\n                        compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);\n                        if (compareResult !== 0) {\n                            compareResult = compareResult * getFlagOfOrder(order);\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                return compareResult;\n            });\n        }\n        return filteredDataRef.value;\n    });\n    function getUpdatedSorterState(sortState) {\n        let currentSortState = mergedSortStateRef.value.slice();\n        // Multiple sorter (if you clicked on a multiple sort column)\n        if (sortState && getMultiplePriority(sortState.sorter) !== false) {\n            // clear column is not multiple sort\n            currentSortState = currentSortState.filter((sortState) => getMultiplePriority(sortState.sorter) !== false);\n            updateSortStatesByNewSortState(currentSortState, sortState);\n            return currentSortState;\n        }\n        else if (sortState) {\n            // single sorter\n            return sortState;\n        }\n        // no sorter\n        return null;\n    }\n    function deriveNextSorter(sortState) {\n        const nextSorterState = getUpdatedSorterState(sortState);\n        doUpdateSorter(nextSorterState);\n    }\n    function doUpdateSorter(sortState) {\n        const { 'onUpdate:sorter': _onUpdateSorter, onUpdateSorter, onSorterChange } = props;\n        if (_onUpdateSorter) {\n            call(_onUpdateSorter, sortState);\n        }\n        if (onUpdateSorter) {\n            call(onUpdateSorter, sortState);\n        }\n        if (onSorterChange) {\n            call(onSorterChange, sortState);\n        }\n        uncontrolledSortStateRef.value = sortState;\n    }\n    function sort(columnKey, order = 'ascend') {\n        if (!columnKey) {\n            clearSorter();\n        }\n        else {\n            const columnToSort = dataRelatedColsRef.value.find((column) => column.type !== 'selection' &&\n                column.type !== 'expand' &&\n                column.key === columnKey);\n            if (!columnToSort || !columnToSort.sorter)\n                return;\n            const sorter = columnToSort.sorter;\n            deriveNextSorter({\n                columnKey,\n                sorter,\n                order: order\n            });\n        }\n    }\n    function clearSorter() {\n        doUpdateSorter(null);\n    }\n    function updateSortStatesByNewSortState(sortStates, sortState) {\n        const index = sortStates.findIndex((state) => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);\n        if (index !== undefined && index >= 0) {\n            sortStates[index] = sortState;\n        }\n        else {\n            sortStates.push(sortState);\n        }\n    }\n    return {\n        clearSorter,\n        sort,\n        sortedDataRef,\n        mergedSortStateRef,\n        deriveNextSorter\n    };\n}\n"]},"metadata":{},"sourceType":"module"}