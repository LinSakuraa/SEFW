{"ast":null,"code":"import { DOM } from \"../dom\";\nimport { defaultExecutionContext } from \"../observation/observable\";\nimport { compileTemplate } from \"./compiler\";\nimport { HTMLView } from \"./view\";\nimport { HTMLDirective, TargetedHTMLDirective } from \"./html-directive\";\nimport { HTMLBindingDirective } from \"./binding\";\n/**\n * A template capable of creating HTMLView instances or rendering directly to DOM.\n * @public\n */\n\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\nexport class ViewTemplate {\n  /**\n   * Creates an instance of ViewTemplate.\n   * @param html - The html representing what this template will instantiate, including placeholders for directives.\n   * @param directives - The directives that will be connected to placeholders in the html.\n   */\n  constructor(html, directives) {\n    this.behaviorCount = 0;\n    this.hasHostBehaviors = false;\n    this.fragment = null;\n    this.targetOffset = 0;\n    this.viewBehaviorFactories = null;\n    this.hostBehaviorFactories = null;\n    this.html = html;\n    this.directives = directives;\n  }\n  /**\n   * Creates an HTMLView instance based on this template definition.\n   * @param hostBindingTarget - The element that host behaviors will be bound to.\n   */\n\n\n  create(hostBindingTarget) {\n    if (this.fragment === null) {\n      let template;\n      const html = this.html;\n\n      if (typeof html === \"string\") {\n        template = document.createElement(\"template\");\n        template.innerHTML = DOM.createHTML(html);\n        const fec = template.content.firstElementChild;\n\n        if (fec !== null && fec.tagName === \"TEMPLATE\") {\n          template = fec;\n        }\n      } else {\n        template = html;\n      }\n\n      const result = compileTemplate(template, this.directives);\n      this.fragment = result.fragment;\n      this.viewBehaviorFactories = result.viewBehaviorFactories;\n      this.hostBehaviorFactories = result.hostBehaviorFactories;\n      this.targetOffset = result.targetOffset;\n      this.behaviorCount = this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;\n      this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;\n    }\n\n    const fragment = this.fragment.cloneNode(true);\n    const viewFactories = this.viewBehaviorFactories;\n    const behaviors = new Array(this.behaviorCount);\n    const walker = DOM.createTemplateWalker(fragment);\n    let behaviorIndex = 0;\n    let targetIndex = this.targetOffset;\n    let node = walker.nextNode();\n\n    for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {\n      const factory = viewFactories[behaviorIndex];\n      const factoryIndex = factory.targetIndex;\n\n      while (node !== null) {\n        if (targetIndex === factoryIndex) {\n          behaviors[behaviorIndex] = factory.createBehavior(node);\n          break;\n        } else {\n          node = walker.nextNode();\n          targetIndex++;\n        }\n      }\n    }\n\n    if (this.hasHostBehaviors) {\n      const hostFactories = this.hostBehaviorFactories;\n\n      for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {\n        behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);\n      }\n    }\n\n    return new HTMLView(fragment, behaviors);\n  }\n  /**\n   * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.\n   * @param source - The data source to bind the template to.\n   * @param host - The Element where the template will be rendered.\n   * @param hostBindingTarget - An HTML element to target the host bindings at if different from the\n   * host that the template is being attached to.\n   */\n\n\n  render(source, host, hostBindingTarget) {\n    if (typeof host === \"string\") {\n      host = document.getElementById(host);\n    }\n\n    if (hostBindingTarget === void 0) {\n      hostBindingTarget = host;\n    }\n\n    const view = this.create(hostBindingTarget);\n    view.bind(source, defaultExecutionContext);\n    view.appendTo(host);\n    return view;\n  }\n\n} // Much thanks to LitHTML for working this out!\n\nconst lastAttributeNameRegex =\n/* eslint-disable-next-line no-control-regex */\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n/**\n * Transforms a template literal string into a renderable ViewTemplate.\n * @param strings - The string fragments that are interpolated with the values.\n * @param values - The values that are interpolated with the string fragments.\n * @remarks\n * The html helper supports interpolation of strings, numbers, binding expressions,\n * other template instances, and Directive instances.\n * @public\n */\n\nexport function html(strings, ...values) {\n  const directives = [];\n  let html = \"\";\n\n  for (let i = 0, ii = strings.length - 1; i < ii; ++i) {\n    const currentString = strings[i];\n    let value = values[i];\n    html += currentString;\n\n    if (value instanceof ViewTemplate) {\n      const template = value;\n\n      value = () => template;\n    }\n\n    if (typeof value === \"function\") {\n      value = new HTMLBindingDirective(value);\n    }\n\n    if (value instanceof TargetedHTMLDirective) {\n      const match = lastAttributeNameRegex.exec(currentString);\n\n      if (match !== null) {\n        value.targetName = match[2];\n      }\n    }\n\n    if (value instanceof HTMLDirective) {\n      // Since not all values are directives, we can't use i\n      // as the index for the placeholder. Instead, we need to\n      // use directives.length to get the next index.\n      html += value.createPlaceholder(directives.length);\n      directives.push(value);\n    } else {\n      html += value;\n    }\n  }\n\n  html += strings[strings.length - 1];\n  return new ViewTemplate(html, directives);\n}","map":{"version":3,"sources":["G:/VUE_FDS/fluent-vue/node_modules/@microsoft/fast-element/dist/esm/templating/template.js"],"names":["DOM","defaultExecutionContext","compileTemplate","HTMLView","HTMLDirective","TargetedHTMLDirective","HTMLBindingDirective","ViewTemplate","constructor","html","directives","behaviorCount","hasHostBehaviors","fragment","targetOffset","viewBehaviorFactories","hostBehaviorFactories","create","hostBindingTarget","template","document","createElement","innerHTML","createHTML","fec","content","firstElementChild","tagName","result","length","cloneNode","viewFactories","behaviors","Array","walker","createTemplateWalker","behaviorIndex","targetIndex","node","nextNode","ii","factory","factoryIndex","createBehavior","hostFactories","i","render","source","host","getElementById","view","bind","appendTo","lastAttributeNameRegex","strings","values","currentString","value","match","exec","targetName","createPlaceholder","push"],"mappings":"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","sourcesContent":["import { DOM } from \"../dom\";\nimport { defaultExecutionContext } from \"../observation/observable\";\nimport { compileTemplate } from \"./compiler\";\nimport { HTMLView } from \"./view\";\nimport { HTMLDirective, TargetedHTMLDirective, } from \"./html-directive\";\nimport { HTMLBindingDirective } from \"./binding\";\n/**\n * A template capable of creating HTMLView instances or rendering directly to DOM.\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\nexport class ViewTemplate {\n    /**\n     * Creates an instance of ViewTemplate.\n     * @param html - The html representing what this template will instantiate, including placeholders for directives.\n     * @param directives - The directives that will be connected to placeholders in the html.\n     */\n    constructor(html, directives) {\n        this.behaviorCount = 0;\n        this.hasHostBehaviors = false;\n        this.fragment = null;\n        this.targetOffset = 0;\n        this.viewBehaviorFactories = null;\n        this.hostBehaviorFactories = null;\n        this.html = html;\n        this.directives = directives;\n    }\n    /**\n     * Creates an HTMLView instance based on this template definition.\n     * @param hostBindingTarget - The element that host behaviors will be bound to.\n     */\n    create(hostBindingTarget) {\n        if (this.fragment === null) {\n            let template;\n            const html = this.html;\n            if (typeof html === \"string\") {\n                template = document.createElement(\"template\");\n                template.innerHTML = DOM.createHTML(html);\n                const fec = template.content.firstElementChild;\n                if (fec !== null && fec.tagName === \"TEMPLATE\") {\n                    template = fec;\n                }\n            }\n            else {\n                template = html;\n            }\n            const result = compileTemplate(template, this.directives);\n            this.fragment = result.fragment;\n            this.viewBehaviorFactories = result.viewBehaviorFactories;\n            this.hostBehaviorFactories = result.hostBehaviorFactories;\n            this.targetOffset = result.targetOffset;\n            this.behaviorCount =\n                this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;\n            this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;\n        }\n        const fragment = this.fragment.cloneNode(true);\n        const viewFactories = this.viewBehaviorFactories;\n        const behaviors = new Array(this.behaviorCount);\n        const walker = DOM.createTemplateWalker(fragment);\n        let behaviorIndex = 0;\n        let targetIndex = this.targetOffset;\n        let node = walker.nextNode();\n        for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {\n            const factory = viewFactories[behaviorIndex];\n            const factoryIndex = factory.targetIndex;\n            while (node !== null) {\n                if (targetIndex === factoryIndex) {\n                    behaviors[behaviorIndex] = factory.createBehavior(node);\n                    break;\n                }\n                else {\n                    node = walker.nextNode();\n                    targetIndex++;\n                }\n            }\n        }\n        if (this.hasHostBehaviors) {\n            const hostFactories = this.hostBehaviorFactories;\n            for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {\n                behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);\n            }\n        }\n        return new HTMLView(fragment, behaviors);\n    }\n    /**\n     * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.\n     * @param source - The data source to bind the template to.\n     * @param host - The Element where the template will be rendered.\n     * @param hostBindingTarget - An HTML element to target the host bindings at if different from the\n     * host that the template is being attached to.\n     */\n    render(source, host, hostBindingTarget) {\n        if (typeof host === \"string\") {\n            host = document.getElementById(host);\n        }\n        if (hostBindingTarget === void 0) {\n            hostBindingTarget = host;\n        }\n        const view = this.create(hostBindingTarget);\n        view.bind(source, defaultExecutionContext);\n        view.appendTo(host);\n        return view;\n    }\n}\n// Much thanks to LitHTML for working this out!\nconst lastAttributeNameRegex = \n/* eslint-disable-next-line no-control-regex */\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n/**\n * Transforms a template literal string into a renderable ViewTemplate.\n * @param strings - The string fragments that are interpolated with the values.\n * @param values - The values that are interpolated with the string fragments.\n * @remarks\n * The html helper supports interpolation of strings, numbers, binding expressions,\n * other template instances, and Directive instances.\n * @public\n */\nexport function html(strings, ...values) {\n    const directives = [];\n    let html = \"\";\n    for (let i = 0, ii = strings.length - 1; i < ii; ++i) {\n        const currentString = strings[i];\n        let value = values[i];\n        html += currentString;\n        if (value instanceof ViewTemplate) {\n            const template = value;\n            value = () => template;\n        }\n        if (typeof value === \"function\") {\n            value = new HTMLBindingDirective(value);\n        }\n        if (value instanceof TargetedHTMLDirective) {\n            const match = lastAttributeNameRegex.exec(currentString);\n            if (match !== null) {\n                value.targetName = match[2];\n            }\n        }\n        if (value instanceof HTMLDirective) {\n            // Since not all values are directives, we can't use i\n            // as the index for the placeholder. Instead, we need to\n            // use directives.length to get the next index.\n            html += value.createPlaceholder(directives.length);\n            directives.push(value);\n        }\n        else {\n            html += value;\n        }\n    }\n    html += strings[strings.length - 1];\n    return new ViewTemplate(html, directives);\n}\n"]},"metadata":{},"sourceType":"module"}